<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueMetaBase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Hop Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.hop.core.row.value</a> &gt; <span class="el_source">ValueMetaBase.java</span></div><h1>ValueMetaBase.java</h1><pre class="source lang-java linenums">//CHECKSTYLE:FileLength:OFF
/*! ******************************************************************************
 *
 * Hop : The Hop Orchestration Platform
 *
 * http://www.project-hop.org
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.apache.hop.core.row.value;

import org.apache.hop.core.Const;
import org.apache.hop.core.database.DatabaseMeta;
import org.apache.hop.core.database.IDatabase;
import org.apache.hop.core.exception.HopDatabaseException;
import org.apache.hop.core.exception.HopEofException;
import org.apache.hop.core.exception.HopException;
import org.apache.hop.core.exception.HopFileException;
import org.apache.hop.core.exception.HopValueException;
import org.apache.hop.core.logging.HopLogStore;
import org.apache.hop.core.logging.ILogChannel;
import org.apache.hop.core.row.IValueMeta;
import org.apache.hop.core.row.ValueDataUtil;
import org.apache.hop.core.util.EnvUtil;
import org.apache.hop.core.util.Utils;
import org.apache.hop.core.xml.XmlHandler;
import org.apache.hop.i18n.BaseMessages;
import org.w3c.dom.Node;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.net.InetAddress;
import java.net.SocketTimeoutException;
import java.nio.charset.Charset;
import java.sql.Blob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.Collator;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

public class ValueMetaBase implements IValueMeta {

  // region Default Numeric Types Parse Format
<span class="fc" id="L78">  public static final String DEFAULT_INTEGER_PARSE_MASK = Const.NVL(</span>
<span class="fc" id="L79">    EnvUtil.getSystemProperty( Const.HOP_DEFAULT_INTEGER_FORMAT ), &quot;####0&quot; );</span>
<span class="fc" id="L80">  public static final String DEFAULT_NUMBER_PARSE_MASK = Const.NVL(</span>
<span class="fc" id="L81">    EnvUtil.getSystemProperty( Const.HOP_DEFAULT_NUMBER_FORMAT ), &quot;####0.0#########&quot; );</span>
<span class="fc" id="L82">  public static final String DEFAULT_BIGNUMBER_PARSE_MASK = Const.NVL(</span>
<span class="fc" id="L83">    EnvUtil.getSystemProperty( Const.HOP_DEFAULT_BIGNUMBER_FORMAT ), &quot;######0.0###################&quot; );</span>

<span class="fc" id="L85">  public static final String DEFAULT_DATE_PARSE_MASK = Const.NVL( EnvUtil</span>
<span class="fc" id="L86">    .getSystemProperty( Const.HOP_DEFAULT_DATE_FORMAT ), &quot;yyyy/MM/dd HH:mm:ss.SSS&quot; );</span>
<span class="fc" id="L87">  public static final String DEFAULT_TIMESTAMP_PARSE_MASK = Const.NVL( EnvUtil</span>
<span class="fc" id="L88">    .getSystemProperty( Const.HOP_DEFAULT_DATE_FORMAT ), &quot;yyyy/MM/dd HH:mm:ss.SSSSSSSSS&quot; );</span>
  // endregion

  // region Default Types Format
  public static final String DEFAULT_INTEGER_FORMAT_MASK;
  public static final String DEFAULT_NUMBER_FORMAT_MASK;

  static {
<span class="fc" id="L96">    DEFAULT_INTEGER_FORMAT_MASK = Const.NVL(</span>
<span class="fc" id="L97">      EnvUtil.getSystemProperty( Const.HOP_DEFAULT_INTEGER_FORMAT ),</span>
      &quot;####0;-####0&quot; );
<span class="fc" id="L99">    DEFAULT_NUMBER_FORMAT_MASK = Const.NVL(</span>
<span class="fc" id="L100">      EnvUtil.getSystemProperty( Const.HOP_DEFAULT_NUMBER_FORMAT ),</span>
      &quot;####0.0#########;-####0.0#########&quot; );
  }

<span class="fc" id="L104">  public static final String DEFAULT_BIG_NUMBER_FORMAT_MASK = Const.NVL(</span>
<span class="fc" id="L105">    EnvUtil.getSystemProperty( Const.HOP_DEFAULT_BIGNUMBER_FORMAT ),</span>
    &quot;######0.0###################;-######0.0###################&quot; );

<span class="fc" id="L108">  public static final String DEFAULT_DATE_FORMAT_MASK = Const.NVL( EnvUtil</span>
<span class="fc" id="L109">    .getSystemProperty( Const.HOP_DEFAULT_DATE_FORMAT ), &quot;yyyy/MM/dd HH:mm:ss.SSS&quot; );</span>

<span class="fc" id="L111">  public static final String DEFAULT_TIMESTAMP_FORMAT_MASK = Const.NVL( EnvUtil</span>
<span class="fc" id="L112">    .getSystemProperty( Const.HOP_DEFAULT_TIMESTAMP_FORMAT ), &quot;yyyy/MM/dd HH:mm:ss.SSSSSSSSS&quot; );</span>
  // endregion

  // region ValueMetaBase Attributes
<span class="fc" id="L116">  public static final Class&lt;?&gt; PKG = Const.class; // for i18n purposes, needed by Translator</span>

  public static final String XML_META_TAG = &quot;value-meta&quot;;
  public static final String XML_DATA_TAG = &quot;value-data&quot;;

  public static final String COMPATIBLE_DATE_FORMAT_PATTERN = &quot;yyyy/MM/dd HH:mm:ss.SSS&quot;;

  protected String name;
  protected int length;
  protected int precision;
  protected int type;
  protected int trimType;
  protected int storageType;

  protected String origin;
  protected String comments;
  protected Object[] index;
  protected String conversionMask;
  protected String stringEncoding;
  protected String decimalSymbol;
  protected String groupingSymbol;
  protected String currencySymbol;
  protected int collatorStrength;
  protected boolean caseInsensitive;
  protected boolean collatorDisabled;
  protected boolean sortedDescending;
  protected boolean outputPaddingEnabled;
  protected boolean largeTextField;
  protected Locale collatorLocale;
  protected Collator collator;
  protected Locale dateFormatLocale;
  protected TimeZone dateFormatTimeZone;
  protected boolean dateFormatLenient;
  protected boolean lenientStringToNumber;
  protected boolean ignoreTimezone;
  protected boolean emptyStringAndNullAreDifferent;

  protected SimpleDateFormat dateFormat;
  protected boolean dateFormatChanged;

  protected DecimalFormat decimalFormat;
  protected boolean decimalFormatChanged;

  protected IValueMeta storageMetadata;
  protected boolean identicalFormat;

  protected IValueMeta conversionMetadata;

  boolean singleByteEncoding;

  protected long numberOfBinaryStringConversions;

  protected boolean bigNumberFormatting;

  // get &amp; store original result set meta data for later use
  // @see java.sql.ResultSetMetaData
  //
  protected int originalColumnType;
  protected String originalColumnTypeName;
  protected int originalPrecision;
  protected int originalScale;
  protected boolean originalAutoIncrement;
  protected int originalNullable;
  protected boolean originalSigned;

  protected boolean ignoreWhitespace;

  protected final Comparator&lt;Object&gt; comparator;

<span class="fc" id="L185">  private static final ILogChannel log = HopLogStore.getLogChannelFactory().create( &quot;ValueMetaBase&quot; );</span>

  /**
   * The trim type codes
   */
<span class="fc" id="L190">  public static final String[] trimTypeCode = { &quot;none&quot;, &quot;left&quot;, &quot;right&quot;, &quot;both&quot; };</span>

  /**
   * The trim description
   */
<span class="fc" id="L195">  public static final String[] trimTypeDesc =</span>
<span class="fc" id="L196">    { BaseMessages.getString( PKG, &quot;ValueMeta.TrimType.None&quot; ),</span>
<span class="fc" id="L197">      BaseMessages.getString( PKG, &quot;ValueMeta.TrimType.Left&quot; ),</span>
<span class="fc" id="L198">      BaseMessages.getString( PKG, &quot;ValueMeta.TrimType.Right&quot; ),</span>
<span class="fc" id="L199">      BaseMessages.getString( PKG, &quot;ValueMeta.TrimType.Both&quot; ) };</span>
  // endregion

  public ValueMetaBase() {
<span class="fc" id="L203">    this( null, IValueMeta.TYPE_NONE, -1, -1 );</span>
<span class="fc" id="L204">  }</span>

  public ValueMetaBase( String name ) {
<span class="fc" id="L207">    this( name, IValueMeta.TYPE_NONE, -1, -1 );</span>
<span class="fc" id="L208">  }</span>

  public ValueMetaBase( String name, int type ) {
<span class="fc" id="L211">    this( name, type, -1, -1 );</span>
<span class="fc" id="L212">  }</span>

  public ValueMetaBase( String name, int type, Comparator&lt;Object&gt; comparator ) {
<span class="nc" id="L215">    this( name, type, -1, -1, comparator );</span>
<span class="nc" id="L216">  }</span>

  public ValueMetaBase( String name, int type, int length, int precision ) {
<span class="fc" id="L219">    this( name, type, length, precision, null );</span>
<span class="fc" id="L220">  }</span>

<span class="fc" id="L222">  public ValueMetaBase( String name, int type, int length, int precision, Comparator&lt;Object&gt; comparator ) {</span>
<span class="fc" id="L223">    this.name = name;</span>
<span class="fc" id="L224">    this.type = type;</span>
<span class="fc" id="L225">    this.length = length;</span>
<span class="fc" id="L226">    this.precision = precision;</span>
<span class="fc" id="L227">    this.storageType = STORAGE_TYPE_NORMAL;</span>
<span class="fc" id="L228">    this.sortedDescending = false;</span>
<span class="fc" id="L229">    this.outputPaddingEnabled = false;</span>
<span class="fc" id="L230">    this.decimalSymbol = &quot;&quot; + Const.DEFAULT_DECIMAL_SEPARATOR;</span>
<span class="fc" id="L231">    this.groupingSymbol = &quot;&quot; + Const.DEFAULT_GROUPING_SEPARATOR;</span>
<span class="fc" id="L232">    this.currencySymbol = &quot;&quot; + Const.DEFAULT_CURRENCY_SYMBOL;</span>
<span class="fc" id="L233">    this.dateFormatLocale = Locale.getDefault();</span>
<span class="fc" id="L234">    this.collatorDisabled = true;</span>
<span class="fc" id="L235">    this.collatorLocale = Locale.getDefault();</span>
<span class="fc" id="L236">    this.collator = Collator.getInstance( this.collatorLocale );</span>
<span class="fc" id="L237">    this.collatorStrength = 0;</span>
<span class="fc" id="L238">    this.dateFormatTimeZone = TimeZone.getDefault();</span>
<span class="fc" id="L239">    this.identicalFormat = true;</span>
<span class="fc" id="L240">    this.bigNumberFormatting = true;</span>
<span class="fc" id="L241">    this.lenientStringToNumber = convertStringToBoolean( Const.NVL( System.getProperty( Const.HOP_LENIENT_STRING_TO_NUMBER_CONVERSION, &quot;N&quot; ), &quot;N&quot; ) );</span>
<span class="fc" id="L242">    this.ignoreTimezone = convertStringToBoolean( Const.NVL( System.getProperty( Const.HOP_COMPATIBILITY_DB_IGNORE_TIMEZONE, &quot;N&quot; ), &quot;N&quot; ) );</span>
<span class="fc" id="L243">    this.emptyStringAndNullAreDifferent = convertStringToBoolean( Const.NVL( System.getProperty( Const.HOP_EMPTY_STRING_DIFFERS_FROM_NULL, &quot;N&quot; ), &quot;N&quot; ) );</span>

<span class="fc" id="L245">    this.comparator = comparator;</span>
<span class="fc" id="L246">    determineSingleByteEncoding();</span>
<span class="fc" id="L247">    setDefaultConversionMask();</span>
<span class="fc" id="L248">  }</span>

  public ValueMetaBase( Node node ) throws HopException {
<span class="fc" id="L251">    this();</span>

<span class="fc" id="L253">    type = getType( XmlHandler.getTagValue( node, &quot;type&quot; ) );</span>
<span class="fc" id="L254">    storageType = getStorageType( XmlHandler.getTagValue( node, &quot;storagetype&quot; ) );</span>

<span class="pc bpc" id="L256" title="2 of 3 branches missed.">    switch ( storageType ) {</span>
      case STORAGE_TYPE_INDEXED:
<span class="nc" id="L258">        Node indexNode = XmlHandler.getSubNode( node, &quot;index&quot; );</span>
<span class="nc" id="L259">        int nrIndexes = XmlHandler.countNodes( indexNode, &quot;value&quot; );</span>
<span class="nc" id="L260">        index = new Object[ nrIndexes ];</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">        for ( int i = 0; i &lt; index.length; i++ ) {</span>
<span class="nc" id="L263">          Node valueNode = XmlHandler.getSubNodeByNr( indexNode, &quot;value&quot;, i );</span>
<span class="nc" id="L264">          String valueString = XmlHandler.getNodeValue( valueNode );</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">          if ( Utils.isEmpty( valueString ) ) {</span>
<span class="nc" id="L266">            index[ i ] = null;</span>
          } else {
<span class="nc bnc" id="L268" title="All 8 branches missed.">            switch ( type ) {</span>
              case TYPE_STRING:
<span class="nc" id="L270">                index[ i ] = valueString;</span>
<span class="nc" id="L271">                break;</span>
              case TYPE_NUMBER:
<span class="nc" id="L273">                index[ i ] = Double.parseDouble( valueString );</span>
<span class="nc" id="L274">                break;</span>
              case TYPE_INTEGER:
<span class="nc" id="L276">                index[ i ] = Long.parseLong( valueString );</span>
<span class="nc" id="L277">                break;</span>
              case TYPE_DATE:
<span class="nc" id="L279">                index[ i ] = XmlHandler.stringToDate( valueString );</span>
<span class="nc" id="L280">                break;</span>
              case TYPE_BIGNUMBER:
<span class="nc" id="L282">                index[ i ] = new BigDecimal( valueString );</span>
<span class="nc" id="L283">                break;</span>
              case TYPE_BOOLEAN:
<span class="nc" id="L285">                index[ i ] = Boolean.valueOf( &quot;Y&quot;.equalsIgnoreCase( valueString ) );</span>
<span class="nc" id="L286">                break;</span>
              case TYPE_BINARY:
<span class="nc" id="L288">                index[ i ] = XmlHandler.stringToBinary( valueString );</span>
<span class="nc" id="L289">                break;</span>
              default:
<span class="nc" id="L291">                throw new HopException( toString()</span>
<span class="nc" id="L292">                  + &quot; : Unable to de-serialize index storage type from XML for data type &quot; + getType() );</span>
            }
          }
        }
<span class="nc" id="L296">        break;</span>

      case STORAGE_TYPE_BINARY_STRING:
        // Load the storage meta data...
        //
<span class="nc" id="L301">        Node storageMetaNode = XmlHandler.getSubNode( node, &quot;storage-meta&quot; );</span>
<span class="nc" id="L302">        Node storageValueMetaNode = XmlHandler.getSubNode( storageMetaNode, XML_META_TAG );</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if ( storageValueMetaNode != null ) {</span>
<span class="nc" id="L304">          storageMetadata = new ValueMetaBase( storageValueMetaNode );</span>
        }
        break;

      default:
        break;
    }

<span class="fc" id="L312">    name = XmlHandler.getTagValue( node, &quot;name&quot; );</span>
<span class="fc" id="L313">    length = Integer.parseInt( XmlHandler.getTagValue( node, &quot;length&quot; ) );</span>
<span class="fc" id="L314">    precision = Integer.parseInt( XmlHandler.getTagValue( node, &quot;precision&quot; ) );</span>
<span class="fc" id="L315">    origin = XmlHandler.getTagValue( node, &quot;origin&quot; );</span>
<span class="fc" id="L316">    comments = XmlHandler.getTagValue( node, &quot;comments&quot; );</span>
<span class="fc" id="L317">    conversionMask = XmlHandler.getTagValue( node, &quot;conversion_Mask&quot; );</span>
<span class="fc" id="L318">    decimalSymbol = XmlHandler.getTagValue( node, &quot;decimal_symbol&quot; );</span>
<span class="fc" id="L319">    groupingSymbol = XmlHandler.getTagValue( node, &quot;grouping_symbol&quot; );</span>
<span class="fc" id="L320">    currencySymbol = XmlHandler.getTagValue( node, &quot;currency_symbol&quot; );</span>
<span class="fc" id="L321">    trimType = getTrimTypeByCode( XmlHandler.getTagValue( node, &quot;trim_type&quot; ) );</span>
<span class="fc" id="L322">    caseInsensitive = &quot;Y&quot;.equalsIgnoreCase( XmlHandler.getTagValue( node, &quot;case_insensitive&quot; ) );</span>
<span class="fc" id="L323">    collatorDisabled = &quot;Y&quot;.equalsIgnoreCase( XmlHandler.getTagValue( node, &quot;collator_disabled&quot; ) );</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">    if ( XmlHandler.getTagValue( node, &quot;collator_strength&quot; ) != null ) {</span>
<span class="fc" id="L325">      collatorStrength = Integer.parseInt( XmlHandler.getTagValue( node, &quot;collator_strength&quot; ) );</span>
    }
<span class="fc" id="L327">    sortedDescending = &quot;Y&quot;.equalsIgnoreCase( XmlHandler.getTagValue( node, &quot;sort_descending&quot; ) );</span>
<span class="fc" id="L328">    outputPaddingEnabled = &quot;Y&quot;.equalsIgnoreCase( XmlHandler.getTagValue( node, &quot;output_padding&quot; ) );</span>
<span class="fc" id="L329">    dateFormatLenient = &quot;Y&quot;.equalsIgnoreCase( XmlHandler.getTagValue( node, &quot;date_format_lenient&quot; ) );</span>
<span class="fc" id="L330">    String dateFormatLocaleString = XmlHandler.getTagValue( node, &quot;date_format_locale&quot; );</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">    if ( !Utils.isEmpty( dateFormatLocaleString ) ) {</span>
<span class="fc" id="L332">      dateFormatLocale = EnvUtil.createLocale( dateFormatLocaleString );</span>
    }
<span class="fc" id="L334">    String dateTimeZoneString = XmlHandler.getTagValue( node, &quot;date_format_timezone&quot; );</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">    if ( !Utils.isEmpty( dateTimeZoneString ) ) {</span>
<span class="nc" id="L336">      dateFormatTimeZone = EnvUtil.createTimeZone( dateTimeZoneString );</span>
    } else {
<span class="fc" id="L338">      dateFormatTimeZone = TimeZone.getDefault();</span>
    }
<span class="fc" id="L340">    lenientStringToNumber = &quot;Y&quot;.equalsIgnoreCase( XmlHandler.getTagValue( node, &quot;lenient_string_to_number&quot; ) );</span>
<span class="fc" id="L341">  }</span>

  /**
   * Create a new Value meta object.
   *
   * @param inputStream
   * @throws HopFileException
   * @throws HopEofException
   * @deprecated in favor of a combination of {@link ValueMetaFactory}.createValueMeta() and the loadMetaData() method.
   */
  @Deprecated
  public ValueMetaBase( DataInputStream inputStream ) throws HopFileException, HopEofException {
<span class="fc" id="L353">    this();</span>
    try {
<span class="fc" id="L355">      type = inputStream.readInt();</span>
<span class="nc" id="L356">    } catch ( EOFException e ) {</span>
<span class="nc" id="L357">      throw new HopEofException( e );</span>
<span class="nc" id="L358">    } catch ( IOException e ) {</span>
<span class="nc" id="L359">      throw new HopFileException( toString() + &quot; : Unable to read value metadata from input stream&quot;, e );</span>
<span class="fc" id="L360">    }</span>

<span class="fc" id="L362">    readMetaData( inputStream );</span>
<span class="fc" id="L363">  }</span>

<span class="fc" id="L365">  public static final String[] SINGLE_BYTE_ENCODINGS = new String[] { &quot;ISO8859_1&quot;, &quot;Cp1252&quot;, &quot;ASCII&quot;, &quot;Cp037&quot;, &quot;Cp273&quot;,</span>
    &quot;Cp277&quot;, &quot;Cp278&quot;, &quot;Cp280&quot;, &quot;Cp284&quot;, &quot;Cp285&quot;, &quot;Cp297&quot;, &quot;Cp420&quot;, &quot;Cp424&quot;, &quot;Cp437&quot;, &quot;Cp500&quot;, &quot;Cp737&quot;, &quot;Cp775&quot;,
    &quot;Cp850&quot;, &quot;Cp852&quot;, &quot;Cp855&quot;, &quot;Cp856&quot;, &quot;Cp857&quot;, &quot;Cp858&quot;, &quot;Cp860&quot;, &quot;Cp861&quot;, &quot;Cp862&quot;, &quot;Cp863&quot;, &quot;Cp865&quot;, &quot;Cp866&quot;,
    &quot;Cp869&quot;, &quot;Cp870&quot;, &quot;Cp871&quot;, &quot;Cp875&quot;, &quot;Cp918&quot;, &quot;Cp921&quot;, &quot;Cp922&quot;, &quot;Cp1140&quot;, &quot;Cp1141&quot;, &quot;Cp1142&quot;, &quot;Cp1143&quot;, &quot;Cp1144&quot;,
    &quot;Cp1145&quot;, &quot;Cp1146&quot;, &quot;Cp1147&quot;, &quot;Cp1148&quot;, &quot;Cp1149&quot;, &quot;Cp1250&quot;, &quot;Cp1251&quot;, &quot;Cp1253&quot;, &quot;Cp1254&quot;, &quot;Cp1255&quot;, &quot;Cp1257&quot;,
    &quot;ISO8859_2&quot;, &quot;ISO8859_3&quot;, &quot;ISO8859_5&quot;, &quot;ISO8859_5&quot;, &quot;ISO8859_6&quot;, &quot;ISO8859_7&quot;, &quot;ISO8859_8&quot;, &quot;ISO8859_9&quot;,
    &quot;ISO8859_13&quot;, &quot;ISO8859_15&quot;, &quot;ISO8859_15_FDIS&quot;, &quot;MacCentralEurope&quot;, &quot;MacCroatian&quot;, &quot;MacCyrillic&quot;, &quot;MacDingbat&quot;,
    &quot;MacGreek&quot;, &quot;MacHebrew&quot;, &quot;MacIceland&quot;, &quot;MacRoman&quot;, &quot;MacRomania&quot;, &quot;MacSymbol&quot;, &quot;MacTurkish&quot;, &quot;MacUkraine&quot;, };

  protected void setDefaultConversionMask() {
    // Set some sensible default mask on the numbers
    //
<span class="fc bfc" id="L377" title="All 4 branches covered.">    switch ( getType() ) {</span>
      case TYPE_INTEGER:
<span class="fc" id="L379">        setConversionMask( DEFAULT_INTEGER_FORMAT_MASK );</span>
<span class="fc" id="L380">        break;</span>
      case TYPE_NUMBER:
<span class="fc" id="L382">        setConversionMask( DEFAULT_NUMBER_FORMAT_MASK );</span>
<span class="fc" id="L383">        break;</span>
      case TYPE_BIGNUMBER:
<span class="fc" id="L385">        setConversionMask( DEFAULT_BIG_NUMBER_FORMAT_MASK );</span>

<span class="fc" id="L387">        setGroupingSymbol( null );</span>
<span class="fc" id="L388">        setDecimalSymbol( &quot;.&quot; ); // For backward compatibility reasons!</span>
<span class="fc" id="L389">        break;</span>
      default:
        // does nothing
    }
<span class="fc" id="L393">  }</span>

  protected void determineSingleByteEncoding() {
<span class="fc" id="L396">    singleByteEncoding = false;</span>

    Charset cs;
<span class="fc bfc" id="L399" title="All 2 branches covered.">    if ( Utils.isEmpty( stringEncoding ) ) {</span>
<span class="fc" id="L400">      cs = Charset.defaultCharset();</span>
    } else {
<span class="fc" id="L402">      cs = Charset.forName( stringEncoding );</span>
    }

    // See if the default character set for input is single byte encoded.
    //
<span class="fc bfc" id="L407" title="All 2 branches covered.">    for ( String charSetEncoding : SINGLE_BYTE_ENCODINGS ) {</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">      if ( cs.toString().equalsIgnoreCase( charSetEncoding ) ) {</span>
<span class="nc" id="L409">        singleByteEncoding = true;</span>
      }
    }
<span class="fc" id="L412">  }</span>

  @Override
  public ValueMetaBase clone() {
    try {
<span class="fc" id="L417">      ValueMetaBase valueMeta = (ValueMetaBase) super.clone();</span>
<span class="fc" id="L418">      valueMeta.dateFormat = null;</span>
<span class="fc" id="L419">      valueMeta.decimalFormat = null;</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">      if ( dateFormatLocale != null ) {</span>
<span class="fc" id="L421">        valueMeta.dateFormatLocale = (Locale) dateFormatLocale.clone();</span>
      }
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">      if ( dateFormatTimeZone != null ) {</span>
<span class="fc" id="L424">        valueMeta.dateFormatTimeZone = (TimeZone) dateFormatTimeZone.clone();</span>
      }
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">      if ( storageMetadata != null ) {</span>
<span class="nc" id="L427">        valueMeta.storageMetadata = storageMetadata.clone();</span>
      }
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">      if ( conversionMetadata != null ) {</span>
<span class="nc" id="L430">        valueMeta.conversionMetadata = conversionMetadata.clone();</span>
      }

<span class="fc" id="L433">      valueMeta.compareStorageAndActualFormat();</span>

<span class="fc" id="L435">      return valueMeta;</span>
<span class="nc" id="L436">    } catch ( CloneNotSupportedException e ) {</span>
<span class="nc" id="L437">      return null;</span>
    }
  }

  /**
   * @return the comments
   */
  @Override
  public String getComments() {
<span class="fc" id="L446">    return comments;</span>
  }

  /**
   * @param comments the comments to set
   */
  @Override
  public void setComments( String comments ) {
<span class="fc" id="L454">    this.comments = comments;</span>
<span class="fc" id="L455">  }</span>

  /**
   * @return the index
   */
  @Override
  public Object[] getIndex() {
<span class="fc" id="L462">    return index;</span>
  }

  /**
   * @param index the index to set
   */
  @Override
  public void setIndex( Object[] index ) {
<span class="fc" id="L470">    this.index = index;</span>
<span class="fc" id="L471">  }</span>

  /**
   * @return the length
   */
  @Override
  public int getLength() {
<span class="fc" id="L478">    return length;</span>
  }

  /**
   * @param length the length to set
   */
  @Override
  public void setLength( int length ) {
<span class="fc" id="L486">    this.length = length;</span>
<span class="fc" id="L487">  }</span>

  /**
   * @param length the length to set
   */
  @Override
  public void setLength( int length, int precision ) {
<span class="fc" id="L494">    this.length = length;</span>
<span class="fc" id="L495">    this.precision = precision;</span>
<span class="fc" id="L496">  }</span>

  /**
   * @return
   */
  boolean isLengthInvalidOrZero() {
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">    return this.length &lt; 1;</span>
  }

  /**
   * @return the name
   */
  @Override
  public String getName() {
<span class="fc" id="L510">    return name;</span>
  }

  /**
   * @param name the name to set
   */
  @Override
  public void setName( String name ) {
<span class="fc" id="L518">    this.name = name;</span>
<span class="fc" id="L519">  }</span>

  /**
   * @return the origin
   */
  @Override
  public String getOrigin() {
<span class="fc" id="L526">    return origin;</span>
  }

  /**
   * @param origin the origin to set
   */
  @Override
  public void setOrigin( String origin ) {
<span class="fc" id="L534">    this.origin = origin;</span>
<span class="fc" id="L535">  }</span>

  /**
   * @return the precision
   */
  @Override
  public int getPrecision() {
    // For backward compatibility we need to tweak a bit...
    //
<span class="fc bfc" id="L544" title="All 4 branches covered.">    if ( isInteger() || isBinary() ) {</span>
<span class="fc" id="L545">      return 0;</span>
    }
<span class="fc bfc" id="L547" title="All 4 branches covered.">    if ( isString() || isBoolean() ) {</span>
<span class="fc" id="L548">      return -1;</span>
    }

<span class="fc" id="L551">    return precision;</span>
  }

  /**
   * @param precision the precision to set
   */
  @Override
  public void setPrecision( int precision ) {
<span class="fc" id="L559">    this.precision = precision;</span>
<span class="fc" id="L560">  }</span>

  /**
   * @return the storageType
   */
  @Override
  public int getStorageType() {
<span class="fc" id="L567">    return storageType;</span>
  }

  /**
   * @param storageType the storageType to set
   */
  @Override
  public void setStorageType( int storageType ) {
<span class="fc" id="L575">    this.storageType = storageType;</span>
<span class="fc" id="L576">  }</span>

  @Override
  public boolean isStorageNormal() {
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">    return storageType == STORAGE_TYPE_NORMAL;</span>
  }

  @Override
  public boolean isStorageIndexed() {
<span class="nc bnc" id="L585" title="All 2 branches missed.">    return storageType == STORAGE_TYPE_INDEXED;</span>
  }

  @Override
  public boolean isStorageBinaryString() {
<span class="fc bfc" id="L590" title="All 2 branches covered.">    return storageType == STORAGE_TYPE_BINARY_STRING;</span>
  }

  /**
   * @return the type
   */
  @Override
  public int getType() {
<span class="fc" id="L598">    return type;</span>
  }

  /**
   * @return the conversionMask
   */
  @Override
  @Deprecated
  public String getConversionMask() {
<span class="fc" id="L607">    return conversionMask;</span>
  }

  /**
   * @param conversionMask the conversionMask to set
   */
  @Override
  public void setConversionMask( String conversionMask ) {
<span class="fc" id="L615">    this.conversionMask = conversionMask;</span>
<span class="fc" id="L616">    dateFormatChanged = true;</span>
<span class="fc" id="L617">    decimalFormatChanged = true;</span>
<span class="fc" id="L618">    compareStorageAndActualFormat();</span>
<span class="fc" id="L619">  }</span>

  /**
   * @return the encoding
   */
  @Override
  public String getStringEncoding() {
<span class="fc" id="L626">    return stringEncoding;</span>
  }

  /**
   * @param encoding the encoding to set
   */
  @Override
  public void setStringEncoding( String encoding ) {
<span class="fc" id="L634">    this.stringEncoding = encoding;</span>
<span class="fc" id="L635">    determineSingleByteEncoding();</span>
<span class="fc" id="L636">    compareStorageAndActualFormat();</span>
<span class="fc" id="L637">  }</span>

  /**
   * @return the decimalSymbol
   */
  @Override
  public String getDecimalSymbol() {
<span class="fc" id="L644">    return decimalSymbol;</span>
  }

  /**
   * @param decimalSymbol the decimalSymbol to set
   */
  @Override
  public void setDecimalSymbol( String decimalSymbol ) {
<span class="fc" id="L652">    this.decimalSymbol = decimalSymbol;</span>
<span class="fc" id="L653">    decimalFormatChanged = true;</span>
<span class="fc" id="L654">    compareStorageAndActualFormat();</span>
<span class="fc" id="L655">  }</span>

  /**
   * @return the groupingSymbol
   */
  @Override
  public String getGroupingSymbol() {
<span class="fc" id="L662">    return groupingSymbol;</span>
  }

  /**
   * @param groupingSymbol the groupingSymbol to set
   */
  @Override
  public void setGroupingSymbol( String groupingSymbol ) {
<span class="fc" id="L670">    this.groupingSymbol = groupingSymbol;</span>
<span class="fc" id="L671">    decimalFormatChanged = true;</span>
<span class="fc" id="L672">    compareStorageAndActualFormat();</span>
<span class="fc" id="L673">  }</span>

  /**
   * @return the currencySymbol
   */
  @Override
  public String getCurrencySymbol() {
<span class="fc" id="L680">    return currencySymbol;</span>
  }

  /**
   * @param currencySymbol the currencySymbol to set
   */
  @Override
  public void setCurrencySymbol( String currencySymbol ) {
<span class="fc" id="L688">    this.currencySymbol = currencySymbol;</span>
<span class="fc" id="L689">    decimalFormatChanged = true;</span>
<span class="fc" id="L690">  }</span>

  /**
   * @return the caseInsensitive
   */
  @Override
  public boolean isCaseInsensitive() {
<span class="fc" id="L697">    return caseInsensitive;</span>
  }

  /**
   * @param caseInsensitive the caseInsensitive to set
   */
  @Override
  public void setCaseInsensitive( boolean caseInsensitive ) {
<span class="fc" id="L705">    this.caseInsensitive = caseInsensitive;</span>
<span class="fc" id="L706">  }</span>

  /**
   * @return the collatorDisabled
   */
  @Override
  public boolean isCollatorDisabled() {
<span class="fc" id="L713">    return collatorDisabled;</span>
  }

  /**
   * @param collatorDisabled the collatorDisabled to set
   */
  @Override
  public void setCollatorDisabled( boolean collatorDisabled ) {
<span class="fc" id="L721">    this.collatorDisabled = collatorDisabled;</span>
<span class="fc" id="L722">  }</span>

  @Override
  public Locale getCollatorLocale() {
<span class="fc" id="L726">    return this.collatorLocale;</span>
  }

  /**
   * @ sets the collator Locale
   */
  @Override
  public void setCollatorLocale( Locale locale ) {
    // Update the collator only if required
<span class="pc bpc" id="L735" title="1 of 4 branches missed.">    if ( collatorLocale == null || !collatorLocale.equals( locale ) ) {</span>
<span class="fc" id="L736">      this.collatorLocale = locale;</span>
<span class="fc" id="L737">      this.collator = Collator.getInstance( locale );</span>
    }
<span class="fc" id="L739">  }</span>

  /**
   * @get the collatorStrength
   */
  @Override
  public int getCollatorStrength() {
<span class="fc" id="L746">    return collatorStrength;</span>
  }

  /**
   * @param collatorStrength the collatorStrength to set
   */
  @Override
  public void setCollatorStrength( int collatorStrength ) throws IllegalArgumentException {
    try {
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">      if ( collator != null ) {</span>
<span class="fc" id="L756">        this.collator.setStrength( collatorStrength );</span>
<span class="fc" id="L757">        this.collatorStrength = collatorStrength;</span>
      }
<span class="nc" id="L759">    } catch ( IllegalArgumentException e ) {</span>
<span class="nc" id="L760">      throw new IllegalArgumentException( &quot; : Collator strength must be an int between 0 and 3. &quot; );</span>
<span class="fc" id="L761">    }</span>
<span class="fc" id="L762">  }</span>

  /**
   * @return the sortedDescending
   */
  @Override
  public boolean isSortedDescending() {
<span class="fc" id="L769">    return sortedDescending;</span>
  }

  /**
   * @param sortedDescending the sortedDescending to set
   */
  @Override
  public void setSortedDescending( boolean sortedDescending ) {
<span class="fc" id="L777">    this.sortedDescending = sortedDescending;</span>
<span class="fc" id="L778">  }</span>

  /**
   * @return true if output padding is enabled (padding to specified length)
   */
  @Override
  public boolean isOutputPaddingEnabled() {
<span class="fc" id="L785">    return outputPaddingEnabled;</span>
  }

  /**
   * @param outputPaddingEnabled Set to true if output padding is to be enabled (padding to specified length)
   */
  @Override
  public void setOutputPaddingEnabled( boolean outputPaddingEnabled ) {
<span class="fc" id="L793">    this.outputPaddingEnabled = outputPaddingEnabled;</span>
<span class="fc" id="L794">  }</span>

  /**
   * @return true if this is a large text field (CLOB, TEXT) with arbitrary length.
   */
  @Override
  public boolean isLargeTextField() {
<span class="fc" id="L801">    return largeTextField;</span>
  }

  /**
   * @param largeTextField Set to true if this is to be a large text field (CLOB, TEXT) with arbitrary length.
   */
  @Override
  public void setLargeTextField( boolean largeTextField ) {
<span class="fc" id="L809">    this.largeTextField = largeTextField;</span>
<span class="fc" id="L810">  }</span>

  /**
   * @return the dateFormatLenient
   */
  @Override
  public boolean isDateFormatLenient() {
<span class="fc" id="L817">    return dateFormatLenient;</span>
  }

  /**
   * @param dateFormatLenient the dateFormatLenient to set
   */
  @Override
  public void setDateFormatLenient( boolean dateFormatLenient ) {
<span class="fc" id="L825">    this.dateFormatLenient = dateFormatLenient;</span>
<span class="fc" id="L826">    dateFormatChanged = true;</span>
<span class="fc" id="L827">  }</span>

  /**
   * @return the dateFormatLocale
   */
  @Override
  public Locale getDateFormatLocale() {
<span class="fc" id="L834">    return dateFormatLocale;</span>
  }

  /**
   * @param dateFormatLocale the dateFormatLocale to set
   */
  @Override
  public void setDateFormatLocale( Locale dateFormatLocale ) {
<span class="fc" id="L842">    this.dateFormatLocale = dateFormatLocale;</span>
<span class="fc" id="L843">    dateFormatChanged = true;</span>
<span class="fc" id="L844">  }</span>

  // DATE + STRING

  protected synchronized String convertDateToString( Date date ) {
<span class="fc bfc" id="L849" title="All 2 branches covered.">    if ( date == null ) {</span>
<span class="fc" id="L850">      return null;</span>
    }

<span class="fc" id="L853">    return getDateFormat().format( date );</span>
  }

<span class="fc" id="L856">  protected static SimpleDateFormat compatibleDateFormat = new SimpleDateFormat( COMPATIBLE_DATE_FORMAT_PATTERN );</span>

  protected synchronized String convertDateToCompatibleString( Date date ) {
<span class="nc bnc" id="L859" title="All 2 branches missed.">    if ( date == null ) {</span>
<span class="nc" id="L860">      return null;</span>
    }
<span class="nc" id="L862">    return compatibleDateFormat.format( date );</span>
  }

  public synchronized Date convertStringToDate( String string ) throws HopValueException {
<span class="fc" id="L866">    string = Const.trimToType( string, getTrimType() ); // see if trimming needs</span>
    // to be performed before
    // conversion

<span class="pc bpc" id="L870" title="1 of 2 branches missed.">    if ( Utils.isEmpty( string ) ) {</span>
<span class="nc" id="L871">      return null;</span>
    }

    try {
<span class="fc" id="L875">      ParsePosition pp = new ParsePosition( 0 );</span>
<span class="fc" id="L876">      Date result = getDateFormat( TYPE_DATE ).parse( string, pp );</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">      if ( pp.getErrorIndex() &gt;= 0 ) {</span>
        // error happen
<span class="fc" id="L879">        throw new ParseException( string, pp.getErrorIndex() );</span>
      }
      // some chars can be after pp.getIndex(). That means, not full value was parsed. For example, for value
      // &quot;25-03-1918 11:54&quot; and format &quot;dd-MM-yyyy&quot;, value will be &quot;25-03-1918 00:00&quot; without any exception.
      // If there are only spaces after pp.getIndex() - that means full values was parsed
<span class="fc" id="L884">      return result;</span>
<span class="fc" id="L885">    } catch ( ParseException e ) {</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">      String dateFormat = ( getDateFormat() != null ) ? getDateFormat().toPattern() : &quot;null&quot;;</span>
<span class="fc" id="L887">      throw new HopValueException( toString() + &quot; : couldn't convert string [&quot; + string</span>
<span class="fc" id="L888">        + &quot;] to a date using format [&quot; + dateFormat + &quot;] on offset location &quot; + e.getErrorOffset(), e );</span>
    }
  }

  // DATE + NUMBER

  protected Double convertDateToNumber( Date date ) {
<span class="nc" id="L895">    return new Double( date.getTime() );</span>
  }

  protected Date convertNumberToDate( Double number ) {
<span class="fc" id="L899">    return new Date( number.longValue() );</span>
  }

  // DATE + INTEGER

  protected Long convertDateToInteger( Date date ) {
<span class="fc" id="L905">    return new Long( date.getTime() );</span>
  }

  protected Date convertIntegerToDate( Long number ) {
<span class="fc" id="L909">    return new Date( number.longValue() );</span>
  }

  // DATE + BIGNUMBER

  protected BigDecimal convertDateToBigNumber( Date date ) {
<span class="nc" id="L915">    return new BigDecimal( date.getTime() );</span>
  }

  protected Date convertBigNumberToDate( BigDecimal number ) {
<span class="fc" id="L919">    return new Date( number.longValue() );</span>
  }

  public synchronized String convertNumberToString( Double number ) throws HopValueException {
<span class="fc bfc" id="L923" title="All 2 branches covered.">    if ( number == null ) {</span>
<span class="pc bpc" id="L924" title="3 of 4 branches missed.">      if ( !outputPaddingEnabled || length &lt; 1 ) {</span>
<span class="fc" id="L925">        return null;</span>
      } else {
        // Return strings padded to the specified length...
        // This is done for backward compatibility with 2.5.x
        // We just optimized this a bit...
        //
<span class="nc" id="L931">        String[] emptyPaddedStrings = Const.getEmptyPaddedStrings();</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if ( length &lt; emptyPaddedStrings.length ) {</span>
<span class="nc" id="L933">          return emptyPaddedStrings[ length ];</span>
        } else {
<span class="nc" id="L935">          return Const.rightPad( &quot;&quot;, length );</span>
        }
      }
    }

    try {
<span class="fc" id="L941">      DecimalFormat format = getDecimalFormat( false );</span>

      // When conversion masks are different, we must ensure the number precision is not lost
<span class="pc bpc" id="L944" title="1 of 4 branches missed.">      if ( this.conversionMask != null &amp;&amp; storageMetadata != null</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        &amp;&amp; !this.conversionMask.equals( storageMetadata.getConversionMask() ) ) {</span>
<span class="nc" id="L946">        format.setMaximumFractionDigits( 50 );</span>
      }
<span class="fc" id="L948">      return format.format( number );</span>
<span class="nc" id="L949">    } catch ( Exception e ) {</span>
<span class="nc" id="L950">      throw new HopValueException( toString() + &quot; : couldn't convert Number to String &quot;, e );</span>
    }
  }

  protected synchronized String convertNumberToCompatibleString( Double number ) throws HopValueException {
<span class="nc bnc" id="L955" title="All 2 branches missed.">    if ( number == null ) {</span>
<span class="nc" id="L956">      return null;</span>
    }
<span class="nc" id="L958">    return Double.toString( number );</span>
  }

  protected synchronized Double convertStringToNumber( String string ) throws HopValueException {
<span class="fc" id="L962">    string = Const.trimToType( string, getTrimType() ); // see if trimming needs</span>
    // to be performed before
    // conversion

<span class="fc bfc" id="L966" title="All 2 branches covered.">    if ( Utils.isEmpty( string ) ) {</span>
<span class="fc" id="L967">      return null;</span>
    }

    try {
<span class="fc" id="L971">      DecimalFormat format = getDecimalFormat( false );</span>
      Number number;
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">      if ( lenientStringToNumber ) {</span>
<span class="nc" id="L974">        number = format.parse( string );</span>
      } else {
<span class="fc" id="L976">        ParsePosition parsePosition = new ParsePosition( 0 );</span>
<span class="fc" id="L977">        number = format.parse( string, parsePosition );</span>

<span class="fc bfc" id="L979" title="All 2 branches covered.">        if ( parsePosition.getIndex() &lt; string.length() ) {</span>
<span class="fc" id="L980">          throw new HopValueException( toString()</span>
            + &quot; : couldn't convert String to number : non-numeric character found at position &quot;
<span class="fc" id="L982">            + ( parsePosition.getIndex() + 1 ) + &quot; for value [&quot; + string + &quot;]&quot; );</span>
        }

      }

<span class="fc" id="L987">      return new Double( number.doubleValue() );</span>
<span class="fc" id="L988">    } catch ( Exception e ) {</span>
<span class="fc" id="L989">      throw new HopValueException( toString() + &quot; : couldn't convert String to number &quot;, e );</span>
    }
  }

  @Override
  public synchronized SimpleDateFormat getDateFormat() {
<span class="fc" id="L995">    return getDateFormat( getType() );</span>
  }

  private synchronized SimpleDateFormat getDateFormat( int valueMetaType ) {
    // If we have a Date that is represented as a String
    // In that case we can set the format of the original Date on the String
    // value metadata in the form of a conversion metadata object.
    // That way, we can always convert from Date to String and back without a
    // problem, no matter how complex the format was.
    // As such, we should return the date SimpleDateFormat of the conversion
    // metadata.
    //
<span class="fc bfc" id="L1007" title="All 2 branches covered.">    if ( conversionMetadata != null ) {</span>
<span class="fc" id="L1008">      return conversionMetadata.getDateFormat();</span>
    }

<span class="fc bfc" id="L1011" title="All 4 branches covered.">    if ( dateFormat == null || dateFormatChanged ) {</span>
      // This may not become static as the class is not thread-safe!
<span class="fc" id="L1013">      dateFormat = new SimpleDateFormat();</span>

<span class="fc" id="L1015">      String mask = this.getMask( valueMetaType );</span>

      // Do we have a locale?
      //
<span class="pc bpc" id="L1019" title="2 of 4 branches missed.">      if ( dateFormatLocale == null || dateFormatLocale.equals( Locale.getDefault() ) ) {</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">        if ( mask != null ) {</span>
<span class="fc" id="L1021">          dateFormat = new SimpleDateFormat( mask );</span>
        }
      } else {
<span class="nc bnc" id="L1024" title="All 2 branches missed.">        if ( mask == null ) {</span>
<span class="nc" id="L1025">          mask = dateFormat.toPattern();</span>
        }
<span class="nc" id="L1027">        dateFormat = new SimpleDateFormat( mask, dateFormatLocale );</span>
      }

      // Do we have a time zone?
      //
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">      if ( dateFormatTimeZone != null ) {</span>
<span class="fc" id="L1033">        dateFormat.setTimeZone( dateFormatTimeZone );</span>
      }

      // Set the conversion leniency as well
      //
<span class="fc" id="L1038">      dateFormat.setLenient( dateFormatLenient );</span>

<span class="fc" id="L1040">      dateFormatChanged = false;</span>
    }

<span class="fc" id="L1043">    return dateFormat;</span>
  }

  @Override
  public synchronized DecimalFormat getDecimalFormat() {
<span class="nc" id="L1048">    return getDecimalFormat( false );</span>
  }

  @Override
  public synchronized DecimalFormat getDecimalFormat( boolean useBigDecimal ) {
    // If we have an Integer that is represented as a String
    // In that case we can set the format of the original Integer on the String
    // value metadata in the form of a conversion metadata object.
    // That way, we can always convert from Integer to String and back without a
    // problem, no matter how complex the format was.
    // As such, we should return the decimal format of the conversion metadata.
    //
<span class="fc bfc" id="L1060" title="All 2 branches covered.">    if ( conversionMetadata != null ) {</span>
<span class="fc" id="L1061">      return conversionMetadata.getDecimalFormat( useBigDecimal );</span>
    }

    // Calculate the decimal format as few times as possible.
    // That is because creating or changing a DecimalFormat object is very CPU
    // hungry.
    //
<span class="pc bpc" id="L1068" title="1 of 4 branches missed.">    if ( decimalFormat == null || decimalFormatChanged ) {</span>
<span class="fc" id="L1069">      decimalFormat = (DecimalFormat) NumberFormat.getInstance();</span>
<span class="fc" id="L1070">      decimalFormat.setParseBigDecimal( useBigDecimal );</span>
<span class="fc" id="L1071">      DecimalFormatSymbols decimalFormatSymbols = decimalFormat.getDecimalFormatSymbols();</span>

<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">      if ( !Utils.isEmpty( currencySymbol ) ) {</span>
<span class="fc" id="L1074">        decimalFormatSymbols.setCurrencySymbol( currencySymbol );</span>
      }
<span class="fc bfc" id="L1076" title="All 2 branches covered.">      if ( !Utils.isEmpty( groupingSymbol ) ) {</span>
<span class="fc" id="L1077">        decimalFormatSymbols.setGroupingSeparator( groupingSymbol.charAt( 0 ) );</span>
      }
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">      if ( !Utils.isEmpty( decimalSymbol ) ) {</span>
<span class="fc" id="L1080">        decimalFormatSymbols.setDecimalSeparator( decimalSymbol.charAt( 0 ) );</span>
      }
<span class="fc" id="L1082">      decimalFormat.setDecimalFormatSymbols( decimalFormatSymbols );</span>

<span class="fc" id="L1084">      String decimalPattern = getMask( getType() );</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">      if ( !Utils.isEmpty( decimalPattern ) ) {</span>
<span class="fc" id="L1086">        decimalFormat.applyPattern( decimalPattern );</span>
      }

<span class="fc" id="L1089">      decimalFormatChanged = false;</span>
    }

<span class="fc" id="L1092">    return decimalFormat;</span>
  }

  @Override
  public String getFormatMask() {
<span class="nc" id="L1097">    return getMask( getType() );</span>
  }

  String getMask( int type ) {
<span class="fc bfc" id="L1101" title="All 2 branches covered.">    if ( !Utils.isEmpty( this.conversionMask ) ) {</span>
<span class="fc" id="L1102">      return this.conversionMask;</span>
    }

<span class="fc" id="L1105">    boolean fromString = isString();</span>
<span class="pc bpc" id="L1106" title="1 of 6 branches missed.">    switch ( type ) {</span>
      case TYPE_INTEGER:
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">        return fromString ? DEFAULT_INTEGER_PARSE_MASK : getIntegerFormatMask();</span>
      case TYPE_NUMBER:
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">        return fromString ? DEFAULT_NUMBER_PARSE_MASK : getNumberFormatMask();</span>
      case TYPE_BIGNUMBER:
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        return fromString ? DEFAULT_BIGNUMBER_PARSE_MASK : getBigNumberFormatMask();</span>

      case TYPE_DATE:
<span class="fc bfc" id="L1115" title="All 2 branches covered.">        return fromString ? DEFAULT_DATE_PARSE_MASK : getDateFormatMask();</span>
      case TYPE_TIMESTAMP:
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">        return fromString ? DEFAULT_TIMESTAMP_PARSE_MASK : getTimestampFormatMask();</span>
    }

<span class="fc" id="L1120">    return null;</span>
  }

  String getNumberFormatMask() {
<span class="fc" id="L1124">    String numberMask = this.conversionMask;</span>

<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">    if ( Utils.isEmpty( numberMask ) ) {</span>
<span class="pc bpc" id="L1127" title="1 of 2 branches missed.">      if ( this.isLengthInvalidOrZero() ) {</span>
<span class="nc" id="L1128">        numberMask = DEFAULT_NUMBER_FORMAT_MASK;</span>
      } else {
<span class="fc" id="L1130">        numberMask = this.buildNumberPattern();</span>
      }
    }

<span class="fc" id="L1134">    return numberMask;</span>
  }

  String getIntegerFormatMask() {
<span class="fc" id="L1138">    String integerMask = this.conversionMask;</span>

<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">    if ( Utils.isEmpty( integerMask ) ) {</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">      if ( this.isLengthInvalidOrZero() ) {</span>
<span class="nc" id="L1142">        integerMask = DEFAULT_INTEGER_FORMAT_MASK;</span>
        // as
        // before
        // version
        // 3.0
      } else {
<span class="fc" id="L1148">        StringBuilder integerPattern = new StringBuilder();</span>

        // First the format for positive integers...
        //
<span class="fc" id="L1152">        integerPattern.append( &quot; &quot; );</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">        for ( int i = 0; i &lt; getLength(); i++ ) {</span>
<span class="fc" id="L1154">          integerPattern.append( '0' ); // all zeroes.</span>
        }
<span class="fc" id="L1156">        integerPattern.append( &quot;;&quot; );</span>

        // Then the format for the negative numbers...
        //
<span class="fc" id="L1160">        integerPattern.append( &quot;-&quot; );</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">        for ( int i = 0; i &lt; getLength(); i++ ) {</span>
<span class="fc" id="L1162">          integerPattern.append( '0' ); // all zeroes.</span>
        }

<span class="fc" id="L1165">        integerMask = integerPattern.toString();</span>

      }
    }

<span class="fc" id="L1170">    return integerMask;</span>
  }

  String getBigNumberFormatMask() {
<span class="nc" id="L1174">    String bigNumberMask = this.conversionMask;</span>

<span class="nc bnc" id="L1176" title="All 2 branches missed.">    if ( Utils.isEmpty( bigNumberMask ) ) {</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">      if ( this.isLengthInvalidOrZero() ) {</span>
<span class="nc" id="L1178">        bigNumberMask = DEFAULT_BIG_NUMBER_FORMAT_MASK;</span>
      } else {
<span class="nc" id="L1180">        bigNumberMask = this.buildNumberPattern();</span>
      }
    }

<span class="nc" id="L1184">    return bigNumberMask;</span>
  }

  String getDateFormatMask() {
<span class="fc" id="L1188">    String mask = this.conversionMask;</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">    if ( Utils.isEmpty( mask ) ) {</span>
<span class="fc" id="L1190">      mask = DEFAULT_DATE_FORMAT_MASK;</span>
    }

<span class="fc" id="L1193">    return mask;</span>
  }

  String getTimestampFormatMask() {
<span class="fc" id="L1197">    String mask = conversionMask;</span>
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">    if ( Utils.isEmpty( mask ) ) {</span>
<span class="fc" id="L1199">      mask = DEFAULT_TIMESTAMP_FORMAT_MASK;</span>
    }

<span class="fc" id="L1202">    return mask;</span>
  }

  private String buildNumberPattern() {
<span class="fc" id="L1206">    StringBuilder numberPattern = new StringBuilder();</span>

    // First do the format for positive numbers...
    //
<span class="fc" id="L1210">    numberPattern.append( ' ' ); // to compensate for minus sign.</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">    if ( precision &lt; 0 ) {</span>
      // Default: two decimals
<span class="nc bnc" id="L1213" title="All 2 branches missed.">      for ( int i = 0; i &lt; length; i++ ) {</span>
<span class="nc" id="L1214">        numberPattern.append( '0' );</span>
      }
<span class="nc" id="L1216">      numberPattern.append( &quot;.00&quot; ); // for the .00</span>
    } else {
      // Floating point format 00001234,56 --&gt; (12,2)
<span class="fc bfc" id="L1219" title="All 2 branches covered.">      for ( int i = 0; i &lt;= length; i++ ) {</span>
<span class="fc" id="L1220">        numberPattern.append( '0' ); // all zeroes.</span>
      }
<span class="fc" id="L1222">      int pos = length - precision + 1;</span>
<span class="pc bpc" id="L1223" title="2 of 4 branches missed.">      if ( pos &gt;= 0 &amp;&amp; pos &lt; numberPattern.length() ) {</span>
<span class="fc" id="L1224">        numberPattern.setCharAt( length - precision + 1, '.' ); // one</span>
        // 'comma'
      }
    }

    // Now do the format for negative numbers...
    //
<span class="fc" id="L1231">    StringBuilder negativePattern = new StringBuilder( numberPattern );</span>
<span class="fc" id="L1232">    negativePattern.setCharAt( 0, '-' );</span>

<span class="fc" id="L1234">    numberPattern.append( &quot;;&quot; );</span>
<span class="fc" id="L1235">    numberPattern.append( negativePattern );</span>

    // Return the pattern...
    //
<span class="fc" id="L1239">    return numberPattern.toString();</span>
  }

  protected synchronized String convertIntegerToString( Long integer ) throws HopValueException {
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">    if ( integer == null ) {</span>
<span class="nc bnc" id="L1244" title="All 4 branches missed.">      if ( !outputPaddingEnabled || length &lt; 1 ) {</span>
<span class="nc" id="L1245">        return null;</span>
      } else {
        // Return strings padded to the specified length...
        // This is done for backward compatibility with 2.5.x
        // We just optimized this a bit...
        //
<span class="nc" id="L1251">        String[] emptyPaddedStrings = Const.getEmptyPaddedStrings();</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if ( length &lt; emptyPaddedStrings.length ) {</span>
<span class="nc" id="L1253">          return emptyPaddedStrings[ length ];</span>
        } else {
<span class="nc" id="L1255">          return Const.rightPad( &quot;&quot;, length );</span>
        }
      }
    }

    try {
<span class="fc" id="L1261">      return getDecimalFormat( false ).format( integer );</span>
<span class="nc" id="L1262">    } catch ( Exception e ) {</span>
<span class="nc" id="L1263">      throw new HopValueException( toString() + &quot; : couldn't convert Long to String &quot;, e );</span>
    }
  }

  protected synchronized String convertIntegerToCompatibleString( Long integer ) throws HopValueException {
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">    if ( integer == null ) {</span>
<span class="nc" id="L1269">      return null;</span>
    }
<span class="fc" id="L1271">    return Long.toString( integer );</span>
  }

  protected synchronized Long convertStringToInteger( String string ) throws HopValueException {
<span class="fc" id="L1275">    string = Const.trimToType( string, getTrimType() ); // see if trimming needs</span>
    // to be performed before
    // conversion

<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">    if ( Utils.isEmpty( string ) ) {</span>
<span class="nc" id="L1280">      return null;</span>
    }

    try {
      Number number;
<span class="fc bfc" id="L1285" title="All 2 branches covered.">      if ( lenientStringToNumber ) {</span>
<span class="fc" id="L1286">        number = new Long( getDecimalFormat( false ).parse( string ).longValue() );</span>
      } else {
<span class="fc" id="L1288">        ParsePosition parsePosition = new ParsePosition( 0 );</span>
<span class="fc" id="L1289">        number = getDecimalFormat( false ).parse( string, parsePosition );</span>

<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if ( parsePosition.getIndex() &lt; string.length() ) {</span>
<span class="fc" id="L1292">          throw new HopValueException( toString()</span>
            + &quot; : couldn't convert String to number : non-numeric character found at position &quot;
<span class="fc" id="L1294">            + ( parsePosition.getIndex() + 1 ) + &quot; for value [&quot; + string + &quot;]&quot; );</span>
        }

      }
<span class="fc" id="L1298">      return new Long( number.longValue() );</span>
<span class="fc" id="L1299">    } catch ( Exception e ) {</span>
<span class="fc" id="L1300">      throw new HopValueException( toString() + &quot; : couldn't convert String to Integer&quot;, e );</span>
    }
  }

  protected synchronized String convertBigNumberToString( BigDecimal number ) throws HopValueException {
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">    if ( number == null ) {</span>
<span class="nc" id="L1306">      return null;</span>
    }

    try {
<span class="fc" id="L1310">      return getDecimalFormat( bigNumberFormatting ).format( number );</span>
<span class="nc" id="L1311">    } catch ( Exception e ) {</span>
<span class="nc" id="L1312">      throw new HopValueException( toString() + &quot; : couldn't convert BigNumber to String &quot;, e );</span>
    }
  }

  protected synchronized BigDecimal convertStringToBigNumber( String string ) throws HopValueException {
<span class="fc" id="L1317">    string = Const.trimToType( string, getTrimType() ); // see if trimming needs</span>
    // to be performed before
    // conversion

<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">    if ( Utils.isEmpty( string ) ) {</span>
<span class="nc" id="L1322">      return null;</span>
    }

    try {
<span class="fc" id="L1326">      DecimalFormat format = getDecimalFormat( bigNumberFormatting );</span>
      Number number;
<span class="fc bfc" id="L1328" title="All 2 branches covered.">      if ( lenientStringToNumber ) {</span>
<span class="fc" id="L1329">        number = format.parse( string );</span>
      } else {
<span class="fc" id="L1331">        ParsePosition parsePosition = new ParsePosition( 0 );</span>
<span class="fc" id="L1332">        number = format.parse( string, parsePosition );</span>

<span class="fc bfc" id="L1334" title="All 2 branches covered.">        if ( parsePosition.getIndex() &lt; string.length() ) {</span>
<span class="fc" id="L1335">          throw new HopValueException( toString()</span>
            + &quot; : couldn't convert String to number : non-numeric character found at position &quot;
<span class="fc" id="L1337">            + ( parsePosition.getIndex() + 1 ) + &quot; for value [&quot; + string + &quot;]&quot; );</span>
        }
      }

      // PDI-17366: Cannot simply cast a number to a BigDecimal,
      //            If the Number is not a BigDecimal.
      //
<span class="fc bfc" id="L1344" title="All 2 branches covered.">      if ( number instanceof Double ) {</span>
<span class="fc" id="L1345">        return BigDecimal.valueOf( number.doubleValue() );</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">      } else if ( number instanceof Long ) {</span>
<span class="fc" id="L1347">        return BigDecimal.valueOf( number.longValue() );</span>
      }
<span class="fc" id="L1349">      return (BigDecimal) number;</span>

<span class="fc" id="L1351">    } catch ( Exception e ) {</span>
      // We added this workaround for PDI-1824
      //
      try {
<span class="nc" id="L1355">        return new BigDecimal( string );</span>
<span class="fc" id="L1356">      } catch ( NumberFormatException ex ) {</span>
<span class="fc" id="L1357">        throw new HopValueException( toString() + &quot; : couldn't convert string value '&quot; + string</span>
          + &quot;' to a big number.&quot;, ex );
      }
    }
  }

  // BOOLEAN + STRING

  protected String convertBooleanToString( Boolean bool ) {
<span class="fc bfc" id="L1366" title="All 2 branches covered.">    if ( bool == null ) {</span>
<span class="fc" id="L1367">      return null;</span>
    }
<span class="fc bfc" id="L1369" title="All 2 branches covered.">    if ( length &gt;= 3 ) {</span>
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">      return bool.booleanValue() ? &quot;true&quot; : &quot;false&quot;;</span>
    } else {
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">      return bool.booleanValue() ? &quot;Y&quot; : &quot;N&quot;;</span>
    }
  }

  public static Boolean convertStringToBoolean( String string ) {
<span class="fc bfc" id="L1377" title="All 2 branches covered.">    if ( Utils.isEmpty( string ) ) {</span>
<span class="fc" id="L1378">      return null;</span>
    }
<span class="fc bfc" id="L1380" title="All 4 branches covered.">    return &quot;Y&quot;.equalsIgnoreCase( string ) || &quot;TRUE&quot;.equalsIgnoreCase( string )</span>
<span class="pc bpc" id="L1381" title="1 of 4 branches missed.">      || &quot;YES&quot;.equalsIgnoreCase( string ) || &quot;1&quot;.equals( string );</span>
  }

  // BOOLEAN + NUMBER

  protected Double convertBooleanToNumber( Boolean bool ) {
<span class="nc bnc" id="L1387" title="All 2 branches missed.">    if ( bool == null ) {</span>
<span class="nc" id="L1388">      return null;</span>
    }
<span class="nc bnc" id="L1390" title="All 2 branches missed.">    return new Double( bool.booleanValue() ? 1.0 : 0.0 );</span>
  }

  protected Boolean convertNumberToBoolean( Double number ) {
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">    if ( number == null ) {</span>
<span class="fc" id="L1395">      return null;</span>
    }
<span class="nc bnc" id="L1397" title="All 2 branches missed.">    return Boolean.valueOf( number.intValue() != 0 );</span>
  }

  // BOOLEAN + INTEGER

  protected Long convertBooleanToInteger( Boolean bool ) {
<span class="nc bnc" id="L1403" title="All 2 branches missed.">    if ( bool == null ) {</span>
<span class="nc" id="L1404">      return null;</span>
    }
<span class="nc bnc" id="L1406" title="All 2 branches missed.">    return Long.valueOf( bool.booleanValue() ? 1L : 0L );</span>
  }

  protected Boolean convertIntegerToBoolean( Long number ) {
<span class="nc bnc" id="L1410" title="All 2 branches missed.">    if ( number == null ) {</span>
<span class="nc" id="L1411">      return null;</span>
    }
<span class="nc bnc" id="L1413" title="All 2 branches missed.">    return Boolean.valueOf( number.longValue() != 0 );</span>
  }

  // BOOLEAN + BIGNUMBER

  protected BigDecimal convertBooleanToBigNumber( Boolean bool ) {
<span class="nc bnc" id="L1419" title="All 2 branches missed.">    if ( bool == null ) {</span>
<span class="nc" id="L1420">      return null;</span>
    }
<span class="nc bnc" id="L1422" title="All 2 branches missed.">    return bool.booleanValue() ? BigDecimal.ONE : BigDecimal.ZERO;</span>
  }

  public Boolean convertBigNumberToBoolean( BigDecimal number ) {
<span class="pc bpc" id="L1426" title="1 of 2 branches missed.">    if ( number == null ) {</span>
<span class="nc" id="L1427">      return null;</span>
    }
<span class="fc bfc" id="L1429" title="All 2 branches covered.">    return Boolean.valueOf( number.signum() != 0 );</span>
  }

  /**
   * Converts a byte[] stored in a binary string storage type into a String;
   *
   * @param binary the binary string
   * @return the String in the correct encoding.
   * @throws HopValueException
   */
  protected String convertBinaryStringToString( byte[] binary ) throws HopValueException {
    //noinspection deprecation
<span class="fc" id="L1441">    return convertBinaryStringToString( binary, emptyStringAndNullAreDifferent );</span>
  }

  /*
   * Do not use this method directly! It is for tests!
   */
  @Deprecated
  String convertBinaryStringToString( byte[] binary, boolean emptyStringDiffersFromNull ) throws HopValueException {
    // OK, so we have an internal representation of the original object, read
    // from file.
    // Before we release it back, we have to see if we don't have to do a
    // String-&lt;type&gt;-String
    // conversion with different masks.
    // This obviously only applies to numeric data and dates.
    // We verify if this is true or false in advance for performance reasons
    //
    // if (binary==null || binary.length==0) return null;
<span class="pc bpc" id="L1458" title="1 of 4 branches missed.">    if ( binary == null || binary.length == 0 ) {</span>
<span class="pc bpc" id="L1459" title="3 of 4 branches missed.">      return ( emptyStringDiffersFromNull &amp;&amp; binary != null ) ? &quot;&quot; : null;</span>
    }

    String encoding;
<span class="fc bfc" id="L1463" title="All 2 branches covered.">    if ( identicalFormat ) {</span>
<span class="fc" id="L1464">      encoding = getStringEncoding();</span>
    } else {
<span class="fc" id="L1466">      encoding = storageMetadata.getStringEncoding();</span>
    }

<span class="fc bfc" id="L1469" title="All 2 branches covered.">    if ( Utils.isEmpty( encoding ) ) {</span>
<span class="fc" id="L1470">      return new String( binary );</span>
    } else {
      try {
<span class="fc" id="L1473">        return new String( binary, encoding );</span>
<span class="nc" id="L1474">      } catch ( UnsupportedEncodingException e ) {</span>
<span class="nc" id="L1475">        throw new HopValueException( toString()</span>
          + &quot; : couldn't convert binary value to String with specified string encoding [&quot; + stringEncoding + &quot;]&quot;, e );
      }
    }
  }

  /**
   * Converts the specified data object to the normal storage type.
   *
   * @param object the data object to convert
   * @return the data in a normal storage type
   * @throws HopValueException In case there is a data conversion error.
   */
  @Override
  public Object convertToNormalStorageType( Object object ) throws HopValueException {
<span class="nc bnc" id="L1490" title="All 2 branches missed.">    if ( object == null ) {</span>
<span class="nc" id="L1491">      return null;</span>
    }

<span class="nc bnc" id="L1494" title="All 4 branches missed.">    switch ( storageType ) {</span>
      case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1496">        return object;</span>
      case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1498">        return convertBinaryStringToNativeType( (byte[]) object );</span>
      case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1500">        return index[ (Integer) object ];</span>
      default:
<span class="nc" id="L1502">        throw new HopValueException( toStringMeta() + &quot; : Unknown storage type [&quot; + storageType</span>
          + &quot;] while converting to normal storage type&quot; );
    }
  }

  /**
   * Converts the specified data object to the binary string storage type.
   *
   * @param object the data object to convert
   * @return the data in a binary string storage type
   * @throws HopValueException In case there is a data conversion error.
   */
  @Override
  public Object convertToBinaryStringStorageType( Object object ) throws HopValueException {
<span class="pc bpc" id="L1516" title="1 of 2 branches missed.">    if ( object == null ) {</span>
<span class="nc" id="L1517">      return null;</span>
    }

<span class="pc bpc" id="L1520" title="3 of 4 branches missed.">    switch ( storageType ) {</span>
      case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1522">        return convertNormalStorageTypeToBinaryString( object );</span>
      case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1524">        return object;</span>
      case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1526">        return convertNormalStorageTypeToBinaryString( index[ (Integer) object ] );</span>
      default:
<span class="nc" id="L1528">        throw new HopValueException( toStringMeta() + &quot; : Unknown storage type [&quot; + storageType</span>
          + &quot;] while converting to normal storage type&quot; );
    }
  }

  /**
   * Convert the binary data to the actual data type.&lt;br&gt;
   * - byte[] --&gt; Long (Integer) - byte[] --&gt; Double (Number) - byte[] --&gt; BigDecimal (BigNumber) - byte[] --&gt; Date
   * (Date) - byte[] --&gt; Boolean (Boolean) - byte[] --&gt; byte[] (Binary)
   *
   * @param binary
   * @return
   * @throws HopValueException
   */
  @Override
  public Object convertBinaryStringToNativeType( byte[] binary ) throws HopValueException {
<span class="pc bpc" id="L1544" title="1 of 2 branches missed.">    if ( binary == null ) {</span>
<span class="nc" id="L1545">      return null;</span>
    }

<span class="fc" id="L1548">    numberOfBinaryStringConversions++;</span>

    // OK, so we have an internal representation of the original object, read
    // from file.
    // First we decode it in the correct encoding
    //
<span class="fc" id="L1554">    String string = convertBinaryStringToString( binary );</span>

    // In this method we always must convert the data.
    // We use the storageMetadata object to convert the binary string object.
    //
    // --&gt; Convert from the String format to the current data type...
    //
<span class="fc" id="L1561">    return convertData( storageMetadata, string );</span>
  }

  @Override
  public Object convertNormalStorageTypeToBinaryString( Object object ) throws HopValueException {
<span class="pc bpc" id="L1566" title="1 of 2 branches missed.">    if ( object == null ) {</span>
<span class="nc" id="L1567">      return null;</span>
    }

<span class="fc" id="L1570">    String string = getString( object );</span>

<span class="fc" id="L1572">    return convertStringToBinaryString( string );</span>
  }

  protected byte[] convertStringToBinaryString( String string ) throws HopValueException {
<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">    if ( string == null ) {</span>
<span class="nc" id="L1577">      return null;</span>
    }

<span class="fc bfc" id="L1580" title="All 2 branches covered.">    if ( Utils.isEmpty( stringEncoding ) ) {</span>
<span class="fc" id="L1581">      return string.getBytes();</span>
    } else {
      try {
<span class="fc" id="L1584">        return string.getBytes( stringEncoding );</span>
<span class="nc" id="L1585">      } catch ( UnsupportedEncodingException e ) {</span>
<span class="nc" id="L1586">        throw new HopValueException( toString()</span>
          + &quot; : couldn't convert String to Binary with specified string encoding [&quot; + stringEncoding + &quot;]&quot;, e );
      }
    }
  }

  /**
   * Clones the data. Normally, we don't have to do anything here, but just for arguments and safety, we do a little
   * extra work in case of binary blobs and Date objects. We should write a programmers manual later on to specify in
   * all clarity that &quot;we always overwrite/replace values in the Object[] data rows, we never modify them&quot; .
   *
   * @return a cloned data object if needed
   */
  @Override
  public Object cloneValueData( Object object ) throws HopValueException {
<span class="nc bnc" id="L1601" title="All 2 branches missed.">    if ( object == null ) {</span>
<span class="nc" id="L1602">      return null;</span>
    }

<span class="nc bnc" id="L1605" title="All 2 branches missed.">    if ( storageType == STORAGE_TYPE_NORMAL ) {</span>
<span class="nc bnc" id="L1606" title="All 5 branches missed.">      switch ( getType() ) {</span>
        case IValueMeta.TYPE_STRING:
        case IValueMeta.TYPE_NUMBER:
        case IValueMeta.TYPE_INTEGER:
        case IValueMeta.TYPE_BOOLEAN:
        case IValueMeta.TYPE_BIGNUMBER: // primitive data types: we can only
          // overwrite these, not change them
<span class="nc" id="L1613">          return object;</span>

        case IValueMeta.TYPE_DATE:
<span class="nc" id="L1616">          return new Date( ( (Date) object ).getTime() ); // just to make sure: very</span>
        // inexpensive too.

        case IValueMeta.TYPE_BINARY:
<span class="nc" id="L1620">          byte[] origin = (byte[]) object;</span>
<span class="nc" id="L1621">          byte[] target = new byte[ origin.length ];</span>
<span class="nc" id="L1622">          System.arraycopy( origin, 0, target, 0, origin.length );</span>
<span class="nc" id="L1623">          return target;</span>

        case IValueMeta.TYPE_SERIALIZABLE:
          // Let's not create a copy but simply return the same value.
          //
<span class="nc" id="L1628">          return object;</span>

        default:
<span class="nc" id="L1631">          throw new HopValueException( toString() + &quot;: unable to make copy of value type: &quot; + getType() );</span>
      }
    } else {

<span class="nc" id="L1635">      return object;</span>

    }
  }

  @Override
  public String getCompatibleString( Object object ) throws HopValueException {
    try {
      String string;

<span class="pc bpc" id="L1645" title="3 of 4 branches missed.">      switch ( type ) {</span>
        case TYPE_DATE:
<span class="nc bnc" id="L1647" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1649">              string = convertDateToCompatibleString( (Date) object );</span>
<span class="nc" id="L1650">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1652">              string = convertDateToCompatibleString( (Date) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L1653">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1655" title="All 2 branches missed.">              if ( object == null ) {</span>
<span class="nc" id="L1656">                string = null;</span>
              } else {
<span class="nc" id="L1658">                string = convertDateToCompatibleString( (Date) index[ ( (Integer) object ).intValue() ] );</span>
              }
<span class="nc" id="L1660">              break;</span>
            default:
<span class="nc" id="L1662">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_NUMBER:
<span class="nc bnc" id="L1667" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1669">              string = convertNumberToCompatibleString( (Double) object );</span>
<span class="nc" id="L1670">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1672">              string = convertNumberToCompatibleString( (Double) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L1673">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1675" title="All 2 branches missed.">              string =</span>
<span class="nc" id="L1676">                object == null ? null : convertNumberToCompatibleString( (Double) index[ ( (Integer) object )</span>
<span class="nc" id="L1677">                  .intValue() ] );</span>
<span class="nc" id="L1678">              break;</span>
            default:
<span class="nc" id="L1680">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_INTEGER:
<span class="pc bpc" id="L1685" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1687">              string = convertIntegerToCompatibleString( (Long) object );</span>
<span class="nc" id="L1688">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
              try {
<span class="nc" id="L1691">                string = convertIntegerToCompatibleString( (Long) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="fc" id="L1692">              } catch ( ClassCastException e ) {</span>
<span class="fc" id="L1693">                string = convertIntegerToCompatibleString( (Long) object );</span>
<span class="nc" id="L1694">              }</span>
<span class="fc" id="L1695">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1697" title="All 2 branches missed.">              string =</span>
<span class="nc" id="L1698">                object == null ? null : convertIntegerToCompatibleString( (Long) index[ ( (Integer) object )</span>
<span class="nc" id="L1699">                  .intValue() ] );</span>
<span class="nc" id="L1700">              break;</span>
            default:
<span class="nc" id="L1702">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        default:
<span class="nc" id="L1707">          return getString( object );</span>
      }

<span class="fc" id="L1710">      return string;</span>
<span class="nc" id="L1711">    } catch ( ClassCastException e ) {</span>
<span class="nc" id="L1712">      throw new HopValueException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L1713">        + object.getClass().getName() + &quot; object [&quot; + object + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L1714">        + toStringMeta() + &quot;]&quot; );</span>
    }
  }

  @Override
  public String getString( Object object ) throws HopValueException {
    try {
      String string;

<span class="pc bpc" id="L1723" title="3 of 9 branches missed.">      switch ( type ) {</span>
        case TYPE_STRING:
<span class="pc bpc" id="L1725" title="1 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc bfc" id="L1727" title="All 2 branches covered.">              string = object == null ? null : object.toString();</span>
<span class="fc" id="L1728">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1730">              string = (String) convertBinaryStringToNativeType( (byte[]) object );</span>
<span class="fc" id="L1731">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="fc bfc" id="L1733" title="All 2 branches covered.">              string = object == null ? null : (String) index[ ( (Integer) object ).intValue() ];</span>
<span class="fc" id="L1734">              break;</span>
            default:
<span class="nc" id="L1736">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
<span class="fc bfc" id="L1738" title="All 2 branches covered.">          if ( string != null ) {</span>
<span class="fc" id="L1739">            string = trim( string );</span>
          }
          break;

        case TYPE_DATE:
<span class="pc bpc" id="L1744" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1746">              string = convertDateToString( (Date) object );</span>
<span class="fc" id="L1747">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1749">              string = convertDateToString( (Date) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L1750">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="pc bpc" id="L1752" title="1 of 2 branches missed.">              string = object == null ? null : convertDateToString( (Date) index[ ( (Integer) object ).intValue() ] );</span>
<span class="fc" id="L1753">              break;</span>
            default:
<span class="nc" id="L1755">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_NUMBER:
<span class="pc bpc" id="L1760" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1762">              string = convertNumberToString( (Double) object );</span>
<span class="fc" id="L1763">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1765">              string = convertNumberToString( (Double) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="fc" id="L1766">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1768" title="All 2 branches missed.">              string = object == null ? null : convertNumberToString( (Double) index[ ( (Integer) object ).intValue() ] );</span>
<span class="nc" id="L1769">              break;</span>
            default:
<span class="nc" id="L1771">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_INTEGER:
<span class="pc bpc" id="L1776" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1778">              string = convertIntegerToString( (Long) object );</span>
<span class="fc" id="L1779">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1781">              string = convertIntegerToString( (Long) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="fc" id="L1782">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1784" title="All 2 branches missed.">              string = object == null ? null : convertIntegerToString( (Long) index[ ( (Integer) object ).intValue() ] );</span>
<span class="nc" id="L1785">              break;</span>
            default:
<span class="nc" id="L1787">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_BIGNUMBER:
<span class="pc bpc" id="L1792" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1794">              string = convertBigNumberToString( (BigDecimal) object );</span>
<span class="fc" id="L1795">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1797">              string = convertBigNumberToString( (BigDecimal) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="fc" id="L1798">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1800" title="All 2 branches missed.">              string =</span>
                object == null ? null
<span class="nc" id="L1802">                  : convertBigNumberToString( (BigDecimal) index[ ( (Integer) object ).intValue() ] );</span>
<span class="nc" id="L1803">              break;</span>
            default:
<span class="nc" id="L1805">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_BOOLEAN:
<span class="pc bpc" id="L1810" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1812">              string = convertBooleanToString( (Boolean) object );</span>
<span class="fc" id="L1813">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1815">              string = convertBooleanToString( (Boolean) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="fc" id="L1816">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1818" title="All 2 branches missed.">              string =</span>
<span class="nc" id="L1819">                object == null ? null : convertBooleanToString( (Boolean) index[ ( (Integer) object ).intValue() ] );</span>
<span class="nc" id="L1820">              break;</span>
            default:
<span class="nc" id="L1822">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_BINARY:
<span class="nc bnc" id="L1827" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1829">              string = convertBinaryStringToString( (byte[]) object );</span>
<span class="nc" id="L1830">              break;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1832">              string = convertBinaryStringToString( (byte[]) object );</span>
<span class="nc" id="L1833">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1835" title="All 2 branches missed.">              string =</span>
<span class="nc" id="L1836">                object == null ? null : convertBinaryStringToString( (byte[]) index[ ( (Integer) object ).intValue() ] );</span>
<span class="nc" id="L1837">              break;</span>
            default:
<span class="nc" id="L1839">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        case TYPE_SERIALIZABLE:
<span class="nc bnc" id="L1844" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc bnc" id="L1846" title="All 2 branches missed.">              string = object == null ? null : object.toString();</span>
<span class="nc" id="L1847">              break; // just go for the default toString()</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1849">              string = convertBinaryStringToString( (byte[]) object );</span>
<span class="nc" id="L1850">              break;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L1852" title="All 2 branches missed.">              string = object == null ? null : index[ ( (Integer) object ).intValue() ].toString();</span>
<span class="nc" id="L1853">              break; // just go for the default toString()</span>
            default:
<span class="nc" id="L1855">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
          break;

        default:
<span class="nc" id="L1860">          throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
      }

<span class="pc bpc" id="L1863" title="3 of 4 branches missed.">      if ( isOutputPaddingEnabled() &amp;&amp; getLength() &gt; 0 ) {</span>
<span class="nc" id="L1864">        string = ValueDataUtil.rightPad( string, getLength() );</span>
      }

<span class="fc" id="L1867">      return string;</span>
<span class="nc" id="L1868">    } catch ( ClassCastException e ) {</span>
<span class="nc" id="L1869">      throw new HopValueException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L1870">        + object.getClass().getName() + &quot; object [&quot; + object + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L1871">        + toStringMeta() + &quot;]&quot; );</span>
    }
  }

  protected String trim( String string ) {
<span class="pc bpc" id="L1876" title="1 of 5 branches missed.">    switch ( getTrimType() ) {</span>
      case TRIM_TYPE_NONE:
<span class="fc" id="L1878">        break;</span>
      case TRIM_TYPE_RIGHT:
<span class="fc" id="L1880">        string = Const.rtrim( string );</span>
<span class="fc" id="L1881">        break;</span>
      case TRIM_TYPE_LEFT:
<span class="fc" id="L1883">        string = Const.ltrim( string );</span>
<span class="fc" id="L1884">        break;</span>
      case TRIM_TYPE_BOTH:
<span class="fc" id="L1886">        string = Const.trim( string );</span>
<span class="fc" id="L1887">        break;</span>
      default:
        break;
    }
<span class="fc" id="L1891">    return string;</span>
  }

  @Override
  public Double getNumber( Object object ) throws HopValueException {
    try {
<span class="fc bfc" id="L1897" title="All 2 branches covered.">      if ( isNull( object ) ) {</span>
<span class="fc" id="L1898">        return null;</span>
      }
<span class="pc bpc" id="L1900" title="5 of 9 branches missed.">      switch ( type ) {</span>
        case TYPE_NUMBER:
<span class="pc bpc" id="L1902" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1904">              return (Double) object;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1906">              return (Double) convertBinaryStringToNativeType( (byte[]) object );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1908">              return (Double) index[ ( (Integer) object ).intValue() ];</span>
            default:
<span class="nc" id="L1910">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_STRING:
<span class="pc bpc" id="L1913" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1915">              return convertStringToNumber( (String) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1917">              return convertStringToNumber( (String) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1919">              return convertStringToNumber( (String) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L1921">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_DATE:
<span class="nc bnc" id="L1924" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1926">              return convertDateToNumber( (Date) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1928">              return convertDateToNumber( (Date) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1930">              return new Double( ( (Date) index[ ( (Integer) object ).intValue() ] ).getTime() );</span>
            default:
<span class="nc" id="L1932">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_INTEGER:
<span class="pc bpc" id="L1935" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1937">              return new Double( ( (Long) object ).doubleValue() );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1939">              return new Double( ( (Long) convertBinaryStringToNativeType( (byte[]) object ) ).doubleValue() );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1941">              return new Double( ( (Long) index[ ( (Integer) object ).intValue() ] ).doubleValue() );</span>
            default:
<span class="nc" id="L1943">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BIGNUMBER:
<span class="pc bpc" id="L1946" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1948">              return new Double( ( (BigDecimal) object ).doubleValue() );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1950">              return new Double( ( (BigDecimal) convertBinaryStringToNativeType( (byte[]) object ) ).doubleValue() );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1952">              return new Double( ( (BigDecimal) index[ ( (Integer) object ).intValue() ] ).doubleValue() );</span>
            default:
<span class="nc" id="L1954">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BOOLEAN:
<span class="nc bnc" id="L1957" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L1959">              return convertBooleanToNumber( (Boolean) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L1961">              return convertBooleanToNumber( (Boolean) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1963">              return convertBooleanToNumber( (Boolean) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L1965">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BINARY:
<span class="nc" id="L1968">          throw new HopValueException( toString() + &quot; : I don't know how to convert binary values to numbers.&quot; );</span>
        case TYPE_SERIALIZABLE:
<span class="nc" id="L1970">          throw new HopValueException( toString() + &quot; : I don't know how to convert serializable values to numbers.&quot; );</span>
        default:
<span class="nc" id="L1972">          throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
      }
<span class="fc" id="L1974">    } catch ( Exception e ) {</span>
<span class="fc" id="L1975">      throw new HopValueException( &quot;Unexpected conversion error while converting value [&quot; + toString()</span>
        + &quot;] to a Number&quot;, e );
    }
  }

  @Override
  public Long getInteger( Object object ) throws HopValueException {
    try {
<span class="fc bfc" id="L1983" title="All 2 branches covered.">      if ( isNull( object ) ) {</span>
<span class="fc" id="L1984">        return null;</span>
      }
<span class="pc bpc" id="L1986" title="4 of 9 branches missed.">      switch ( type ) {</span>
        case TYPE_INTEGER:
<span class="pc bpc" id="L1988" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L1990">              return (Long) object;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L1992">              return (Long) convertBinaryStringToNativeType( (byte[]) object );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L1994">              return (Long) index[ ( (Integer) object ).intValue() ];</span>
            default:
<span class="nc" id="L1996">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_STRING:
<span class="pc bpc" id="L1999" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2001">              return convertStringToInteger( (String) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2003">              return convertStringToInteger( (String) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2005">              return convertStringToInteger( (String) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2007">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_NUMBER:
<span class="pc bpc" id="L2010" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2012">              return new Long( Math.round( ( (Double) object ).doubleValue() ) );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2014">              return new Long( Math.round( ( (Double) convertBinaryStringToNativeType( (byte[]) object ) )</span>
<span class="fc" id="L2015">                .doubleValue() ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2017">              return new Long( Math.round( ( (Double) index[ ( (Integer) object ).intValue() ] ).doubleValue() ) );</span>
            default:
<span class="nc" id="L2019">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_DATE:
<span class="pc bpc" id="L2022" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2024">              return convertDateToInteger( (Date) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2026">              return new Long( ( (Date) convertBinaryStringToNativeType( (byte[]) object ) ).getTime() );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2028">              return convertDateToInteger( (Date) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2030">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BIGNUMBER:
<span class="pc bpc" id="L2033" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2035">              return new Long( ( (BigDecimal) object ).longValue() );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2037">              return new Long( ( (BigDecimal) convertBinaryStringToNativeType( (byte[]) object ) ).longValue() );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2039">              return new Long( ( (BigDecimal) index[ ( (Integer) object ).intValue() ] ).longValue() );</span>
            default:
<span class="nc" id="L2041">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BOOLEAN:
<span class="nc bnc" id="L2044" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2046">              return convertBooleanToInteger( (Boolean) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2048">              return convertBooleanToInteger( (Boolean) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2050">              return convertBooleanToInteger( (Boolean) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2052">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BINARY:
<span class="nc" id="L2055">          throw new HopValueException( toString() + &quot; : I don't know how to convert binary values to integers.&quot; );</span>
        case TYPE_SERIALIZABLE:
<span class="nc" id="L2057">          throw new HopValueException( toString()</span>
            + &quot; : I don't know how to convert serializable values to integers.&quot; );
        default:
<span class="nc" id="L2060">          throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
      }
<span class="fc" id="L2062">    } catch ( Exception e ) {</span>
<span class="fc" id="L2063">      throw new HopValueException( &quot;Unexpected conversion error while converting value [&quot; + toString()</span>
        + &quot;] to an Integer&quot;, e );
    }
  }

  @Override
  public BigDecimal getBigNumber( Object object ) throws HopValueException {
    try {
<span class="fc bfc" id="L2071" title="All 2 branches covered.">      if ( isNull( object ) ) {</span>
<span class="fc" id="L2072">        return null;</span>
      }
<span class="pc bpc" id="L2074" title="5 of 9 branches missed.">      switch ( type ) {</span>
        case TYPE_BIGNUMBER:
<span class="pc bpc" id="L2076" title="2 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2078">              return (BigDecimal) object;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2080">              return (BigDecimal) convertBinaryStringToNativeType( (byte[]) object );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2082">              return (BigDecimal) index[ ( (Integer) object ).intValue() ];</span>
            default:
<span class="nc" id="L2084">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_STRING:
<span class="pc bpc" id="L2087" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2089">              return convertStringToBigNumber( (String) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2091">              return convertStringToBigNumber( (String) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2093">              return convertStringToBigNumber( (String) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2095">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_INTEGER:
<span class="pc bpc" id="L2098" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2100">              return BigDecimal.valueOf( ( (Long) object ).longValue() );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2102">              return BigDecimal.valueOf( ( (Long) convertBinaryStringToNativeType( (byte[]) object ) ).longValue() );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2104">              return BigDecimal.valueOf( ( (Long) index[ ( (Integer) object ).intValue() ] ).longValue() );</span>
            default:
<span class="nc" id="L2106">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_NUMBER:
<span class="pc bpc" id="L2109" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2111">              return BigDecimal.valueOf( ( (Double) object ).doubleValue() );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2113">              return BigDecimal.valueOf( ( (Double) convertBinaryStringToNativeType( (byte[]) object ) ).doubleValue() );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2115">              return BigDecimal.valueOf( ( (Double) index[ ( (Integer) object ).intValue() ] ).doubleValue() );</span>
            default:
<span class="nc" id="L2117">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_DATE:
<span class="nc bnc" id="L2120" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2122">              return convertDateToBigNumber( (Date) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2124">              return convertDateToBigNumber( (Date) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2126">              return convertDateToBigNumber( (Date) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2128">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BOOLEAN:
<span class="nc bnc" id="L2131" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2133">              return convertBooleanToBigNumber( (Boolean) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2135">              return convertBooleanToBigNumber( (Boolean) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2137">              return convertBooleanToBigNumber( (Boolean) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2139">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }
        case TYPE_BINARY:
<span class="nc" id="L2142">          throw new HopValueException( toString() + &quot; : I don't know how to convert binary values to BigDecimals.&quot; );</span>
        case TYPE_SERIALIZABLE:
<span class="nc" id="L2144">          throw new HopValueException( toString() + &quot; : I don't know how to convert serializable values to BigDecimals.&quot; );</span>
        default:
<span class="nc" id="L2146">          throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
      }
<span class="fc" id="L2148">    } catch ( Exception e ) {</span>
<span class="fc" id="L2149">      throw new HopValueException( &quot;Unexpected conversion error while converting value [&quot; + toString()</span>
        + &quot;] to a BigNumber&quot;, e );
    }
  }

  @Override
  public Boolean getBoolean( Object object ) throws HopValueException {
<span class="fc bfc" id="L2156" title="All 2 branches covered.">    if ( object == null ) {</span>
<span class="fc" id="L2157">      return null;</span>
    }
<span class="pc bpc" id="L2159" title="6 of 9 branches missed.">    switch ( type ) {</span>
      case TYPE_BOOLEAN:
<span class="pc bpc" id="L2161" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2163">            return (Boolean) object;</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2165">            return (Boolean) convertBinaryStringToNativeType( (byte[]) object );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2167">            return (Boolean) index[ ( (Integer) object ).intValue() ];</span>
          default:
<span class="nc" id="L2169">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_STRING:
<span class="pc bpc" id="L2172" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2174">            return convertStringToBoolean( trim( (String) object ) );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2176">            return convertStringToBoolean( trim( (String) convertBinaryStringToNativeType( (byte[]) object ) ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2178">            return convertStringToBoolean( trim( (String) index[ ( (Integer) object ).intValue() ] ) );</span>
          default:
<span class="nc" id="L2180">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_INTEGER:
<span class="nc bnc" id="L2183" title="All 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2185">            return convertIntegerToBoolean( (Long) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2187">            return convertIntegerToBoolean( (Long) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2189">            return convertIntegerToBoolean( (Long) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2191">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_NUMBER:
<span class="pc bpc" id="L2194" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2196">            return convertNumberToBoolean( (Double) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2198">            return convertNumberToBoolean( (Double) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2200">            return convertNumberToBoolean( (Double) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2202">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_BIGNUMBER:
<span class="nc bnc" id="L2205" title="All 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2207">            return convertBigNumberToBoolean( (BigDecimal) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2209">            return convertBigNumberToBoolean( (BigDecimal) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2211">            return convertBigNumberToBoolean( (BigDecimal) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2213">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_DATE:
<span class="nc" id="L2216">        throw new HopValueException( toString() + &quot; : I don't know how to convert date values to booleans.&quot; );</span>
      case TYPE_BINARY:
<span class="nc" id="L2218">        throw new HopValueException( toString() + &quot; : I don't know how to convert binary values to booleans.&quot; );</span>
      case TYPE_SERIALIZABLE:
<span class="nc" id="L2220">        throw new HopValueException( toString() + &quot; : I don't know how to convert serializable values to booleans.&quot; );</span>
      default:
<span class="nc" id="L2222">        throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
    }
  }

  @Override
  public Date getDate( Object object ) throws HopValueException {
<span class="fc bfc" id="L2228" title="All 2 branches covered.">    if ( isNull( object ) ) {</span>
<span class="fc" id="L2229">      return null;</span>
    }
<span class="pc bpc" id="L2231" title="4 of 9 branches missed.">    switch ( type ) {</span>
      case TYPE_DATE:
<span class="pc bpc" id="L2233" title="2 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2235">            return (Date) object;</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2237">            return (Date) convertBinaryStringToNativeType( (byte[]) object );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2239">            return (Date) index[ ( (Integer) object ).intValue() ];</span>
          default:
<span class="nc" id="L2241">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_STRING:
<span class="pc bpc" id="L2244" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2246">            return convertStringToDate( (String) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2248">            return convertStringToDate( (String) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2250">            return convertStringToDate( (String) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2252">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_NUMBER:
<span class="pc bpc" id="L2255" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2257">            return convertNumberToDate( (Double) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2259">            return convertNumberToDate( (Double) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2261">            return convertNumberToDate( (Double) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2263">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_INTEGER:
<span class="pc bpc" id="L2266" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2268">            return convertIntegerToDate( (Long) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2270">            return convertIntegerToDate( (Long) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2272">            return convertIntegerToDate( (Long) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2274">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_BIGNUMBER:
<span class="pc bpc" id="L2277" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2279">            return convertBigNumberToDate( (BigDecimal) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2281">            return convertBigNumberToDate( (BigDecimal) convertBinaryStringToNativeType( (byte[]) object ) );</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2283">            return convertBigNumberToDate( (BigDecimal) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2285">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_BOOLEAN:
<span class="nc" id="L2288">        throw new HopValueException( toString() + &quot; : I don't know how to convert a boolean to a date.&quot; );</span>
      case TYPE_BINARY:
<span class="nc" id="L2290">        throw new HopValueException( toString() + &quot; : I don't know how to convert a binary value to date.&quot; );</span>
      case TYPE_SERIALIZABLE:
<span class="nc" id="L2292">        throw new HopValueException( toString() + &quot; : I don't know how to convert a serializable value to date.&quot; );</span>

      default:
<span class="nc" id="L2295">        throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
    }
  }

  @Override
  public byte[] getBinary( Object object ) throws HopValueException {
<span class="fc bfc" id="L2301" title="All 2 branches covered.">    if ( object == null ) {</span>
<span class="fc" id="L2302">      return null;</span>
    }
<span class="pc bpc" id="L2304" title="8 of 9 branches missed.">    switch ( type ) {</span>
      case TYPE_BINARY:
<span class="nc bnc" id="L2306" title="All 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2308">            return (byte[]) object;</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2310">            return (byte[]) object;</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2312">            return (byte[]) index[ ( (Integer) object ).intValue() ];</span>
          default:
<span class="nc" id="L2314">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_DATE:
<span class="nc" id="L2317">        throw new HopValueException( toString() + &quot; : I don't know how to convert a date to binary.&quot; );</span>
      case TYPE_STRING:
<span class="pc bpc" id="L2319" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2321">            return convertStringToBinaryString( (String) object );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2323">            return (byte[]) object;</span>
          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2325">            return convertStringToBinaryString( (String) index[ ( (Integer) object ).intValue() ] );</span>
          default:
<span class="nc" id="L2327">            throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
        }
      case TYPE_NUMBER:
<span class="nc" id="L2330">        throw new HopValueException( toString() + &quot; : I don't know how to convert a number to binary.&quot; );</span>
      case TYPE_INTEGER:
<span class="nc" id="L2332">        throw new HopValueException( toString() + &quot; : I don't know how to convert an integer to binary.&quot; );</span>
      case TYPE_BIGNUMBER:
<span class="nc" id="L2334">        throw new HopValueException( toString() + &quot; : I don't know how to convert a bignumber to binary.&quot; );</span>
      case TYPE_BOOLEAN:
<span class="nc" id="L2336">        throw new HopValueException( toString() + &quot; : I don't know how to convert a boolean to binary.&quot; );</span>
      case TYPE_SERIALIZABLE:
<span class="nc" id="L2338">        throw new HopValueException( toString() + &quot; : I don't know how to convert a serializable to binary.&quot; );</span>

      default:
<span class="nc" id="L2341">        throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
    }
  }

  @Override
  public byte[] getBinaryString( Object object ) throws HopValueException {
    // If the input is a binary string, we should return the exact same binary
    // object IF
    // and only IF the formatting options for the storage metadata and this
    // object are the same.
    //
<span class="pc bpc" id="L2352" title="1 of 4 branches missed.">    if ( isStorageBinaryString() &amp;&amp; identicalFormat ) {</span>
<span class="nc" id="L2353">      return (byte[]) object; // shortcut it directly for better performance.</span>
    }

    try {
<span class="pc bpc" id="L2357" title="1 of 2 branches missed.">      if ( object == null ) {</span>
<span class="nc" id="L2358">        return null;</span>
      }

<span class="pc bpc" id="L2361" title="7 of 9 branches missed.">      switch ( type ) {</span>
        case TYPE_STRING:
<span class="pc bpc" id="L2363" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="fc" id="L2365">              return convertStringToBinaryString( (String) object );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2367">              return convertStringToBinaryString( (String) convertBinaryStringToNativeType( (byte[]) object ) );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2369">              return convertStringToBinaryString( (String) index[ ( (Integer) object ).intValue() ] );</span>
            default:
<span class="nc" id="L2371">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_DATE:
<span class="nc bnc" id="L2375" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2377">              return convertStringToBinaryString( convertDateToString( (Date) object ) );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2379">              String string = convertDateToString( (Date) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L2380">              return convertStringToBinaryString( string );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2382">              return convertStringToBinaryString( convertDateToString( (Date) index[ ( (Integer) object ).intValue() ] ) );</span>
            default:
<span class="nc" id="L2384">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_NUMBER:
<span class="pc bpc" id="L2388" title="3 of 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2390">              return convertStringToBinaryString( convertNumberToString( (Double) object ) );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="fc" id="L2392">              String string = convertNumberToString( (Double) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="fc" id="L2393">              return convertStringToBinaryString( string );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2395">              return convertStringToBinaryString( convertNumberToString( (Double) index[ ( (Integer) object ).intValue() ] ) );</span>
            default:
<span class="nc" id="L2397">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_INTEGER:
<span class="nc bnc" id="L2401" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2403">              return convertStringToBinaryString( convertIntegerToString( (Long) object ) );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2405">              String string = convertIntegerToString( (Long) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L2406">              return convertStringToBinaryString( string );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2408">              return convertStringToBinaryString( convertIntegerToString( (Long) index[ ( (Integer) object ).intValue() ] ) );</span>
            default:
<span class="nc" id="L2410">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_BIGNUMBER:
<span class="nc bnc" id="L2414" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2416">              return convertStringToBinaryString( convertBigNumberToString( (BigDecimal) object ) );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2418">              String string =</span>
<span class="nc" id="L2419">                convertBigNumberToString( (BigDecimal) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L2420">              return convertStringToBinaryString( string );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2422">              return convertStringToBinaryString( convertBigNumberToString( (BigDecimal) index[ ( (Integer) object )</span>
<span class="nc" id="L2423">                .intValue() ] ) );</span>
            default:
<span class="nc" id="L2425">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_BOOLEAN:
<span class="nc bnc" id="L2429" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2431">              return convertStringToBinaryString( convertBooleanToString( (Boolean) object ) );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2433">              String string = convertBooleanToString( (Boolean) convertBinaryStringToNativeType( (byte[]) object ) );</span>
<span class="nc" id="L2434">              return convertStringToBinaryString( string );</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2436">              return convertStringToBinaryString( convertBooleanToString( (Boolean) index[ ( (Integer) object )</span>
<span class="nc" id="L2437">                .intValue() ] ) );</span>
            default:
<span class="nc" id="L2439">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_BINARY:
<span class="nc bnc" id="L2443" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2445">              return (byte[]) object;</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2447">              return (byte[]) object;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2449">              return (byte[]) index[ ( (Integer) object ).intValue() ];</span>
            default:
<span class="nc" id="L2451">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        case TYPE_SERIALIZABLE:
<span class="nc bnc" id="L2455" title="All 4 branches missed.">          switch ( storageType ) {</span>
            case STORAGE_TYPE_NORMAL:
<span class="nc" id="L2457">              return convertStringToBinaryString( object.toString() );</span>
            case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2459">              return (byte[]) object;</span>
            case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2461">              return convertStringToBinaryString( index[ ( (Integer) object ).intValue() ].toString() );</span>
            default:
<span class="nc" id="L2463">              throw new HopValueException( toString() + &quot; : Unknown storage type &quot; + storageType + &quot; specified.&quot; );</span>
          }

        default:
<span class="nc" id="L2467">          throw new HopValueException( toString() + &quot; : Unknown type &quot; + type + &quot; specified.&quot; );</span>
      }
<span class="nc" id="L2469">    } catch ( ClassCastException e ) {</span>
<span class="nc" id="L2470">      throw new HopValueException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L2471">        + object.getClass().getName() + &quot; object [&quot; + object + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L2472">        + toStringMeta() + &quot;]&quot; );</span>
    }
  }

  /**
   * Checks whether or not the value is a String.
   *
   * @return true if the value is a String.
   */
  @Override
  public boolean isString() {
<span class="fc bfc" id="L2483" title="All 2 branches covered.">    return type == TYPE_STRING;</span>
  }

  /**
   * Checks whether or not this value is a Date
   *
   * @return true if the value is a Date
   */
  @Override
  public boolean isDate() {
<span class="pc bpc" id="L2493" title="1 of 4 branches missed.">    return type == TYPE_DATE || type == TYPE_TIMESTAMP;</span>
  }

  /**
   * Checks whether or not the value is a Big Number
   *
   * @return true is this value is a big number
   */
  @Override
  public boolean isBigNumber() {
<span class="fc bfc" id="L2503" title="All 2 branches covered.">    return type == TYPE_BIGNUMBER;</span>
  }

  /**
   * Checks whether or not the value is a Number
   *
   * @return true is this value is a number
   */
  @Override
  public boolean isNumber() {
<span class="fc bfc" id="L2513" title="All 2 branches covered.">    return type == TYPE_NUMBER;</span>
  }

  /**
   * Checks whether or not this value is a boolean
   *
   * @return true if this value has type boolean.
   */
  @Override
  public boolean isBoolean() {
<span class="fc bfc" id="L2523" title="All 2 branches covered.">    return type == TYPE_BOOLEAN;</span>
  }

  /**
   * Checks whether or not this value is of type Serializable
   *
   * @return true if this value has type Serializable
   */
  @Override
  public boolean isSerializableType() {
<span class="nc bnc" id="L2533" title="All 2 branches missed.">    return type == TYPE_SERIALIZABLE;</span>
  }

  /**
   * Checks whether or not this value is of type Binary
   *
   * @return true if this value has type Binary
   */
  @Override
  public boolean isBinary() {
<span class="fc bfc" id="L2543" title="All 2 branches covered.">    return type == TYPE_BINARY;</span>
  }

  /**
   * Checks whether or not this value is an Integer
   *
   * @return true if this value is an integer
   */
  @Override
  public boolean isInteger() {
<span class="fc bfc" id="L2553" title="All 2 branches covered.">    return type == TYPE_INTEGER;</span>
  }

  /**
   * Checks whether or not this Value is Numeric A Value is numeric if it is either of type Number or Integer
   *
   * @return true if the value is either of type Number or Integer
   */
  @Override
  public boolean isNumeric() {
<span class="fc bfc" id="L2563" title="All 6 branches covered.">    return isInteger() || isNumber() || isBigNumber();</span>
  }

  /**
   * Checks whether or not the specified type is either Integer or Number
   *
   * @param t the type to check
   * @return true if the type is Integer or Number
   */
  public static final boolean isNumeric( int t ) {
<span class="fc bfc" id="L2573" title="All 6 branches covered.">    return t == TYPE_INTEGER || t == TYPE_NUMBER || t == TYPE_BIGNUMBER;</span>
  }

  public boolean isSortedAscending() {
<span class="fc bfc" id="L2577" title="All 2 branches covered.">    return !isSortedDescending();</span>
  }

  /**
   * Return the type of a value in a textual form: &quot;String&quot;, &quot;Number&quot;, &quot;Integer&quot;, &quot;Boolean&quot;, &quot;Date&quot;, ...
   *
   * @return A String describing the type of value.
   */
  @Override
  public String getTypeDesc() {
<span class="fc" id="L2587">    return getTypeDesc( type );</span>
  }

  /**
   * Return the storage type of a value in a textual form: &quot;normal&quot;, &quot;binary-string&quot;, &quot;indexes&quot;
   *
   * @return A String describing the storage type of the value metadata
   */
  public String getStorageTypeDesc() {
<span class="nc" id="L2596">    return storageTypeCodes[ storageType ];</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L2601">    return name + &quot; &quot; + toStringMeta();</span>
  }

  /**
   * a String text representation of this Value, optionally padded to the specified length
   *
   * @return a String text representation of this Value, optionally padded to the specified length
   */
  @Override
  public String toStringMeta() {
    // We (Sven Boden) did explicit performance testing for this
    // part. The original version used Strings instead of StringBuilders,
    // performance between the 2 does not differ that much. A few milliseconds
    // on 100000 iterations in the advantage of StringBuilders. The
    // lessened creation of objects may be worth it in the long run.
<span class="fc" id="L2616">    StringBuilder retval = new StringBuilder( getTypeDesc() );</span>

<span class="fc bfc" id="L2618" title="All 4 branches covered.">    switch ( getType() ) {</span>
      case TYPE_STRING:
<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">        if ( getLength() &gt; 0 ) {</span>
<span class="nc" id="L2621">          retval.append( '(' ).append( getLength() ).append( ')' );</span>
        }
        break;
      case TYPE_NUMBER:
      case TYPE_BIGNUMBER:
<span class="pc bpc" id="L2626" title="1 of 2 branches missed.">        if ( getLength() &gt; 0 ) {</span>
<span class="nc" id="L2627">          retval.append( '(' ).append( getLength() );</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">          if ( getPrecision() &gt; 0 ) {</span>
<span class="nc" id="L2629">            retval.append( &quot;, &quot; ).append( getPrecision() );</span>
          }
<span class="nc" id="L2631">          retval.append( ')' );</span>
        }
        break;
      case TYPE_INTEGER:
<span class="pc bpc" id="L2635" title="1 of 2 branches missed.">        if ( getLength() &gt; 0 ) {</span>
<span class="nc" id="L2636">          retval.append( '(' ).append( getLength() ).append( ')' );</span>
        }
        break;
      default:
        break;
    }

<span class="pc bpc" id="L2643" title="1 of 2 branches missed.">    if ( !isStorageNormal() ) {</span>
<span class="nc" id="L2644">      retval.append( &quot;&lt;&quot; ).append( getStorageTypeDesc() ).append( &quot;&gt;&quot; );</span>
    }

<span class="fc" id="L2647">    return retval.toString();</span>
  }

  @Override
  public void writeData( DataOutputStream outputStream, Object object ) throws HopFileException {
    try {
      // Is the value NULL?
<span class="pc bpc" id="L2654" title="1 of 2 branches missed.">      outputStream.writeBoolean( object == null );</span>

<span class="pc bpc" id="L2656" title="1 of 2 branches missed.">      if ( object != null ) {</span>
        // otherwise there is no point
<span class="pc bpc" id="L2658" title="3 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
            // Handle Content -- only when not NULL
<span class="pc bpc" id="L2661" title="7 of 9 branches missed.">            switch ( getType() ) {</span>
              case TYPE_STRING:
<span class="fc" id="L2663">                writeString( outputStream, (String) object );</span>
<span class="fc" id="L2664">                break;</span>
              case TYPE_NUMBER:
<span class="nc" id="L2666">                writeNumber( outputStream, (Double) object );</span>
<span class="nc" id="L2667">                break;</span>
              case TYPE_INTEGER:
<span class="nc" id="L2669">                writeInteger( outputStream, (Long) object );</span>
<span class="nc" id="L2670">                break;</span>
              case TYPE_DATE:
<span class="nc" id="L2672">                writeDate( outputStream, (Date) object );</span>
<span class="nc" id="L2673">                break;</span>
              case TYPE_BIGNUMBER:
<span class="nc" id="L2675">                writeBigNumber( outputStream, (BigDecimal) object );</span>
<span class="nc" id="L2676">                break;</span>
              case TYPE_BOOLEAN:
<span class="nc" id="L2678">                writeBoolean( outputStream, (Boolean) object );</span>
<span class="nc" id="L2679">                break;</span>
              case TYPE_BINARY:
<span class="nc" id="L2681">                writeBinary( outputStream, (byte[]) object );</span>
<span class="nc" id="L2682">                break;</span>
              case TYPE_INET:
<span class="fc" id="L2684">                writeBinary( outputStream, ( (InetAddress) object ).getAddress() );</span>
<span class="fc" id="L2685">                break;</span>
              default:
<span class="nc" id="L2687">                throw new HopFileException( toString() + &quot; : Unable to serialize data type &quot; + getType() );</span>
            }
            break;

          case STORAGE_TYPE_BINARY_STRING:
            // Handle binary string content -- only when not NULL
            // In this case, we opt not to convert anything at all for speed.
            // That way, we can save on CPU power.
            // Since the streams can be compressed, volume shouldn't be an issue
            // at all.
            //
<span class="nc" id="L2698">            writeBinaryString( outputStream, (byte[]) object );</span>
<span class="nc" id="L2699">            break;</span>

          case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2702">            writeInteger( outputStream, (Integer) object ); // just an index</span>
<span class="nc" id="L2703">            break;</span>

          default:
<span class="nc" id="L2706">            throw new HopFileException( toString() + &quot; : Unknown storage type &quot; + getStorageType() );</span>
        }
      }
<span class="nc" id="L2709">    } catch ( ClassCastException e ) {</span>
<span class="nc" id="L2710">      throw new RuntimeException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L2711">        + object.getClass().getName() + &quot; object [&quot; + object + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L2712">        + toStringMeta() + &quot;]&quot; );</span>
<span class="nc" id="L2713">    } catch ( IOException e ) {</span>
<span class="nc" id="L2714">      throw new HopFileException( toString() + &quot; : Unable to write value data to output stream&quot;, e );</span>
<span class="fc" id="L2715">    }</span>

<span class="fc" id="L2717">  }</span>

  @Override
  public Object readData( DataInputStream inputStream ) throws HopFileException, HopEofException,
    SocketTimeoutException {
    try {
      // Is the value NULL?
<span class="pc bpc" id="L2724" title="1 of 2 branches missed.">      if ( inputStream.readBoolean() ) {</span>
<span class="nc" id="L2725">        return null; // done</span>
      }

<span class="pc bpc" id="L2728" title="3 of 4 branches missed.">      switch ( storageType ) {</span>
        case STORAGE_TYPE_NORMAL:
          // Handle Content -- only when not NULL
<span class="pc bpc" id="L2731" title="7 of 9 branches missed.">          switch ( getType() ) {</span>
            case TYPE_STRING:
<span class="fc" id="L2733">              return readString( inputStream );</span>
            case TYPE_NUMBER:
<span class="nc" id="L2735">              return readNumber( inputStream );</span>
            case TYPE_INTEGER:
<span class="nc" id="L2737">              return readInteger( inputStream );</span>
            case TYPE_DATE:
<span class="nc" id="L2739">              return readDate( inputStream );</span>
            case TYPE_BIGNUMBER:
<span class="nc" id="L2741">              return readBigNumber( inputStream );</span>
            case TYPE_BOOLEAN:
<span class="nc" id="L2743">              return readBoolean( inputStream );</span>
            case TYPE_BINARY:
<span class="nc" id="L2745">              return readBinary( inputStream );</span>
            case TYPE_INET:
<span class="fc" id="L2747">              return InetAddress.getByAddress( readBinary( inputStream ) );</span>
            default:
<span class="nc" id="L2749">              throw new HopFileException( toString() + &quot; : Unable to de-serialize data of type &quot; + getType() );</span>
          }

        case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L2753">          return readBinaryString( inputStream );</span>

        case STORAGE_TYPE_INDEXED:
<span class="nc" id="L2756">          return readSmallInteger( inputStream ); // just an index: 4-bytes should</span>
        // be enough.

        default:
<span class="nc" id="L2760">          throw new HopFileException( toString() + &quot; : Unknown storage type &quot; + getStorageType() );</span>
      }
<span class="nc" id="L2762">    } catch ( EOFException e ) {</span>
<span class="nc" id="L2763">      throw new HopEofException( e );</span>
<span class="nc" id="L2764">    } catch ( SocketTimeoutException e ) {</span>
<span class="nc" id="L2765">      throw e;</span>
<span class="nc" id="L2766">    } catch ( IOException e ) {</span>
<span class="nc" id="L2767">      throw new HopFileException( toString() + &quot; : Unable to read value data from input stream&quot;, e );</span>
    }
  }

  protected void writeString( DataOutputStream outputStream, String string ) throws IOException {
    // Write the length and then the bytes
<span class="fc bfc" id="L2773" title="All 2 branches covered.">    if ( string == null ) {</span>
<span class="fc" id="L2774">      outputStream.writeInt( -1 );</span>
    } else {
<span class="fc" id="L2776">      byte[] chars = string.getBytes( Const.XML_ENCODING );</span>
<span class="fc" id="L2777">      outputStream.writeInt( chars.length );</span>
<span class="fc" id="L2778">      outputStream.write( chars );</span>
    }
<span class="fc" id="L2780">  }</span>

  protected void writeBinaryString( DataOutputStream outputStream, byte[] binaryString ) throws IOException {
    // Write the length and then the bytes
<span class="nc bnc" id="L2784" title="All 2 branches missed.">    if ( binaryString == null ) {</span>
<span class="nc" id="L2785">      outputStream.writeInt( -1 );</span>
    } else {
<span class="nc" id="L2787">      outputStream.writeInt( binaryString.length );</span>
<span class="nc" id="L2788">      outputStream.write( binaryString );</span>
    }
<span class="nc" id="L2790">  }</span>

  protected String readString( DataInputStream inputStream ) throws IOException {
    // Read the length and then the bytes
<span class="fc" id="L2794">    int length = inputStream.readInt();</span>
<span class="fc bfc" id="L2795" title="All 2 branches covered.">    if ( length &lt; 0 ) {</span>
<span class="fc" id="L2796">      return null;</span>
    }

<span class="fc" id="L2799">    byte[] chars = new byte[ length ];</span>
<span class="fc" id="L2800">    inputStream.readFully( chars );</span>

<span class="fc" id="L2802">    String string = new String( chars, Const.XML_ENCODING );</span>
<span class="fc" id="L2803">    return string;</span>
  }

  protected byte[] readBinaryString( DataInputStream inputStream ) throws IOException {
    // Read the length and then the bytes
<span class="nc" id="L2808">    int length = inputStream.readInt();</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">    if ( length &lt; 0 ) {</span>
<span class="nc" id="L2810">      return null;</span>
    }

<span class="nc" id="L2813">    byte[] chars = new byte[ length ];</span>
<span class="nc" id="L2814">    inputStream.readFully( chars );</span>

<span class="nc" id="L2816">    return chars;</span>
  }

  protected void writeBigNumber( DataOutputStream outputStream, BigDecimal number ) throws IOException {
<span class="nc" id="L2820">    String string = number.toString();</span>
<span class="nc" id="L2821">    writeString( outputStream, string );</span>
<span class="nc" id="L2822">  }</span>

  protected BigDecimal readBigNumber( DataInputStream inputStream ) throws IOException {
<span class="nc" id="L2825">    String string = readString( inputStream );</span>
<span class="nc" id="L2826">    return new BigDecimal( string );</span>
  }

  protected void writeDate( DataOutputStream outputStream, Date date ) throws IOException {
<span class="nc" id="L2830">    outputStream.writeLong( date.getTime() );</span>
<span class="nc" id="L2831">  }</span>

  protected Date readDate( DataInputStream inputStream ) throws IOException {
<span class="nc" id="L2834">    long time = inputStream.readLong();</span>
<span class="nc" id="L2835">    return new Date( time );</span>
  }

  protected void writeBoolean( DataOutputStream outputStream, Boolean bool ) throws IOException {
<span class="nc" id="L2839">    outputStream.writeBoolean( bool.booleanValue() );</span>
<span class="nc" id="L2840">  }</span>

  protected Boolean readBoolean( DataInputStream inputStream ) throws IOException {
<span class="nc" id="L2843">    Boolean bool = Boolean.valueOf( inputStream.readBoolean() );</span>
<span class="nc" id="L2844">    return bool;</span>
  }

  protected void writeNumber( DataOutputStream outputStream, Double number ) throws IOException {
<span class="nc" id="L2848">    outputStream.writeDouble( number.doubleValue() );</span>
<span class="nc" id="L2849">  }</span>

  protected Double readNumber( DataInputStream inputStream ) throws IOException {
<span class="nc" id="L2852">    Double d = new Double( inputStream.readDouble() );</span>
<span class="nc" id="L2853">    return d;</span>
  }

  protected void writeInteger( DataOutputStream outputStream, Long number ) throws IOException {
<span class="nc" id="L2857">    outputStream.writeLong( number.longValue() );</span>
<span class="nc" id="L2858">  }</span>

  protected Long readInteger( DataInputStream inputStream ) throws IOException {
<span class="nc" id="L2861">    Long l = new Long( inputStream.readLong() );</span>
<span class="nc" id="L2862">    return l;</span>
  }

  protected void writeInteger( DataOutputStream outputStream, Integer number ) throws IOException {
<span class="nc" id="L2866">    outputStream.writeInt( number.intValue() );</span>
<span class="nc" id="L2867">  }</span>

  protected Integer readSmallInteger( DataInputStream inputStream ) throws IOException {
<span class="nc" id="L2870">    Integer i = Integer.valueOf( inputStream.readInt() );</span>
<span class="nc" id="L2871">    return i;</span>
  }

  protected void writeBinary( DataOutputStream outputStream, byte[] binary ) throws IOException {
<span class="fc" id="L2875">    outputStream.writeInt( binary.length );</span>
<span class="fc" id="L2876">    outputStream.write( binary );</span>
<span class="fc" id="L2877">  }</span>

  protected byte[] readBinary( DataInputStream inputStream ) throws IOException {
<span class="fc" id="L2880">    int size = inputStream.readInt();</span>
<span class="fc" id="L2881">    byte[] buffer = new byte[ size ];</span>
<span class="fc" id="L2882">    inputStream.readFully( buffer );</span>

<span class="fc" id="L2884">    return buffer;</span>
  }

  @Override
  public void writeMeta( DataOutputStream outputStream ) throws HopFileException {
    try {
<span class="fc" id="L2890">      int type = getType();</span>

      // Handle type
<span class="fc" id="L2893">      outputStream.writeInt( type );</span>

      // Handle storage type
<span class="fc" id="L2896">      outputStream.writeInt( storageType );</span>

<span class="fc bfc" id="L2898" title="All 3 branches covered.">      switch ( storageType ) {</span>
        case STORAGE_TYPE_INDEXED:
          // Save the indexed strings...
<span class="pc bpc" id="L2901" title="1 of 2 branches missed.">          if ( index == null ) {</span>
<span class="nc" id="L2902">            outputStream.writeInt( -1 ); // null</span>
          } else {
<span class="fc" id="L2904">            outputStream.writeInt( index.length );</span>
<span class="fc bfc" id="L2905" title="All 2 branches covered.">            for ( int i = 0; i &lt; index.length; i++ ) {</span>
              try {
<span class="pc bpc" id="L2907" title="7 of 8 branches missed.">                switch ( type ) {</span>
                  case TYPE_STRING:
<span class="fc" id="L2909">                    writeString( outputStream, (String) index[ i ] );</span>
<span class="fc" id="L2910">                    break;</span>
                  case TYPE_NUMBER:
<span class="nc" id="L2912">                    writeNumber( outputStream, (Double) index[ i ] );</span>
<span class="nc" id="L2913">                    break;</span>
                  case TYPE_INTEGER:
<span class="nc" id="L2915">                    writeInteger( outputStream, (Long) index[ i ] );</span>
<span class="nc" id="L2916">                    break;</span>
                  case TYPE_DATE:
<span class="nc" id="L2918">                    writeDate( outputStream, (Date) index[ i ] );</span>
<span class="nc" id="L2919">                    break;</span>
                  case TYPE_BIGNUMBER:
<span class="nc" id="L2921">                    writeBigNumber( outputStream, (BigDecimal) index[ i ] );</span>
<span class="nc" id="L2922">                    break;</span>
                  case TYPE_BOOLEAN:
<span class="nc" id="L2924">                    writeBoolean( outputStream, (Boolean) index[ i ] );</span>
<span class="nc" id="L2925">                    break;</span>
                  case TYPE_BINARY:
<span class="nc" id="L2927">                    writeBinary( outputStream, (byte[]) index[ i ] );</span>
<span class="nc" id="L2928">                    break;</span>
                  default:
<span class="nc" id="L2930">                    throw new HopFileException( toString()</span>
<span class="nc" id="L2931">                      + &quot; : Unable to serialize indexe storage type for data type &quot; + getType() );</span>
                }
<span class="nc" id="L2933">              } catch ( ClassCastException e ) {</span>
<span class="nc" id="L2934">                throw new RuntimeException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L2935">                  + index[ i ].getClass().getName() + &quot; object [&quot; + index[ i ] + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L2936">                  + toStringMeta() + &quot;]&quot; );</span>
<span class="fc" id="L2937">              }</span>
            }
          }
<span class="fc" id="L2940">          break;</span>

        case STORAGE_TYPE_BINARY_STRING:
          // Save the storage meta data...
          //
<span class="pc bpc" id="L2945" title="1 of 2 branches missed.">          outputStream.writeBoolean( storageMetadata != null );</span>

<span class="pc bpc" id="L2947" title="1 of 2 branches missed.">          if ( storageMetadata != null ) {</span>
<span class="fc" id="L2948">            storageMetadata.writeMeta( outputStream );</span>
          }
          break;

        default:
          break;
      }

      // Handle name-length
<span class="fc" id="L2957">      writeString( outputStream, name );</span>

      // length &amp; precision
<span class="fc" id="L2960">      outputStream.writeInt( getLength() );</span>
<span class="fc" id="L2961">      outputStream.writeInt( getPrecision() );</span>

      // Origin
<span class="fc" id="L2964">      writeString( outputStream, origin );</span>

      // Comments
<span class="fc" id="L2967">      writeString( outputStream, comments );</span>

      // formatting Mask, decimal, grouping, currency
<span class="fc" id="L2970">      writeString( outputStream, conversionMask );</span>
<span class="fc" id="L2971">      writeString( outputStream, decimalSymbol );</span>
<span class="fc" id="L2972">      writeString( outputStream, groupingSymbol );</span>
<span class="fc" id="L2973">      writeString( outputStream, currencySymbol );</span>
<span class="fc" id="L2974">      outputStream.writeInt( trimType );</span>

      // Case sensitivity of compare
<span class="fc" id="L2977">      outputStream.writeBoolean( caseInsensitive );</span>

      // Collator Locale
<span class="fc" id="L2980">      writeString( outputStream, collatorLocale.toLanguageTag() );</span>

      // Collator Disabled of compare
<span class="fc" id="L2983">      outputStream.writeBoolean( collatorDisabled );</span>

      // Collator strength of compare
<span class="fc" id="L2986">      outputStream.writeInt( collatorStrength );</span>

      // Sorting information
<span class="fc" id="L2989">      outputStream.writeBoolean( sortedDescending );</span>

      // Padding information
<span class="fc" id="L2992">      outputStream.writeBoolean( outputPaddingEnabled );</span>

      // date format lenient?
<span class="fc" id="L2995">      outputStream.writeBoolean( dateFormatLenient );</span>

      // date format locale?
<span class="pc bpc" id="L2998" title="1 of 2 branches missed.">      writeString( outputStream, dateFormatLocale != null ? dateFormatLocale.toString() : null );</span>

      // date time zone?
<span class="pc bpc" id="L3001" title="1 of 2 branches missed.">      writeString( outputStream, dateFormatTimeZone != null ? dateFormatTimeZone.getID() : null );</span>

      // string to number conversion lenient?
<span class="fc" id="L3004">      outputStream.writeBoolean( lenientStringToNumber );</span>
<span class="nc" id="L3005">    } catch ( IOException e ) {</span>
<span class="nc" id="L3006">      throw new HopFileException( toString() + &quot; : Unable to write value metadata to output stream&quot;, e );</span>
<span class="fc" id="L3007">    }</span>
<span class="fc" id="L3008">  }</span>

  /**
   * Load the attributes of this particular value meta object from the input stream. Loading the type is not handled
   * here, this should be read from the stream previously!
   *
   * @param inputStream the input stream to read from
   * @throws HopFileException In case there was a IO problem
   * @throws HopEofException  If we reached the end of the stream
   */
  @Override
  public void readMetaData( DataInputStream inputStream ) throws HopFileException, HopEofException {

    // Loading the type is not handled here, this should be read from the stream previously!
    //
    try {

      // Handle storage type
<span class="fc" id="L3026">      storageType = inputStream.readInt();</span>

      // Read the data in the index
<span class="fc bfc" id="L3029" title="All 3 branches covered.">      switch ( storageType ) {</span>
        case STORAGE_TYPE_INDEXED:
<span class="fc" id="L3031">          int indexSize = inputStream.readInt();</span>
<span class="pc bpc" id="L3032" title="1 of 2 branches missed.">          if ( indexSize &lt; 0 ) {</span>
<span class="nc" id="L3033">            index = null;</span>
          } else {
<span class="fc" id="L3035">            index = new Object[ indexSize ];</span>
<span class="fc bfc" id="L3036" title="All 2 branches covered.">            for ( int i = 0; i &lt; indexSize; i++ ) {</span>
<span class="pc bpc" id="L3037" title="7 of 8 branches missed.">              switch ( type ) {</span>
                case TYPE_STRING:
<span class="fc" id="L3039">                  index[ i ] = readString( inputStream );</span>
<span class="fc" id="L3040">                  break;</span>
                case TYPE_NUMBER:
<span class="nc" id="L3042">                  index[ i ] = readNumber( inputStream );</span>
<span class="nc" id="L3043">                  break;</span>
                case TYPE_INTEGER:
<span class="nc" id="L3045">                  index[ i ] = readInteger( inputStream );</span>
<span class="nc" id="L3046">                  break;</span>
                case TYPE_DATE:
<span class="nc" id="L3048">                  index[ i ] = readDate( inputStream );</span>
<span class="nc" id="L3049">                  break;</span>
                case TYPE_BIGNUMBER:
<span class="nc" id="L3051">                  index[ i ] = readBigNumber( inputStream );</span>
<span class="nc" id="L3052">                  break;</span>
                case TYPE_BOOLEAN:
<span class="nc" id="L3054">                  index[ i ] = readBoolean( inputStream );</span>
<span class="nc" id="L3055">                  break;</span>
                case TYPE_BINARY:
<span class="nc" id="L3057">                  index[ i ] = readBinary( inputStream );</span>
<span class="nc" id="L3058">                  break;</span>
                default:
<span class="nc" id="L3060">                  throw new HopFileException( toString()</span>
<span class="nc" id="L3061">                    + &quot; : Unable to de-serialize indexed storage type for data type &quot; + getType() );</span>
              }
            }
          }
<span class="fc" id="L3065">          break;</span>

        case STORAGE_TYPE_BINARY_STRING:
          // In case we do have storage metadata defined, we read that back in as
          // well..
<span class="pc bpc" id="L3070" title="1 of 2 branches missed.">          if ( inputStream.readBoolean() ) {</span>
<span class="fc" id="L3071">            storageMetadata = new ValueMetaBase( inputStream );</span>
          }
          break;

        default:
          break;
      }

      // name
<span class="fc" id="L3080">      name = readString( inputStream );</span>

      // length &amp; precision
<span class="fc" id="L3083">      length = inputStream.readInt();</span>
<span class="fc" id="L3084">      precision = inputStream.readInt();</span>

      // Origin
<span class="fc" id="L3087">      origin = readString( inputStream );</span>

      // Comments
<span class="fc" id="L3090">      comments = readString( inputStream );</span>

      // formatting Mask, decimal, grouping, currency

<span class="fc" id="L3094">      conversionMask = readString( inputStream );</span>
<span class="fc" id="L3095">      decimalSymbol = readString( inputStream );</span>
<span class="fc" id="L3096">      groupingSymbol = readString( inputStream );</span>
<span class="fc" id="L3097">      currencySymbol = readString( inputStream );</span>
<span class="fc" id="L3098">      trimType = inputStream.readInt();</span>

      // Case sensitivity
<span class="fc" id="L3101">      caseInsensitive = inputStream.readBoolean();</span>

      // Collator locale
<span class="fc" id="L3104">      setCollatorLocale( Locale.forLanguageTag( readString( inputStream ) ) );</span>

      // Collator disabled
<span class="fc" id="L3107">      collatorDisabled = inputStream.readBoolean();</span>

      // Collator strength
<span class="fc" id="L3110">      collatorStrength = inputStream.readInt();</span>

      // Sorting type
<span class="fc" id="L3113">      sortedDescending = inputStream.readBoolean();</span>

      // Output padding?
<span class="fc" id="L3116">      outputPaddingEnabled = inputStream.readBoolean();</span>

      // is date parsing lenient?
      //
<span class="fc" id="L3120">      dateFormatLenient = inputStream.readBoolean();</span>

      // What is the date format locale?
      //
<span class="fc" id="L3124">      String strDateFormatLocale = readString( inputStream );</span>
<span class="pc bpc" id="L3125" title="1 of 2 branches missed.">      if ( Utils.isEmpty( strDateFormatLocale ) ) {</span>
<span class="nc" id="L3126">        dateFormatLocale = null;</span>
      } else {
<span class="fc" id="L3128">        dateFormatLocale = EnvUtil.createLocale( strDateFormatLocale );</span>
      }

      // What is the time zone to use for date parsing?
      //
<span class="fc" id="L3133">      String strTimeZone = readString( inputStream );</span>
<span class="pc bpc" id="L3134" title="1 of 2 branches missed.">      if ( Utils.isEmpty( strTimeZone ) ) {</span>
<span class="nc" id="L3135">        dateFormatTimeZone = TimeZone.getDefault();</span>
      } else {
<span class="fc" id="L3137">        dateFormatTimeZone = EnvUtil.createTimeZone( strTimeZone );</span>
      }

      // is string to number parsing lenient?
<span class="fc" id="L3141">      lenientStringToNumber = inputStream.readBoolean();</span>
<span class="nc" id="L3142">    } catch ( EOFException e ) {</span>
<span class="nc" id="L3143">      throw new HopEofException( e );</span>
<span class="nc" id="L3144">    } catch ( IOException e ) {</span>
<span class="nc" id="L3145">      throw new HopFileException( toString() + &quot; : Unable to read value metadata from input stream&quot;, e );</span>
<span class="fc" id="L3146">    }</span>

<span class="fc" id="L3148">  }</span>

  @Override
  public String getMetaXml() throws IOException {
<span class="fc" id="L3152">    StringBuilder xml = new StringBuilder();</span>

<span class="fc" id="L3154">    xml.append( XmlHandler.openTag( XML_META_TAG ) );</span>

<span class="fc" id="L3156">    xml.append( XmlHandler.addTagValue( &quot;type&quot;, getTypeDesc() ) );</span>
<span class="fc" id="L3157">    xml.append( XmlHandler.addTagValue( &quot;storagetype&quot;, getStorageTypeCode( getStorageType() ) ) );</span>

<span class="pc bpc" id="L3159" title="2 of 3 branches missed.">    switch ( storageType ) {</span>
      case STORAGE_TYPE_INDEXED:
<span class="nc" id="L3161">        xml.append( XmlHandler.openTag( &quot;index&quot; ) );</span>

        // Save the indexed strings...
        //
<span class="nc bnc" id="L3165" title="All 2 branches missed.">        if ( index != null ) {</span>
<span class="nc bnc" id="L3166" title="All 2 branches missed.">          for ( int i = 0; i &lt; index.length; i++ ) {</span>
            try {
<span class="nc bnc" id="L3168" title="All 8 branches missed.">              switch ( type ) {</span>
                case TYPE_STRING:
<span class="nc" id="L3170">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (String) index[ i ] ) );</span>
<span class="nc" id="L3171">                  break;</span>
                case TYPE_NUMBER:
<span class="nc" id="L3173">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (Double) index[ i ] ) );</span>
<span class="nc" id="L3174">                  break;</span>
                case TYPE_INTEGER:
<span class="nc" id="L3176">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (Long) index[ i ] ) );</span>
<span class="nc" id="L3177">                  break;</span>
                case TYPE_DATE:
<span class="nc" id="L3179">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (Date) index[ i ] ) );</span>
<span class="nc" id="L3180">                  break;</span>
                case TYPE_BIGNUMBER:
<span class="nc" id="L3182">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (BigDecimal) index[ i ] ) );</span>
<span class="nc" id="L3183">                  break;</span>
                case TYPE_BOOLEAN:
<span class="nc" id="L3185">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (Boolean) index[ i ] ) );</span>
<span class="nc" id="L3186">                  break;</span>
                case TYPE_BINARY:
<span class="nc" id="L3188">                  xml.append( XmlHandler.addTagValue( &quot;value&quot;, (byte[]) index[ i ] ) );</span>
<span class="nc" id="L3189">                  break;</span>
                default:
<span class="nc" id="L3191">                  throw new IOException( toString() + &quot; : Unable to serialize index storage type to XML for data type &quot;</span>
<span class="nc" id="L3192">                    + getType() );</span>
              }
<span class="nc" id="L3194">            } catch ( ClassCastException e ) {</span>
<span class="nc" id="L3195">              throw new RuntimeException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L3196">                + index[ i ].getClass().getName() + &quot; object [&quot; + index[ i ] + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L3197">                + toStringMeta() + &quot;]&quot; );</span>
<span class="nc" id="L3198">            }</span>
          }
        }
<span class="nc" id="L3201">        xml.append( XmlHandler.closeTag( &quot;index&quot; ) );</span>
<span class="nc" id="L3202">        break;</span>

      case STORAGE_TYPE_BINARY_STRING:
        // Save the storage meta data...
        //
<span class="nc bnc" id="L3207" title="All 2 branches missed.">        if ( storageMetadata != null ) {</span>
<span class="nc" id="L3208">          xml.append( XmlHandler.openTag( &quot;storage-meta&quot; ) );</span>
<span class="nc" id="L3209">          xml.append( storageMetadata.getMetaXml() );</span>
<span class="nc" id="L3210">          xml.append( XmlHandler.closeTag( &quot;storage-meta&quot; ) );</span>
        }
        break;

      default:
        break;
    }

<span class="fc" id="L3218">    xml.append( XmlHandler.addTagValue( &quot;name&quot;, name ) );</span>
<span class="fc" id="L3219">    xml.append( XmlHandler.addTagValue( &quot;length&quot;, length ) );</span>
<span class="fc" id="L3220">    xml.append( XmlHandler.addTagValue( &quot;precision&quot;, precision ) );</span>
<span class="fc" id="L3221">    xml.append( XmlHandler.addTagValue( &quot;origin&quot;, origin ) );</span>
<span class="fc" id="L3222">    xml.append( XmlHandler.addTagValue( &quot;comments&quot;, comments ) );</span>
<span class="fc" id="L3223">    xml.append( XmlHandler.addTagValue( &quot;conversion_Mask&quot;, conversionMask ) );</span>
<span class="fc" id="L3224">    xml.append( XmlHandler.addTagValue( &quot;decimal_symbol&quot;, decimalSymbol ) );</span>
<span class="fc" id="L3225">    xml.append( XmlHandler.addTagValue( &quot;grouping_symbol&quot;, groupingSymbol ) );</span>
<span class="fc" id="L3226">    xml.append( XmlHandler.addTagValue( &quot;currency_symbol&quot;, currencySymbol ) );</span>
<span class="fc" id="L3227">    xml.append( XmlHandler.addTagValue( &quot;trim_type&quot;, getTrimTypeCode( trimType ) ) );</span>
<span class="fc" id="L3228">    xml.append( XmlHandler.addTagValue( &quot;case_insensitive&quot;, caseInsensitive ) );</span>
<span class="fc" id="L3229">    xml.append( XmlHandler.addTagValue( &quot;collator_disabled&quot;, collatorDisabled ) );</span>
<span class="fc" id="L3230">    xml.append( XmlHandler.addTagValue( &quot;collator_strength&quot;, collatorStrength ) );</span>
<span class="fc" id="L3231">    xml.append( XmlHandler.addTagValue( &quot;sort_descending&quot;, sortedDescending ) );</span>
<span class="fc" id="L3232">    xml.append( XmlHandler.addTagValue( &quot;output_padding&quot;, outputPaddingEnabled ) );</span>
<span class="fc" id="L3233">    xml.append( XmlHandler.addTagValue( &quot;date_format_lenient&quot;, dateFormatLenient ) );</span>
<span class="pc bpc" id="L3234" title="1 of 2 branches missed.">    xml.append( XmlHandler.addTagValue( &quot;date_format_locale&quot;, dateFormatLocale != null ? dateFormatLocale.toString()</span>
      : null ) );
<span class="pc bpc" id="L3236" title="1 of 2 branches missed.">    xml.append( XmlHandler.addTagValue( &quot;date_format_timezone&quot;, dateFormatTimeZone != null ? dateFormatTimeZone.getID()</span>
      : null ) );
<span class="fc" id="L3238">    xml.append( XmlHandler.addTagValue( &quot;lenient_string_to_number&quot;, lenientStringToNumber ) );</span>

<span class="fc" id="L3240">    xml.append( XmlHandler.closeTag( XML_META_TAG ) );</span>

<span class="fc" id="L3242">    return xml.toString();</span>
  }

  @Override
  public String getDataXml(Object object ) throws IOException {
<span class="fc" id="L3247">    StringBuilder xml = new StringBuilder();</span>

    String string;

<span class="pc bpc" id="L3251" title="1 of 2 branches missed.">    if ( object != null ) {</span>
      try {
<span class="pc bpc" id="L3253" title="2 of 4 branches missed.">        switch ( storageType ) {</span>
          case STORAGE_TYPE_NORMAL:
            // Handle Content -- only when not NULL
            //
<span class="pc bpc" id="L3257" title="3 of 10 branches missed.">            switch ( getType() ) {</span>
              case TYPE_STRING:
<span class="fc" id="L3259">                string = (String) object;</span>
<span class="fc" id="L3260">                break;</span>
              case TYPE_NUMBER:
<span class="nc" id="L3262">                string = Double.toString( (Double) object );</span>
<span class="nc" id="L3263">                break;</span>
              case TYPE_INTEGER:
<span class="fc" id="L3265">                string = Long.toString( (Long) object );</span>
<span class="fc" id="L3266">                break;</span>
              case TYPE_DATE:
<span class="fc" id="L3268">                string = XmlHandler.date2string( (Date) object );</span>
<span class="fc" id="L3269">                break;</span>
              case TYPE_BIGNUMBER:
<span class="fc" id="L3271">                string = ( (BigDecimal) object ).toString();</span>
<span class="fc" id="L3272">                break;</span>
              case TYPE_BOOLEAN:
<span class="fc" id="L3274">                string = Boolean.toString( (Boolean) object );</span>
<span class="fc" id="L3275">                break;</span>
              case TYPE_BINARY:
<span class="nc" id="L3277">                string = XmlHandler.encodeBinaryData( (byte[]) object );</span>
<span class="nc" id="L3278">                break;</span>
              case TYPE_TIMESTAMP:
<span class="fc" id="L3280">                string = XmlHandler.timestamp2string( (Timestamp) object );</span>
<span class="fc" id="L3281">                break;</span>
              case TYPE_INET:
<span class="fc" id="L3283">                string = ( (InetAddress) object ).toString();</span>
<span class="fc" id="L3284">                break;</span>
              default:
<span class="nc" id="L3286">                throw new IOException( toString() + &quot; : Unable to serialize data type to XML &quot; + getType() );</span>
            }

            break;

          case STORAGE_TYPE_BINARY_STRING:
            // Handle binary string content -- only when not NULL
            // In this case, we opt not to convert anything at all for speed.
            // That way, we can save on CPU power.
            // Since the streams can be compressed, volume shouldn't be an issue
            // at all.
            //
<span class="fc" id="L3298">            string = XmlHandler.addTagValue( &quot;binary-string&quot;, (byte[]) object );</span>
<span class="fc" id="L3299">            xml.append( XmlHandler.openTag( XML_DATA_TAG ) ).append( string ).append( XmlHandler.closeTag( XML_DATA_TAG ) );</span>
<span class="fc" id="L3300">            return xml.toString();</span>

          case STORAGE_TYPE_INDEXED:
            // Just an index
<span class="nc" id="L3304">            string = XmlHandler.addTagValue( &quot;index-value&quot;, (Integer) object );</span>
<span class="nc" id="L3305">            break;</span>

          default:
<span class="nc" id="L3308">            throw new IOException( toString() + &quot; : Unknown storage type &quot; + getStorageType() );</span>
        }
<span class="nc" id="L3310">      } catch ( ClassCastException e ) {</span>
<span class="nc" id="L3311">        throw new RuntimeException( toString() + &quot; : There was a data type error: the data type of &quot;</span>
<span class="nc" id="L3312">          + object.getClass().getName() + &quot; object [&quot; + object + &quot;] does not correspond to value meta [&quot;</span>
<span class="nc" id="L3313">          + toStringMeta() + &quot;]&quot;, e );</span>
<span class="nc" id="L3314">      } catch ( Exception e ) {</span>
<span class="nc" id="L3315">        throw new RuntimeException( toString() + &quot; : there was a value XML encoding error&quot;, e );</span>
<span class="fc" id="L3316">      }</span>
    } else {
      // If the object is null: give an empty string
      //
<span class="nc" id="L3320">      string = &quot;&quot;;</span>
    }
<span class="fc" id="L3322">    xml.append( XmlHandler.addTagValue( XML_DATA_TAG, string ) );</span>

<span class="fc" id="L3324">    return xml.toString();</span>
  }

  /**
   * Convert a data XML node to an Object that corresponds to the metadata. This is basically String to Object
   * conversion that is being done.
   *
   * @param node the node to retrieve the data value from
   * @return the converted data value
   * @throws IOException thrown in case there is a problem with the XML to object conversion
   */
  @Override
  public Object getValue( Node node ) throws HopException {

<span class="pc bpc" id="L3338" title="3 of 4 branches missed.">    switch ( storageType ) {</span>
      case STORAGE_TYPE_NORMAL:
<span class="fc" id="L3340">        String valueString = XmlHandler.getNodeValue( node );</span>
<span class="fc bfc" id="L3341" title="All 2 branches covered.">        if ( Utils.isEmpty( valueString ) ) {</span>
<span class="fc" id="L3342">          return null;</span>
        }

        // Handle Content -- only when not NULL
        //
<span class="pc bpc" id="L3347" title="1 of 9 branches missed.">        switch ( getType() ) {</span>
          case TYPE_STRING:
<span class="fc" id="L3349">            return valueString;</span>
          case TYPE_NUMBER:
<span class="fc" id="L3351">            return Double.parseDouble( valueString );</span>
          case TYPE_INTEGER:
<span class="fc" id="L3353">            return Long.parseLong( valueString );</span>
          case TYPE_DATE:
<span class="fc" id="L3355">            return XmlHandler.stringToDate( valueString );</span>
          case TYPE_TIMESTAMP:
<span class="fc" id="L3357">            return XmlHandler.stringToTimestamp( valueString );</span>
          case TYPE_BIGNUMBER:
<span class="nc" id="L3359">            return new BigDecimal( valueString );</span>
          case TYPE_BOOLEAN:
<span class="fc" id="L3361">            return &quot;Y&quot;.equalsIgnoreCase( valueString );</span>
          case TYPE_BINARY:
<span class="fc" id="L3363">            return XmlHandler.stringToBinary( XmlHandler.getTagValue( node, &quot;binary-value&quot; ) );</span>
          default:
<span class="fc" id="L3365">            throw new HopException( toString() + &quot; : Unable to de-serialize '&quot; + valueString</span>
<span class="fc" id="L3366">              + &quot;' from XML for data type &quot; + getType() );</span>
        }

      case STORAGE_TYPE_BINARY_STRING:
        // Handle binary string content -- only when not NULL
        // In this case, we opt not to convert anything at all for speed.
        // That way, we can save on CPU power.
        // Since the streams can be compressed, volume shouldn't be an issue at
        // all.
        //
<span class="nc" id="L3376">        String binaryString = XmlHandler.getTagValue( node, &quot;binary-string&quot; );</span>
<span class="nc bnc" id="L3377" title="All 2 branches missed.">        if ( Utils.isEmpty( binaryString ) ) {</span>
<span class="nc" id="L3378">          return null;</span>
        }

<span class="nc" id="L3381">        return XmlHandler.stringToBinary( binaryString );</span>

      case STORAGE_TYPE_INDEXED:
<span class="nc" id="L3384">        String indexString = XmlHandler.getTagValue( node, &quot;index-value&quot; );</span>
<span class="nc bnc" id="L3385" title="All 2 branches missed.">        if ( Utils.isEmpty( indexString ) ) {</span>
<span class="nc" id="L3386">          return null;</span>
        }

<span class="nc" id="L3389">        return Integer.parseInt( indexString );</span>

      default:
<span class="nc" id="L3392">        throw new HopException( toString() + &quot; : Unknown storage type &quot; + getStorageType() );</span>
    }

  }

  /**
   * get an array of String describing the possible types a Value can have.
   *
   * @return an array of String describing the possible types a Value can have.
   */
  public static final String[] getTypes() {

<span class="nc" id="L3404">    return ValueMetaFactory.getValueMetaNames();</span>

    /*
     * String retval[] = new String[typeCodes.length - 1]; System.arraycopy(typeCodes, 1, retval, 0, typeCodes.length -
     * 1); return retval;
     */
  }

  /**
   * Get an array of String describing the possible types a Value can have.
   *
   * @return an array of String describing the possible types a Value can have.
   */
  public static final String[] getAllTypes() {

<span class="fc" id="L3419">    return ValueMetaFactory.getAllValueMetaNames();</span>

    /*
     * String retval[] = new String[typeCodes.length]; System.arraycopy(typeCodes, 0, retval, 0, typeCodes.length);
     * return retval;
     */
  }

  /**
   * TODO: change Desc to Code all over the place. Make sure we can localise this stuff later on.
   *
   * @param type the type
   * @return the description (code) of the type
   */
  public static final String getTypeDesc( int type ) {

<span class="fc" id="L3435">    return ValueMetaFactory.getValueMetaName( type );</span>

    // return typeCodes[type];
  }

  /**
   * Convert the String description of a type to an integer type.
   *
   * @param desc The description of the type to convert
   * @return The integer type of the given String. (IValueMeta.TYPE_...)
   */
  public static final int getType( String desc ) {

<span class="fc" id="L3448">    return ValueMetaFactory.getIdForValueMeta( desc );</span>

    /*
     * for (int i = 1; i &lt; typeCodes.length; i++) { if (typeCodes[i].equalsIgnoreCase(desc)) { return i; } }
     *
     * return TYPE_NONE;
     */
  }

  /**
   * Convert the String description of a storage type to an integer type.
   *
   * @param desc The description of the storage type to convert
   * @return The integer storage type of the given String. (IValueMeta.STORAGE_TYPE_...) or -1 if the storage
   * type code not be found.
   */
  public static final int getStorageType( String desc ) {
<span class="pc bpc" id="L3465" title="1 of 2 branches missed.">    for ( int i = 0; i &lt; storageTypeCodes.length; i++ ) {</span>
<span class="pc bpc" id="L3466" title="1 of 2 branches missed.">      if ( storageTypeCodes[ i ].equalsIgnoreCase( desc ) ) {</span>
<span class="fc" id="L3467">        return i;</span>
      }
    }

<span class="nc" id="L3471">    return -1;</span>
  }

  public static final String getStorageTypeCode( int storageType ) {
<span class="pc bpc" id="L3475" title="2 of 4 branches missed.">    if ( storageType &gt;= STORAGE_TYPE_NORMAL &amp;&amp; storageType &lt;= STORAGE_TYPE_INDEXED ) {</span>
<span class="fc" id="L3476">      return storageTypeCodes[ storageType ];</span>
    }
<span class="nc" id="L3478">    return null;</span>
  }

  /**
   * Determine if an object is null. This is the case if data==null or if it's an empty string.
   *
   * @param data the object to test
   * @return true if the object is considered null.
   * @throws HopValueException in case there is a conversion error (only thrown in case of lazy conversion)
   */
  @Override
  public boolean isNull( Object data ) throws HopValueException {
    //noinspection deprecation
<span class="fc" id="L3491">    return isNull( data, emptyStringAndNullAreDifferent );</span>
  }

  /*
   * Do not use this method directly! It is for tests!
   */
  @Deprecated
  boolean isNull( Object data, boolean emptyStringDiffersFromNull ) throws HopValueException {
    try {
<span class="fc" id="L3500">      Object value = data;</span>

<span class="fc bfc" id="L3502" title="All 2 branches covered.">      if ( isStorageBinaryString() ) {</span>
<span class="pc bpc" id="L3503" title="2 of 6 branches missed.">        if ( value == null || !emptyStringDiffersFromNull &amp;&amp; ( (byte[]) value ).length == 0 ) {</span>
<span class="fc" id="L3504">          return true; // shortcut</span>
        }
<span class="fc" id="L3506">        value = convertBinaryStringToNativeType( (byte[]) data );</span>
      }

      // Re-check for null, even for lazy conversion.
      // A value (5 spaces for example) can be null after trim and conversion
      //
<span class="fc bfc" id="L3512" title="All 2 branches covered.">      if ( value == null ) {</span>
<span class="fc" id="L3513">        return true;</span>
      }

<span class="fc bfc" id="L3516" title="All 2 branches covered.">      if ( emptyStringDiffersFromNull ) {</span>
<span class="fc" id="L3517">        return false;</span>
      }

      // If it's a string and the string is empty, it's a null value as well
      //
<span class="fc bfc" id="L3522" title="All 2 branches covered.">      if ( isString() ) {</span>
<span class="fc bfc" id="L3523" title="All 2 branches covered.">        if ( value.toString().length() == 0 ) {</span>
<span class="fc" id="L3524">          return true;</span>
        }
      }

      // We tried everything else so we assume this value is not null.
      //
<span class="fc" id="L3530">      return false;</span>
<span class="nc" id="L3531">    } catch ( ClassCastException e ) {</span>
<span class="nc" id="L3532">      throw new RuntimeException( &quot;Unable to verify if [&quot; + toString() + &quot;] is null or not because of an error:&quot;</span>
<span class="nc" id="L3533">        + e.toString(), e );</span>
    }
  }

  /*
   * Compare 2 binary strings, one byte at a time.&lt;br&gt; This algorithm is very fast but most likely wrong as well.&lt;br&gt;
   *
   * @param one The first binary string to compare with
   *
   * @param two the second binary string to compare to
   *
   * @return -1 if &lt;i&gt;one&lt;/i&gt; is smaller than &lt;i&gt;two&lt;/i&gt;, 0 is both byte arrays are identical and 1 if &lt;i&gt;one&lt;/i&gt; is
   * larger than &lt;i&gt;two&lt;/i&gt; protected int compareBinaryStrings(byte[] one, byte[] two) {
   *
   * for (int i=0;i&lt;one.length;i++) { if (i&gt;=two.length) return 1; // larger if (one[i]&gt;two[i]) return 1; // larger if
   * (one[i]&lt;two[i]) return -1; // smaller } if (one.length&gt;two.length) return 1; // larger if (one.length&gt;two.length)
   * return -11; // smaller return 0; }
   */

  /**
   * Compare 2 values of the same data type
   *
   * @param data1 the first value
   * @param data2 the second value
   * @return 0 if the values are equal, -1 if data1 is smaller than data2 and +1 if it's larger.
   * @throws HopValueException In case we get conversion errors
   */
  @Override
  public int compare( Object data1, Object data2 ) throws HopValueException {
<span class="fc" id="L3562">    boolean n1 = isNull( data1 );</span>
<span class="fc" id="L3563">    boolean n2 = isNull( data2 );</span>

<span class="fc bfc" id="L3565" title="All 4 branches covered.">    if ( n1 &amp;&amp; !n2 ) {</span>
<span class="fc bfc" id="L3566" title="All 2 branches covered.">      if ( isSortedDescending() ) {</span>
        // BACKLOG-14028
<span class="fc" id="L3568">        return 1;</span>
      } else {
<span class="fc" id="L3570">        return -1;</span>
      }
    }
<span class="fc bfc" id="L3573" title="All 4 branches covered.">    if ( !n1 &amp;&amp; n2 ) {</span>
<span class="pc bpc" id="L3574" title="1 of 2 branches missed.">      if ( isSortedDescending() ) {</span>
<span class="nc" id="L3575">        return -1;</span>
      } else {
<span class="fc" id="L3577">        return 1;</span>
      }
    }
<span class="pc bpc" id="L3580" title="1 of 4 branches missed.">    if ( n1 &amp;&amp; n2 ) {</span>
<span class="fc" id="L3581">      return 0;</span>
    }

<span class="fc" id="L3584">    int cmp = 0;</span>

    //If a comparator is not provided, default to the type comparisons
<span class="pc bpc" id="L3587" title="1 of 2 branches missed.">    if ( comparator == null ) {</span>
<span class="fc" id="L3588">      cmp = typeCompare( data1, data2 );</span>
    } else {
<span class="nc" id="L3590">      cmp = comparator.compare( data1, data2 );</span>
    }

<span class="pc bpc" id="L3593" title="1 of 2 branches missed.">    if ( isSortedDescending() ) {</span>
<span class="nc" id="L3594">      return -cmp;</span>
    } else {
<span class="fc" id="L3596">      return cmp;</span>
    }
  }

  private int typeCompare( Object data1, Object data2 ) throws HopValueException {
<span class="fc" id="L3601">    int cmp = 0;</span>
<span class="pc bpc" id="L3602" title="1 of 8 branches missed.">    switch ( getType() ) {</span>
      case TYPE_STRING:
        // if (isStorageBinaryString() &amp;&amp; identicalFormat &amp;&amp;
        // storageMetadata.isSingleByteEncoding()) return
        // compareBinaryStrings((byte[])data1, (byte[])data2); TODO
<span class="fc" id="L3607">        String one = getString( data1 );</span>
<span class="fc" id="L3608">        String two = getString( data2 );</span>

<span class="fc bfc" id="L3610" title="All 2 branches covered.">        if ( ignoreWhitespace ) {</span>
<span class="fc" id="L3611">          one = one.trim();</span>
<span class="fc" id="L3612">          two = two.trim();</span>
        }

<span class="fc bfc" id="L3615" title="All 2 branches covered.">        if ( collatorDisabled ) {</span>
<span class="pc bpc" id="L3616" title="1 of 2 branches missed.">          if ( caseInsensitive ) {</span>
<span class="nc" id="L3617">            cmp = one.compareToIgnoreCase( two );</span>
          } else {
<span class="fc" id="L3619">            cmp = one.compareTo( two );</span>
          }
        } else {
<span class="fc" id="L3622">          cmp = collator.compare( one, two );</span>
        }
<span class="fc" id="L3624">        break;</span>

      case TYPE_INTEGER:
        // if (isStorageBinaryString() &amp;&amp; identicalFormat) return
        // compareBinaryStrings((byte[])data1, (byte[])data2); TODO
<span class="fc" id="L3629">        cmp = getInteger( data1 ).compareTo( getInteger( data2 ) );</span>
<span class="fc" id="L3630">        break;</span>

      case TYPE_NUMBER:
<span class="fc" id="L3633">        cmp = Double.compare( getNumber( data1 ).doubleValue(), getNumber( data2 ).doubleValue() );</span>
<span class="fc" id="L3634">        break;</span>

      case TYPE_DATE:
<span class="fc" id="L3637">        cmp = Long.valueOf( getDate( data1 ).getTime() ).compareTo( Long.valueOf( getDate( data2 ).getTime() ) );</span>
<span class="fc" id="L3638">        break;</span>

      case TYPE_BIGNUMBER:
<span class="fc" id="L3641">        cmp = getBigNumber( data1 ).compareTo( getBigNumber( data2 ) );</span>
<span class="fc" id="L3642">        break;</span>

      case TYPE_BOOLEAN:
<span class="fc bfc" id="L3645" title="All 2 branches covered.">        if ( getBoolean( data1 ).booleanValue() == getBoolean( data2 ).booleanValue() ) {</span>
<span class="fc" id="L3646">          cmp = 0; // true == true, false == false</span>
<span class="pc bpc" id="L3647" title="3 of 4 branches missed.">        } else if ( getBoolean( data1 ).booleanValue() &amp;&amp; !getBoolean( data2 ).booleanValue() ) {</span>
<span class="nc" id="L3648">          cmp = 1; // true &gt; false</span>
        } else {
<span class="fc" id="L3650">          cmp = -1; // false &lt; true</span>
        }
<span class="fc" id="L3652">        break;</span>

      case TYPE_BINARY:
<span class="fc" id="L3655">        byte[] b1 = (byte[]) data1;</span>
<span class="fc" id="L3656">        byte[] b2 = (byte[]) data2;</span>

<span class="pc bpc" id="L3658" title="1 of 2 branches missed.">        int length = b1.length &lt; b2.length ? b1.length : b2.length;</span>

<span class="fc" id="L3660">        cmp = b1.length - b2.length;</span>
<span class="pc bpc" id="L3661" title="1 of 2 branches missed.">        if ( cmp == 0 ) {</span>
<span class="fc bfc" id="L3662" title="All 2 branches covered.">          for ( int i = 0; i &lt; length; i++ ) {</span>
<span class="fc" id="L3663">            cmp = b1[ i ] - b2[ i ];</span>
<span class="fc bfc" id="L3664" title="All 2 branches covered.">            if ( cmp != 0 ) {</span>
<span class="fc bfc" id="L3665" title="All 2 branches covered.">              cmp = cmp &lt; 0 ? -1 : 1;</span>
<span class="fc" id="L3666">              break;</span>
            }
          }
        }

        break;
      default:
<span class="nc" id="L3673">        throw new HopValueException( toString() + &quot; : Comparing values can not be done with data type : &quot;</span>
<span class="nc" id="L3674">          + getType() );</span>
    }
<span class="fc" id="L3676">    return cmp;</span>

  }

  /**
   * Compare 2 values of the same data type
   *
   * @param data1 the first value
   * @param meta2 the second value's metadata
   * @param data2 the second value
   * @return 0 if the values are equal, -1 if data1 is smaller than data2 and +1 if it's larger.
   * @throws HopValueException In case we get conversion errors
   */
  @Override
  public int compare( Object data1, IValueMeta meta2, Object data2 ) throws HopValueException {
<span class="pc bpc" id="L3691" title="1 of 2 branches missed.">    if ( meta2 == null ) {</span>
<span class="nc" id="L3692">      throw new HopValueException( toStringMeta()</span>
        + &quot; : Second meta data (meta2) is null, please check one of the previous transforms.&quot; );
    }

    try {
      // Before we can compare data1 to data2 we need to make sure they have the
      // same data type etc.
      //
<span class="fc bfc" id="L3700" title="All 2 branches covered.">      if ( getType() == meta2.getType() ) {</span>
<span class="fc bfc" id="L3701" title="All 2 branches covered.">        if ( getStorageType() == meta2.getStorageType() ) {</span>
<span class="fc" id="L3702">          return compare( data1, data2 );</span>
        }

        // Convert the storage type to compare the data.
        //
<span class="pc bpc" id="L3707" title="3 of 4 branches missed.">        switch ( getStorageType() ) {</span>
          case STORAGE_TYPE_NORMAL:
<span class="nc" id="L3709">            return compare( data1, meta2.convertToNormalStorageType( data2 ) );</span>
          case STORAGE_TYPE_BINARY_STRING:
<span class="pc bpc" id="L3711" title="2 of 6 branches missed.">            if ( storageMetadata != null &amp;&amp; storageMetadata.getConversionMask() != null &amp;&amp; !meta2.isNumber() ) {</span>
              // BACKLOG-18754 - if there is a storage conversion mask, we should use
              // it as the mask for meta2 (meta2 can have specific storage type and type, so
              // it can't be used directly to convert data2 to binary string)
<span class="fc" id="L3715">              IValueMeta meta2StorageMask = meta2.clone();</span>
<span class="fc" id="L3716">              meta2StorageMask.setConversionMask( storageMetadata.getConversionMask() );</span>
<span class="fc" id="L3717">              return compare( data1, meta2StorageMask.convertToBinaryStringStorageType( data2 ) );</span>
            } else {
<span class="fc" id="L3719">              return compare( data1, meta2.convertToBinaryStringStorageType( data2 ) );</span>
            }
          case STORAGE_TYPE_INDEXED:
<span class="nc bnc" id="L3722" title="All 4 branches missed.">            switch ( meta2.getStorageType() ) {</span>
              case STORAGE_TYPE_INDEXED:
<span class="nc" id="L3724">                return compare( data1, data2 ); // not accessible, just to make sure.</span>
              case STORAGE_TYPE_NORMAL:
<span class="nc" id="L3726">                return -meta2.compare( data2, convertToNormalStorageType( data1 ) );</span>
              case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L3728">                return -meta2.compare( data2, convertToBinaryStringStorageType( data1 ) );</span>
              default:
<span class="nc" id="L3730">                throw new HopValueException( meta2.toStringMeta() + &quot; : Unknown storage type : &quot;</span>
<span class="nc" id="L3731">                  + meta2.getStorageType() );</span>

            }
          default:
<span class="nc" id="L3735">            throw new HopValueException( toStringMeta() + &quot; : Unknown storage type : &quot; + getStorageType() );</span>
        }
<span class="pc bpc" id="L3737" title="2 of 4 branches missed.">      } else if ( IValueMeta.TYPE_INTEGER == getType() &amp;&amp; IValueMeta.TYPE_NUMBER == meta2.getType() ) {</span>
        // BACKLOG-18738
        // compare Double to Integer
<span class="fc" id="L3740">        return -meta2.compare( data2, meta2.convertData( this, data1 ) );</span>
      }

      // If the data types are not the same, the first one is the driver...
      // The second data type is converted to the first one.
      //
<span class="nc" id="L3746">      return compare( data1, convertData( meta2, data2 ) );</span>
<span class="nc" id="L3747">    } catch ( Exception e ) {</span>
<span class="nc" id="L3748">      throw new HopValueException(</span>
<span class="nc" id="L3749">        toStringMeta() + &quot; : Unable to compare with value [&quot; + meta2.toStringMeta() + &quot;]&quot;, e );</span>
    }
  }

  /**
   * Convert the specified data to the data type specified in this object.
   *
   * @param meta2 the metadata of the object to be converted
   * @param data2 the data of the object to be converted
   * @return the object in the data type of this value metadata object
   * @throws HopValueException in case there is a data conversion error
   */
  @Override
  public Object convertData( IValueMeta meta2, Object data2 ) throws HopValueException {
<span class="pc bpc" id="L3763" title="2 of 8 branches missed.">    switch ( getType() ) {</span>
      case TYPE_NONE:
      case TYPE_STRING:
<span class="fc" id="L3766">        return meta2.getString( data2 );</span>
      case TYPE_NUMBER:
<span class="fc" id="L3768">        return meta2.getNumber( data2 );</span>
      case TYPE_INTEGER:
<span class="fc" id="L3770">        return meta2.getInteger( data2 );</span>
      case TYPE_DATE:
<span class="fc" id="L3772">        return meta2.getDate( data2 );</span>
      case TYPE_BIGNUMBER:
<span class="fc" id="L3774">        return meta2.getBigNumber( data2 );</span>
      case TYPE_BOOLEAN:
<span class="fc" id="L3776">        return meta2.getBoolean( data2 );</span>
      case TYPE_BINARY:
<span class="nc" id="L3778">        return meta2.getBinary( data2 );</span>
      default:
<span class="nc" id="L3780">        throw new HopValueException( toString() + &quot; : I can't convert the specified value to data type : &quot;</span>
<span class="nc" id="L3781">          + getType() );</span>
    }
  }

  /**
   * Convert the specified data to the data type specified in this object. For String conversion, be compatible with
   * version 2.5.2.
   *
   * @param meta2 the metadata of the object to be converted
   * @param data2 the data of the object to be converted
   * @return the object in the data type of this value metadata object
   * @throws HopValueException in case there is a data conversion error
   */
  @Override
  public Object convertDataCompatible( IValueMeta meta2, Object data2 ) throws HopValueException {
<span class="nc bnc" id="L3796" title="All 8 branches missed.">    switch ( getType() ) {</span>
      case TYPE_STRING:
<span class="nc" id="L3798">        return meta2.getCompatibleString( data2 );</span>
      case TYPE_NUMBER:
<span class="nc" id="L3800">        return meta2.getNumber( data2 );</span>
      case TYPE_INTEGER:
<span class="nc" id="L3802">        return meta2.getInteger( data2 );</span>
      case TYPE_DATE:
<span class="nc" id="L3804">        return meta2.getDate( data2 );</span>
      case TYPE_BIGNUMBER:
<span class="nc" id="L3806">        return meta2.getBigNumber( data2 );</span>
      case TYPE_BOOLEAN:
<span class="nc" id="L3808">        return meta2.getBoolean( data2 );</span>
      case TYPE_BINARY:
<span class="nc" id="L3810">        return meta2.getBinary( data2 );</span>
      default:
<span class="nc" id="L3812">        throw new HopValueException( toString() + &quot; : I can't convert the specified value to data type : &quot;</span>
<span class="nc" id="L3813">          + getType() );</span>
    }
  }

  /**
   * Convert an object to the data type specified in the conversion metadata
   *
   * @param data The data
   * @return The data converted to the storage data type
   * @throws HopValueException in case there is a conversion error.
   */
  @Override
  public Object convertDataUsingConversionMetaData( Object data ) throws HopValueException {
<span class="pc bpc" id="L3826" title="1 of 2 branches missed.">    if ( conversionMetadata == null ) {</span>
<span class="nc" id="L3827">      throw new HopValueException(</span>
        &quot;API coding error: please specify the conversion metadata before attempting to convert value &quot; + name );
    }

    // Suppose we have an Integer 123, length 5
    // The string variation of this is &quot; 00123&quot;
    // To convert this back to an Integer we use the storage metadata
    // Specifically, in method convertStringToInteger() we consult the
    // storageMetaData to get the correct conversion mask
    // That way we're always sure that a conversion works both ways.
    //

<span class="pc bpc" id="L3839" title="1 of 9 branches missed.">    switch ( conversionMetadata.getType() ) {</span>
      case TYPE_STRING:
<span class="fc" id="L3841">        return getString( data );</span>
      case TYPE_INTEGER:
<span class="fc" id="L3843">        return getInteger( data );</span>
      case TYPE_NUMBER:
<span class="fc" id="L3845">        return getNumber( data );</span>
      case TYPE_DATE:
<span class="fc" id="L3847">        return getDate( data );</span>
      case TYPE_BIGNUMBER:
<span class="fc" id="L3849">        return getBigNumber( data );</span>
      case TYPE_BOOLEAN:
<span class="fc" id="L3851">        return getBoolean( data );</span>
      case TYPE_BINARY:
<span class="nc" id="L3853">        return getBinary( data );</span>
      case TYPE_TIMESTAMP:
<span class="fc" id="L3855">        return getDate( data );</span>
      default:
<span class="fc" id="L3857">        throw new HopValueException( toString() + &quot; : I can't convert the specified value to data type : &quot;</span>
<span class="fc" id="L3858">          + conversionMetadata.getType() );</span>
    }
  }

  /**
   * Convert the specified string to the data type specified in this object.
   *
   * @param pol         the string to be converted
   * @param convertMeta the metadata of the object (only string type) to be converted
   * @param nullIf      set the object to null if pos equals nullif (IgnoreCase)
   * @param ifNull      set the object to ifNull when pol is empty or null
   * @param trim_type   the trim type to be used (IValueMeta.TRIM_TYPE_XXX)
   * @return the object in the data type of this value metadata object
   * @throws HopValueException in case there is a data conversion error
   */
  @Override
  public Object convertDataFromString( String pol, IValueMeta convertMeta, String nullIf, String ifNull,
                                       int trim_type ) throws HopValueException {
<span class="fc bfc" id="L3876" title="All 2 branches covered.">    if ( convertMeta == null ) {</span>
<span class="fc" id="L3877">      throw new HopValueException( &quot;API coding error: convertMeta input parameter should not be equals to null&quot; );</span>
    }
    // null handling and conversion of value to null
    //
<span class="fc" id="L3881">    String null_value = nullIf;</span>
<span class="fc" id="L3882">    int inValueType = convertMeta.getType();</span>
<span class="fc" id="L3883">    int outValueType = getType();</span>

<span class="pc bpc" id="L3885" title="1 of 2 branches missed.">    if ( null_value == null ) {</span>
<span class="pc bpc" id="L3886" title="7 of 8 branches missed.">      switch ( inValueType ) {</span>
        case IValueMeta.TYPE_BOOLEAN:
<span class="nc" id="L3888">          null_value = Const.NULL_BOOLEAN;</span>
<span class="nc" id="L3889">          break;</span>
        case IValueMeta.TYPE_STRING:
<span class="fc" id="L3891">          null_value = Const.NULL_STRING;</span>
<span class="fc" id="L3892">          break;</span>
        case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L3894">          null_value = Const.NULL_BIGNUMBER;</span>
<span class="nc" id="L3895">          break;</span>
        case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L3897">          null_value = Const.NULL_NUMBER;</span>
<span class="nc" id="L3898">          break;</span>
        case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L3900">          null_value = Const.NULL_INTEGER;</span>
<span class="nc" id="L3901">          break;</span>
        case IValueMeta.TYPE_DATE:
<span class="nc" id="L3903">          null_value = Const.NULL_DATE;</span>
<span class="nc" id="L3904">          break;</span>
        case IValueMeta.TYPE_BINARY:
<span class="nc" id="L3906">          null_value = Const.NULL_BINARY;</span>
<span class="nc" id="L3907">          break;</span>
        default:
<span class="nc" id="L3909">          null_value = Const.NULL_NONE;</span>
          break;
      }
    }

    // See if we need to convert a null value into a String
    // For example, we might want to convert null into &quot;Empty&quot;.
    //
<span class="pc bpc" id="L3917" title="1 of 2 branches missed.">    if ( !Utils.isEmpty( ifNull ) ) {</span>
      // Note that you can't pull the pad method up here as a nullComp variable
      // because you could get an NPE since you haven't checked isEmpty(pol)
      // yet!
<span class="nc bnc" id="L3921" title="All 2 branches missed.">      if ( Utils.isEmpty( pol )</span>
<span class="nc bnc" id="L3922" title="All 2 branches missed.">        || pol.equalsIgnoreCase( Const.rightPad( new StringBuilder( null_value ), pol.length() ) ) ) {</span>
<span class="nc" id="L3923">        pol = ifNull;</span>
      }
    }

    // See if the polled value is empty
    // In that case, we have a null value on our hands...
<span class="fc bfc" id="L3929" title="All 2 branches covered.">    boolean isStringValue = outValueType == IValueMeta.TYPE_STRING;</span>
<span class="fc bfc" id="L3930" title="All 2 branches covered.">    Object emptyValue = isStringValue ? Const.NULL_STRING : null;</span>

<span class="fc" id="L3932">    Boolean isEmptyAndNullDiffer = convertStringToBoolean(</span>
<span class="fc" id="L3933">      Const.NVL( System.getProperty( Const.HOP_EMPTY_STRING_DIFFERS_FROM_NULL, &quot;N&quot; ), &quot;N&quot; ) );</span>

<span class="pc bpc" id="L3935" title="1 of 6 branches missed.">    if ( pol == null &amp;&amp; isStringValue &amp;&amp; isEmptyAndNullDiffer ) {</span>
<span class="fc" id="L3936">      pol = Const.NULL_STRING;</span>
    }

<span class="fc bfc" id="L3939" title="All 2 branches covered.">    if ( pol == null ) {</span>
<span class="fc" id="L3940">      return null;</span>
<span class="pc bpc" id="L3941" title="1 of 4 branches missed.">    } else if ( Utils.isEmpty( pol ) &amp;&amp; !isStringValue ) {</span>
<span class="fc" id="L3942">      return null;</span>
    } else {
      // if the null_value is specified, we try to match with that.
      //
<span class="pc bpc" id="L3946" title="1 of 2 branches missed.">      if ( !Utils.isEmpty( null_value ) ) {</span>
<span class="nc bnc" id="L3947" title="All 2 branches missed.">        if ( null_value.length() &lt;= pol.length() ) {</span>
          // If the polled value is equal to the spaces right-padded null_value,
          // we have a match
          //
<span class="nc bnc" id="L3951" title="All 2 branches missed.">          if ( pol.equalsIgnoreCase( Const.rightPad( new StringBuilder( null_value ), pol.length() ) ) ) {</span>
<span class="nc" id="L3952">            return emptyValue;</span>
          }
        }
      } else {
        // Verify if there are only spaces in the polled value...
        // We consider that empty as well...
        //
<span class="pc bpc" id="L3959" title="1 of 2 branches missed.">        if ( Const.onlySpaces( pol ) ) {</span>
<span class="fc" id="L3960">          return emptyValue;</span>
        }
      }
    }

    // Trimming
    StringBuilder strpol;
<span class="nc bnc" id="L3967" title="All 4 branches missed.">    switch ( trim_type ) {</span>
      case IValueMeta.TRIM_TYPE_LEFT:
<span class="nc" id="L3969">        strpol = new StringBuilder( pol );</span>
<span class="nc bnc" id="L3970" title="All 4 branches missed.">        while ( strpol.length() &gt; 0 &amp;&amp; strpol.charAt( 0 ) == ' ' ) {</span>
<span class="nc" id="L3971">          strpol.deleteCharAt( 0 );</span>
        }
<span class="nc" id="L3973">        pol = strpol.toString();</span>

<span class="nc" id="L3975">        break;</span>
      case IValueMeta.TRIM_TYPE_RIGHT:
<span class="nc" id="L3977">        strpol = new StringBuilder( pol );</span>
<span class="nc bnc" id="L3978" title="All 4 branches missed.">        while ( strpol.length() &gt; 0 &amp;&amp; strpol.charAt( strpol.length() - 1 ) == ' ' ) {</span>
<span class="nc" id="L3979">          strpol.deleteCharAt( strpol.length() - 1 );</span>
        }
<span class="nc" id="L3981">        pol = strpol.toString();</span>

<span class="nc" id="L3983">        break;</span>
      case IValueMeta.TRIM_TYPE_BOTH:
<span class="nc" id="L3985">        strpol = new StringBuilder( pol );</span>
<span class="nc bnc" id="L3986" title="All 4 branches missed.">        while ( strpol.length() &gt; 0 &amp;&amp; strpol.charAt( 0 ) == ' ' ) {</span>
<span class="nc" id="L3987">          strpol.deleteCharAt( 0 );</span>
        }
<span class="nc bnc" id="L3989" title="All 4 branches missed.">        while ( strpol.length() &gt; 0 &amp;&amp; strpol.charAt( strpol.length() - 1 ) == ' ' ) {</span>
<span class="nc" id="L3990">          strpol.deleteCharAt( strpol.length() - 1 );</span>
        }
<span class="nc" id="L3992">        pol = strpol.toString();</span>
<span class="nc" id="L3993">        break;</span>
      default:
        break;
    }

    // On with the regular program...
    // Simply call the ValueMeta routines to do the conversion
    // We need to do some effort here: copy all
    //
<span class="nc" id="L4002">    return convertData( convertMeta, pol );</span>
  }

  /**
   * Calculate the hashcode of the specified data object
   *
   * @param object the data value to calculate a hashcode for
   * @return the calculated hashcode
   * @throws HopValueException
   */
  @Override
  public int hashCode( Object object ) throws HopValueException {
<span class="fc" id="L4014">    int hash = 0;</span>

<span class="fc bfc" id="L4016" title="All 2 branches covered.">    if ( isNull( object ) ) {</span>
<span class="pc bpc" id="L4017" title="1 of 11 branches missed.">      switch ( getType() ) {</span>
        case TYPE_BOOLEAN:
<span class="fc" id="L4019">          hash ^= 1;</span>
<span class="fc" id="L4020">          break;</span>
        case TYPE_DATE:
<span class="fc" id="L4022">          hash ^= 2;</span>
<span class="fc" id="L4023">          break;</span>
        case TYPE_NUMBER:
<span class="fc" id="L4025">          hash ^= 4;</span>
<span class="fc" id="L4026">          break;</span>
        case TYPE_STRING:
<span class="fc" id="L4028">          hash ^= 8;</span>
<span class="fc" id="L4029">          break;</span>
        case TYPE_INTEGER:
<span class="fc" id="L4031">          hash ^= 16;</span>
<span class="fc" id="L4032">          break;</span>
        case TYPE_BIGNUMBER:
<span class="fc" id="L4034">          hash ^= 32;</span>
<span class="fc" id="L4035">          break;</span>
        case TYPE_BINARY:
<span class="fc" id="L4037">          hash ^= 64;</span>
<span class="fc" id="L4038">          break;</span>
        case TYPE_TIMESTAMP:
<span class="fc" id="L4040">          hash ^= 128;</span>
<span class="fc" id="L4041">          break;</span>
        case TYPE_INET:
<span class="fc" id="L4043">          hash ^= 256;</span>
<span class="fc" id="L4044">          break;</span>
        case TYPE_NONE:
<span class="fc" id="L4046">          break;</span>
        default:
<span class="nc" id="L4048">          break;</span>
      }
    } else {
<span class="pc bpc" id="L4051" title="1 of 11 branches missed.">      switch ( getType() ) {</span>
        case TYPE_BOOLEAN:
<span class="fc" id="L4053">          hash ^= getBoolean( object ).hashCode();</span>
<span class="fc" id="L4054">          break;</span>
        case TYPE_DATE:
<span class="fc" id="L4056">          hash ^= getDate( object ).hashCode();</span>
<span class="fc" id="L4057">          break;</span>
        case TYPE_INTEGER:
<span class="fc" id="L4059">          hash ^= getInteger( object ).hashCode();</span>
<span class="fc" id="L4060">          break;</span>
        case TYPE_NUMBER:
<span class="fc" id="L4062">          hash ^= getNumber( object ).hashCode();</span>
<span class="fc" id="L4063">          break;</span>
        case TYPE_STRING:
<span class="fc" id="L4065">          hash ^= getString( object ).hashCode();</span>
<span class="fc" id="L4066">          break;</span>
        case TYPE_BIGNUMBER:
<span class="fc" id="L4068">          hash ^= getBigNumber( object ).hashCode();</span>
<span class="fc" id="L4069">          break;</span>
        case TYPE_BINARY:
<span class="fc" id="L4071">          hash ^= Arrays.hashCode( (byte[]) object );</span>
<span class="fc" id="L4072">          break;</span>
        case TYPE_TIMESTAMP:
<span class="fc" id="L4074">          hash ^= ( (Timestamp) object ).hashCode();</span>
<span class="fc" id="L4075">          break;</span>
        case TYPE_INET:
<span class="fc" id="L4077">          hash ^= ( (InetAddress) object ).hashCode();</span>
<span class="fc" id="L4078">          break;</span>
        case TYPE_NONE:
<span class="fc" id="L4080">          break;</span>
        default:
          break;
      }
    }

<span class="fc" id="L4086">    return hash;</span>
  }


  /**
   * @return the storageMetadata
   */
  @Override
  public IValueMeta getStorageMetadata() {
<span class="fc" id="L4095">    return storageMetadata;</span>
  }

  /**
   * @param storageMetadata the storageMetadata to set
   */
  @Override
  public void setStorageMetadata( IValueMeta storageMetadata ) {
<span class="fc" id="L4103">    this.storageMetadata = storageMetadata;</span>
<span class="fc" id="L4104">    compareStorageAndActualFormat();</span>
<span class="fc" id="L4105">  }</span>

  protected void compareStorageAndActualFormat() {

<span class="fc bfc" id="L4109" title="All 2 branches covered.">    if ( storageMetadata == null ) {</span>
<span class="fc" id="L4110">      identicalFormat = true;</span>
    } else {

      // If a trim type is set, we need to at least try to trim the strings.
      // In that case, we have to set the identical format off.
      //
<span class="fc bfc" id="L4116" title="All 2 branches covered.">      if ( trimType != TRIM_TYPE_NONE ) {</span>
<span class="fc" id="L4117">        identicalFormat = false;</span>
      } else {

        // If there is a string encoding set and it's the same encoding in the
        // binary string, then we don't have to convert
        // If there are no encodings set, then we're certain we don't have to
        // convert as well.
        //
<span class="pc bpc" id="L4125" title="1 of 4 branches missed.">        if ( getStringEncoding() != null &amp;&amp; getStringEncoding().equals( storageMetadata.getStringEncoding() )</span>
<span class="pc bpc" id="L4126" title="1 of 4 branches missed.">          || getStringEncoding() == null &amp;&amp; storageMetadata.getStringEncoding() == null ) {</span>

          // However, perhaps the conversion mask changed since we read the
          // binary string?
          // The output can be different from the input. If the mask is
          // different, we need to do conversions.
          // Otherwise, we can just ignore it...
          //
<span class="fc bfc" id="L4134" title="All 2 branches covered.">          if ( isDate() ) {</span>
<span class="pc bpc" id="L4135" title="1 of 4 branches missed.">            if ( ( getConversionMask() != null &amp;&amp; getConversionMask().equals( storageMetadata.getConversionMask() ) )</span>
<span class="fc bfc" id="L4136" title="All 4 branches covered.">              || ( getConversionMask() == null &amp;&amp; storageMetadata.getConversionMask() == null ) ) {</span>
<span class="fc" id="L4137">              identicalFormat = true;</span>
            } else {
<span class="fc" id="L4139">              identicalFormat = false;</span>
            }
<span class="fc bfc" id="L4141" title="All 2 branches covered.">          } else if ( isNumeric() ) {</span>
            // Check the lengths first
            //
<span class="pc bpc" id="L4144" title="1 of 2 branches missed.">            if ( getLength() != storageMetadata.getLength() ) {</span>
<span class="fc" id="L4145">              identicalFormat = false;</span>
<span class="nc bnc" id="L4146" title="All 2 branches missed.">            } else if ( getPrecision() != storageMetadata.getPrecision() ) {</span>
<span class="nc" id="L4147">              identicalFormat = false;</span>
<span class="nc bnc" id="L4148" title="All 2 branches missed.">            } else if ( ( getConversionMask() != null</span>
<span class="nc bnc" id="L4149" title="All 4 branches missed.">              &amp;&amp; getConversionMask().equals( storageMetadata.getConversionMask() ) || ( getConversionMask() == null &amp;&amp; storageMetadata</span>
<span class="nc bnc" id="L4150" title="All 2 branches missed.">              .getConversionMask() == null ) ) ) {</span>
              // For the same reasons as above, if the conversion mask, the
              // decimal or the grouping symbol changes
              // we need to convert from the binary strings to the target data
              // type and then back to a string in the required format.
              //
<span class="nc bnc" id="L4156" title="All 4 branches missed.">              if ( ( getGroupingSymbol() != null &amp;&amp; getGroupingSymbol().equals( storageMetadata.getGroupingSymbol() ) )</span>
<span class="nc bnc" id="L4157" title="All 4 branches missed.">                || ( getConversionMask() == null &amp;&amp; storageMetadata.getConversionMask() == null ) ) {</span>
<span class="nc bnc" id="L4158" title="All 4 branches missed.">                if ( ( getDecimalFormat( false ) != null &amp;&amp; getDecimalFormat( false ).equals(</span>
<span class="nc" id="L4159">                  storageMetadata.getDecimalFormat( false ) ) )</span>
<span class="nc bnc" id="L4160" title="All 4 branches missed.">                  || ( getDecimalFormat( false ) == null &amp;&amp; storageMetadata.getDecimalFormat( false ) == null ) ) {</span>
<span class="nc" id="L4161">                  identicalFormat = true;</span>
                } else {
<span class="nc" id="L4163">                  identicalFormat = false;</span>
                }
              } else {
<span class="nc" id="L4166">                identicalFormat = false;</span>
              }
            } else {
<span class="nc" id="L4169">              identicalFormat = false;</span>
            }
          }
        }
      }
    }
<span class="fc" id="L4175">  }</span>

  /**
   * @return the trimType
   */
  @Override
  public int getTrimType() {
<span class="fc" id="L4182">    return trimType;</span>
  }

  /**
   * @param trimType the trimType to set
   */
  @Override
  public void setTrimType( int trimType ) {
<span class="fc" id="L4190">    this.trimType = trimType;</span>
<span class="fc" id="L4191">  }</span>

  public static final int getTrimTypeByCode( String tt ) {
<span class="fc bfc" id="L4194" title="All 2 branches covered.">    if ( tt == null ) {</span>
<span class="fc" id="L4195">      return 0;</span>
    }

<span class="fc bfc" id="L4198" title="All 2 branches covered.">    for ( int i = 0; i &lt; trimTypeCode.length; i++ ) {</span>
<span class="fc bfc" id="L4199" title="All 2 branches covered.">      if ( trimTypeCode[ i ].equalsIgnoreCase( tt ) ) {</span>
<span class="fc" id="L4200">        return i;</span>
      }
    }
<span class="fc" id="L4203">    return 0;</span>
  }

  public static final int getTrimTypeByDesc( String tt ) {
<span class="fc bfc" id="L4207" title="All 2 branches covered.">    if ( tt == null ) {</span>
<span class="fc" id="L4208">      return 0;</span>
    }

<span class="fc bfc" id="L4211" title="All 2 branches covered.">    for ( int i = 0; i &lt; trimTypeDesc.length; i++ ) {</span>
<span class="fc bfc" id="L4212" title="All 2 branches covered.">      if ( trimTypeDesc[ i ].equalsIgnoreCase( tt ) ) {</span>
<span class="fc" id="L4213">        return i;</span>
      }
    }

    // If this fails, try to match using the code.
<span class="fc" id="L4218">    return getTrimTypeByCode( tt );</span>
  }

  public static final String getTrimTypeCode( int i ) {
<span class="pc bpc" id="L4222" title="2 of 4 branches missed.">    if ( i &lt; 0 || i &gt;= trimTypeCode.length ) {</span>
<span class="nc" id="L4223">      return trimTypeCode[ 0 ];</span>
    }
<span class="fc" id="L4225">    return trimTypeCode[ i ];</span>
  }

  public static final String getTrimTypeDesc( int i ) {
<span class="fc bfc" id="L4229" title="All 4 branches covered.">    if ( i &lt; 0 || i &gt;= trimTypeDesc.length ) {</span>
<span class="fc" id="L4230">      return trimTypeDesc[ 0 ];</span>
    }
<span class="fc" id="L4232">    return trimTypeDesc[ i ];</span>
  }

  /**
   * @return the conversionMetadata
   */
  @Override
  public IValueMeta getConversionMetadata() {
<span class="nc" id="L4240">    return conversionMetadata;</span>
  }

  /**
   * @param conversionMetadata the conversionMetadata to set
   */
  @Override
  public void setConversionMetadata( IValueMeta conversionMetadata ) {
<span class="fc" id="L4248">    this.conversionMetadata = conversionMetadata;</span>
<span class="fc" id="L4249">  }</span>

  /**
   * @return true if the String encoding used (storage) is single byte encoded.
   */
  @Override
  public boolean isSingleByteEncoding() {
<span class="nc" id="L4256">    return singleByteEncoding;</span>
  }

  /**
   * @return the number of binary string to native data type conversions done with this object conversions
   */
  @Override
  public long getNumberOfBinaryStringConversions() {
<span class="nc" id="L4264">    return numberOfBinaryStringConversions;</span>
  }

  /**
   * @param numberOfBinaryStringConversions the number of binary string to native data type done with this object conversions to set
   */
  @Override
  public void setNumberOfBinaryStringConversions( long numberOfBinaryStringConversions ) {
<span class="nc" id="L4272">    this.numberOfBinaryStringConversions = numberOfBinaryStringConversions;</span>
<span class="nc" id="L4273">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#isAutoIncrement()
   */
  @Override
  public boolean isOriginalAutoIncrement() {
<span class="fc" id="L4282">    return originalAutoIncrement;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setAutoIncrement(boolean)
   */
  @Override
  public void setOriginalAutoIncrement( boolean originalAutoIncrement ) {
<span class="fc" id="L4292">    this.originalAutoIncrement = originalAutoIncrement;</span>
<span class="fc" id="L4293">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#getColumnType()
   */
  @Override
  public int getOriginalColumnType() {
<span class="fc" id="L4302">    return originalColumnType;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setColumnType(int)
   */
  @Override
  public void setOriginalColumnType( int originalColumnType ) {
<span class="fc" id="L4312">    this.originalColumnType = originalColumnType;</span>
<span class="fc" id="L4313">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#getColumnTypeName()
   */
  @Override
  public String getOriginalColumnTypeName() {
<span class="fc" id="L4322">    return originalColumnTypeName;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setColumnTypeName(java.lang.String)
   */
  @Override
  public void setOriginalColumnTypeName( String originalColumnTypeName ) {
<span class="fc" id="L4332">    this.originalColumnTypeName = originalColumnTypeName;</span>

<span class="fc" id="L4334">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#isNullable()
   */
  @Override
  public int isOriginalNullable() {
<span class="fc" id="L4343">    return originalNullable;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setNullable(int)
   */
  @Override
  public void setOriginalNullable( int originalNullable ) {
<span class="fc" id="L4353">    this.originalNullable = originalNullable;</span>

<span class="fc" id="L4355">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#getPrecision()
   */
  @Override
  public int getOriginalPrecision() {
<span class="fc" id="L4364">    return originalPrecision;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setPrecision(int)
   */
  @Override
  public void setOriginalPrecision( int originalPrecision ) {
<span class="fc" id="L4374">    this.originalPrecision = originalPrecision;</span>
<span class="fc" id="L4375">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#getScale()
   */
  @Override
  public int getOriginalScale() {
<span class="fc" id="L4384">    return originalScale;</span>
  }

  @Override
  public int getOriginalNullable() {
<span class="nc" id="L4389">    return originalNullable;</span>
  }

  @Override
  public boolean getOriginalSigned() {
<span class="nc" id="L4394">    return originalSigned;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setScale(int)
   */
  @Override
  public void setOriginalScale( int originalScale ) {
<span class="fc" id="L4404">    this.originalScale = originalScale;</span>

<span class="fc" id="L4406">  }</span>

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#isSigned()
   */
  @Override
  public boolean isOriginalSigned() {
<span class="fc" id="L4415">    return originalSigned;</span>
  }

  /*
   * Original JDBC RecordSetMetaData
   *
   * @see java.sql.ResultSetMetaData#setOriginalSigned(boolean)
   */
  @Override
  public void setOriginalSigned( boolean originalSigned ) {
<span class="fc" id="L4425">    this.originalSigned = originalSigned;</span>
<span class="fc" id="L4426">  }</span>

  /**
   * @return the bigNumberFormatting flag : true if BigNumbers of formatted as well
   */
  public boolean isBigNumberFormatting() {
<span class="nc" id="L4432">    return bigNumberFormatting;</span>
  }

  /**
   * @param bigNumberFormatting the bigNumberFormatting flag to set : true if BigNumbers of formatted as well
   */
  public void setBigNumberFormatting( boolean bigNumberFormatting ) {
<span class="fc" id="L4439">    this.bigNumberFormatting = bigNumberFormatting;</span>
<span class="fc" id="L4440">  }</span>

  /**
   * @return The available trim type codes (NOT localized, use for persistence)
   */
  public static String[] getTrimTypeCodes() {
<span class="nc" id="L4446">    return trimTypeCode;</span>
  }

  /**
   * @return The available trim type descriptions (localized)
   */
  public static String[] getTrimTypeDescriptions() {
<span class="nc" id="L4453">    return trimTypeDesc;</span>
  }

  @Override
  public boolean requiresRealClone() {
<span class="fc bfc" id="L4458" title="All 4 branches covered.">    return type == TYPE_BINARY || type == TYPE_SERIALIZABLE;</span>
  }

  /**
   * @return the lenientStringToNumber
   */
  @Override
  public boolean isLenientStringToNumber() {
<span class="fc" id="L4466">    return lenientStringToNumber;</span>
  }

  /**
   * @param lenientStringToNumber the lenientStringToNumber to set
   */
  @Override
  public void setLenientStringToNumber( boolean lenientStringToNumber ) {
<span class="fc" id="L4474">    this.lenientStringToNumber = lenientStringToNumber;</span>
<span class="fc" id="L4475">  }</span>

  /**
   * @return the date format time zone
   */
  @Override
  public TimeZone getDateFormatTimeZone() {
<span class="fc" id="L4482">    return dateFormatTimeZone;</span>
  }

  /**
   * @param dateFormatTimeZone the date format time zone to set
   */
  @Override
  public void setDateFormatTimeZone( TimeZone dateFormatTimeZone ) {
<span class="fc" id="L4490">    this.dateFormatTimeZone = dateFormatTimeZone;</span>
<span class="fc" id="L4491">    dateFormatChanged = true;</span>
<span class="fc" id="L4492">  }</span>

  @Override
  public boolean isIgnoreWhitespace() {
<span class="nc" id="L4496">    return ignoreWhitespace;</span>
  }

  @Override
  public void setIgnoreWhitespace( boolean ignoreWhitespace ) {
<span class="fc" id="L4501">    this.ignoreWhitespace = ignoreWhitespace;</span>
<span class="fc" id="L4502">  }</span>

  @SuppressWarnings( &quot;fallthrough&quot; )
  @Override
  public IValueMeta getValueFromSqlType(DatabaseMeta databaseMeta, String name, java.sql.ResultSetMetaData rm,
                                        int index, boolean ignoreLength, boolean lazyConversion ) throws HopDatabaseException {
    try {
<span class="fc" id="L4509">      int length = -1;</span>
<span class="fc" id="L4510">      int precision = -1;</span>
<span class="fc" id="L4511">      int valtype = IValueMeta.TYPE_NONE;</span>
<span class="fc" id="L4512">      boolean isClob = false;</span>

<span class="fc" id="L4514">      int type = rm.getColumnType( index );</span>
<span class="fc" id="L4515">      boolean signed = false;</span>
      try {
<span class="fc" id="L4517">        signed = rm.isSigned( index );</span>
<span class="nc" id="L4518">      } catch ( Exception ignored ) {</span>
        // This JDBC Driver doesn't support the isSigned method
        // nothing more we can do here by catch the exception.
<span class="fc" id="L4521">      }</span>
<span class="pc bpc" id="L4522" title="11 of 13 branches missed.">      switch ( type ) {</span>
        case java.sql.Types.CHAR:
        case java.sql.Types.VARCHAR:
        case java.sql.Types.NVARCHAR:
        case java.sql.Types.LONGVARCHAR: // Character Large Object
<span class="nc" id="L4527">          valtype = IValueMeta.TYPE_STRING;</span>
<span class="nc bnc" id="L4528" title="All 2 branches missed.">          if ( !ignoreLength ) {</span>
<span class="nc" id="L4529">            length = rm.getColumnDisplaySize( index );</span>
          }
          break;

        case java.sql.Types.CLOB:
        case java.sql.Types.NCLOB:
<span class="nc" id="L4535">          valtype = IValueMeta.TYPE_STRING;</span>
<span class="nc" id="L4536">          length = DatabaseMeta.CLOB_LENGTH;</span>
<span class="nc" id="L4537">          isClob = true;</span>
<span class="nc" id="L4538">          break;</span>

        case java.sql.Types.BIGINT:
          // verify Unsigned BIGINT overflow!
          //
<span class="nc bnc" id="L4543" title="All 2 branches missed.">          if ( signed ) {</span>
<span class="nc" id="L4544">            valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="nc" id="L4545">            precision = 0; // Max 9.223.372.036.854.775.807</span>
<span class="nc" id="L4546">            length = 15;</span>
          } else {
<span class="nc" id="L4548">            valtype = IValueMeta.TYPE_BIGNUMBER;</span>
<span class="nc" id="L4549">            precision = 0; // Max 18.446.744.073.709.551.615</span>
<span class="nc" id="L4550">            length = 16;</span>
          }
<span class="nc" id="L4552">          break;</span>

        case java.sql.Types.INTEGER:
<span class="nc" id="L4555">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="nc" id="L4556">          precision = 0; // Max 2.147.483.647</span>
<span class="nc" id="L4557">          length = 9;</span>
<span class="nc" id="L4558">          break;</span>

        case java.sql.Types.SMALLINT:
<span class="nc" id="L4561">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="nc" id="L4562">          precision = 0; // Max 32.767</span>
<span class="nc" id="L4563">          length = 4;</span>
<span class="nc" id="L4564">          break;</span>

        case java.sql.Types.TINYINT:
<span class="nc" id="L4567">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="nc" id="L4568">          precision = 0; // Max 127</span>
<span class="nc" id="L4569">          length = 2;</span>
<span class="nc" id="L4570">          break;</span>

        case java.sql.Types.DECIMAL:
        case java.sql.Types.DOUBLE:
        case java.sql.Types.FLOAT:
        case java.sql.Types.REAL:
        case java.sql.Types.NUMERIC:
<span class="fc" id="L4577">          valtype = IValueMeta.TYPE_NUMBER;</span>
<span class="fc" id="L4578">          length = rm.getPrecision( index );</span>
<span class="fc" id="L4579">          precision = rm.getScale( index );</span>
<span class="pc bpc" id="L4580" title="1 of 2 branches missed.">          if ( length &gt;= 126 ) {</span>
<span class="nc" id="L4581">            length = -1;</span>
          }
<span class="pc bpc" id="L4583" title="1 of 2 branches missed.">          if ( precision &gt;= 126 ) {</span>
<span class="nc" id="L4584">            precision = -1;</span>
          }

<span class="pc bpc" id="L4587" title="3 of 6 branches missed.">          if ( type == java.sql.Types.DOUBLE || type == java.sql.Types.FLOAT || type == java.sql.Types.REAL ) {</span>
<span class="nc bnc" id="L4588" title="All 2 branches missed.">            if ( precision == 0 ) {</span>
<span class="nc" id="L4589">              precision = -1; // precision is obviously incorrect if the type if</span>
              // Double/Float/Real
            }

            // If we're dealing with PostgreSQL and double precision types
<span class="nc bnc" id="L4594" title="All 8 branches missed.">            if ( databaseMeta.getIDatabase().isPostgresVariant() &amp;&amp; type == java.sql.Types.DOUBLE</span>
              &amp;&amp; precision &gt;= 16 &amp;&amp; length &gt;= 16 ) {
<span class="nc" id="L4596">              precision = -1;</span>
<span class="nc" id="L4597">              length = -1;</span>
            }

            // MySQL: max resolution is double precision floating point (double)
            // The (12,31) that is given back is not correct
<span class="nc bnc" id="L4602" title="All 2 branches missed.">            if ( databaseMeta.getIDatabase().isMySqlVariant() ) {</span>
<span class="nc bnc" id="L4603" title="All 2 branches missed.">              if ( precision &gt;= length ) {</span>
<span class="nc" id="L4604">                precision = -1;</span>
<span class="nc" id="L4605">                length = -1;</span>
              }
            }

            // if the length or precision needs a BIGNUMBER
<span class="nc bnc" id="L4610" title="All 4 branches missed.">            if ( length &gt; 15 || precision &gt; 15 ) {</span>
<span class="nc" id="L4611">              valtype = IValueMeta.TYPE_BIGNUMBER;</span>
            }
          } else {
<span class="pc bpc" id="L4614" title="1 of 2 branches missed.">            if ( precision == 0 ) {</span>
<span class="pc bpc" id="L4615" title="2 of 4 branches missed.">              if ( length &lt;= 18 &amp;&amp; length &gt; 0 ) { // Among others Oracle is affected</span>
                // here.
<span class="nc" id="L4617">                valtype = IValueMeta.TYPE_INTEGER; // Long can hold up to 18</span>
                // significant digits
<span class="pc bpc" id="L4619" title="1 of 2 branches missed.">              } else if ( length &gt; 18 ) {</span>
<span class="nc" id="L4620">                valtype = IValueMeta.TYPE_BIGNUMBER;</span>
              }
            } else { // we have a precision: keep NUMBER or change to BIGNUMBER?
<span class="nc bnc" id="L4623" title="All 4 branches missed.">              if ( length &gt; 15 || precision &gt; 15 ) {</span>
<span class="nc" id="L4624">                valtype = IValueMeta.TYPE_BIGNUMBER;</span>
              }
            }
          }

<span class="pc bpc" id="L4629" title="1 of 2 branches missed.">          if ( databaseMeta.getIDatabase().isPostgresVariant() ) {</span>
            // undefined size =&gt; arbitrary precision
<span class="nc bnc" id="L4631" title="All 6 branches missed.">            if ( type == java.sql.Types.NUMERIC &amp;&amp; length == 0 &amp;&amp; precision == 0 ) {</span>
<span class="nc" id="L4632">              valtype = IValueMeta.TYPE_BIGNUMBER;</span>
<span class="nc" id="L4633">              length = -1;</span>
<span class="nc" id="L4634">              precision = -1;</span>
            }
          }

<span class="pc bpc" id="L4638" title="1 of 2 branches missed.">          if ( databaseMeta.getIDatabase().isOracleVariant() ) {</span>
<span class="nc bnc" id="L4639" title="All 4 branches missed.">            if ( precision == 0 &amp;&amp; length == 38 ) {</span>
<span class="nc bnc" id="L4640" title="All 2 branches missed.">              valtype = databaseMeta.getIDatabase().isStrictBigNumberInterpretation() ? TYPE_BIGNUMBER : TYPE_INTEGER;</span>
            }
<span class="nc bnc" id="L4642" title="All 4 branches missed.">            if ( precision &lt;= 0 &amp;&amp; length &lt;= 0 ) {</span>
              // undefined size: BIGNUMBER,
              // precision on Oracle can be 38, too
              // big for a Number type
<span class="nc" id="L4646">              valtype = IValueMeta.TYPE_BIGNUMBER;</span>
<span class="nc" id="L4647">              length = -1;</span>
<span class="nc" id="L4648">              precision = -1;</span>
            }
          }

          break;

        case java.sql.Types.TIMESTAMP:
<span class="nc bnc" id="L4655" title="All 2 branches missed.">          if ( databaseMeta.supportsTimestampDataType() ) {</span>
<span class="nc" id="L4656">            valtype = IValueMeta.TYPE_TIMESTAMP;</span>
<span class="nc" id="L4657">            length = rm.getScale( index );</span>
          }
          break;

        case java.sql.Types.DATE:
<span class="nc bnc" id="L4662" title="All 2 branches missed.">          if ( databaseMeta.getIDatabase().isTeradataVariant() ) {</span>
<span class="nc" id="L4663">            precision = 1;</span>
          }
        case java.sql.Types.TIME:
<span class="nc" id="L4666">          valtype = IValueMeta.TYPE_DATE;</span>
          //
<span class="nc bnc" id="L4668" title="All 2 branches missed.">          if ( databaseMeta.getIDatabase().isMySqlVariant() ) {</span>
<span class="nc" id="L4669">            String property = databaseMeta.getConnectionProperties().getProperty( &quot;yearIsDateType&quot; );</span>
<span class="nc bnc" id="L4670" title="All 4 branches missed.">            if ( property != null &amp;&amp; property.equalsIgnoreCase( &quot;false&quot; )</span>
<span class="nc bnc" id="L4671" title="All 2 branches missed.">              &amp;&amp; rm.getColumnTypeName( index ).equalsIgnoreCase( &quot;YEAR&quot; ) ) {</span>
<span class="nc" id="L4672">              valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="nc" id="L4673">              precision = 0;</span>
<span class="nc" id="L4674">              length = 4;</span>
<span class="nc" id="L4675">              break;</span>
            }
<span class="nc" id="L4677">          }</span>
          break;

        case java.sql.Types.BOOLEAN:
        case java.sql.Types.BIT:
<span class="nc" id="L4682">          valtype = IValueMeta.TYPE_BOOLEAN;</span>
<span class="nc" id="L4683">          break;</span>

        case java.sql.Types.BINARY:
        case java.sql.Types.BLOB:
        case java.sql.Types.VARBINARY:
        case java.sql.Types.LONGVARBINARY:
<span class="nc" id="L4689">          valtype = IValueMeta.TYPE_BINARY;</span>

<span class="nc bnc" id="L4691" title="All 2 branches missed.">          if ( databaseMeta.isDisplaySizeTwiceThePrecision()</span>
<span class="nc bnc" id="L4692" title="All 2 branches missed.">            &amp;&amp; ( 2 * rm.getPrecision( index ) ) == rm.getColumnDisplaySize( index ) ) {</span>
            // set the length for &quot;CHAR(X) FOR BIT DATA&quot;
<span class="nc" id="L4694">            length = rm.getPrecision( index );</span>
<span class="nc bnc" id="L4695" title="All 6 branches missed.">          } else if ( ( databaseMeta.getIDatabase().isOracleVariant() )</span>
            &amp;&amp; ( type == java.sql.Types.VARBINARY || type == java.sql.Types.LONGVARBINARY ) ) {
            // set the length for Oracle &quot;RAW&quot; or &quot;LONGRAW&quot; data types
<span class="nc" id="L4698">            valtype = IValueMeta.TYPE_STRING;</span>
<span class="nc" id="L4699">            length = rm.getColumnDisplaySize( index );</span>
<span class="nc bnc" id="L4700" title="All 6 branches missed.">          } else if ( databaseMeta.isMySqlVariant()</span>
            &amp;&amp; ( type == java.sql.Types.VARBINARY || type == java.sql.Types.LONGVARBINARY ) ) {
            // PDI-6677 - don't call 'length = rm.getColumnDisplaySize(index);'
<span class="nc" id="L4703">            length = -1; // keep the length to -1, e.g. for string functions (e.g.</span>
            // CONCAT see PDI-4812)
<span class="nc bnc" id="L4705" title="All 2 branches missed.">          } else if ( databaseMeta.getIDatabase().isSqliteVariant() ) {</span>
<span class="nc" id="L4706">            valtype = IValueMeta.TYPE_STRING;</span>
          } else {
<span class="nc" id="L4708">            length = -1;</span>
          }
<span class="nc" id="L4710">          precision = -1;</span>
<span class="nc" id="L4711">          break;</span>

        default:
<span class="fc" id="L4714">          valtype = IValueMeta.TYPE_STRING;</span>
<span class="fc" id="L4715">          precision = rm.getScale( index );</span>
          break;
      }

<span class="fc" id="L4719">      IValueMeta v = ValueMetaFactory.createValueMeta( name, valtype );</span>
<span class="fc" id="L4720">      v.setLength( length );</span>
<span class="fc" id="L4721">      v.setPrecision( precision );</span>
<span class="fc" id="L4722">      v.setLargeTextField( isClob );</span>

<span class="fc" id="L4724">      getOriginalColumnMetadata( v, rm, index, ignoreLength );</span>

      // See if we need to enable lazy conversion...
      //
<span class="pc bpc" id="L4728" title="3 of 4 branches missed.">      if ( lazyConversion &amp;&amp; valtype == IValueMeta.TYPE_STRING ) {</span>
<span class="nc" id="L4729">        v.setStorageType( IValueMeta.STORAGE_TYPE_BINARY_STRING );</span>
        // TODO set some encoding to go with this.

        // Also set the storage metadata. a copy of the parent, set to String too.
        //
        try {
<span class="nc" id="L4735">          IValueMeta storageMetaData = ValueMetaFactory.cloneValueMeta( v, IValueMeta.TYPE_STRING );</span>
<span class="nc" id="L4736">          storageMetaData.setStorageType( IValueMeta.STORAGE_TYPE_NORMAL );</span>
<span class="nc" id="L4737">          v.setStorageMetadata( storageMetaData );</span>
<span class="nc" id="L4738">        } catch ( Exception e ) {</span>
<span class="nc" id="L4739">          throw new SQLException( e );</span>
<span class="nc" id="L4740">        }</span>
      }

<span class="fc" id="L4743">      IValueMeta newV = null;</span>
      try {
<span class="fc" id="L4745">        newV = databaseMeta.getIDatabase().customizeValueFromSqlType( v, rm, index );</span>
<span class="nc" id="L4746">      } catch ( SQLException e ) {</span>
<span class="nc" id="L4747">        throw new SQLException( e );</span>
<span class="fc" id="L4748">      }</span>
<span class="pc bpc" id="L4749" title="1 of 2 branches missed.">      return newV == null ? v : newV;</span>
<span class="nc" id="L4750">    } catch ( Exception e ) {</span>
<span class="nc" id="L4751">      throw new HopDatabaseException( &quot;Error determining value metadata from SQL resultset metadata&quot;, e );</span>
    }
  }

  protected void getOriginalColumnMetadata( IValueMeta v, ResultSetMetaData rm, int index, boolean ignoreLength )
    throws SQLException {
    // Grab the comment as a description to the field as well.
<span class="fc" id="L4758">    String comments = rm.getColumnLabel( index );</span>
<span class="fc" id="L4759">    v.setComments( comments );</span>

    // get &amp; store more result set meta data for later use
<span class="fc" id="L4762">    int originalColumnType = rm.getColumnType( index );</span>
<span class="fc" id="L4763">    v.setOriginalColumnType( originalColumnType );</span>

<span class="fc" id="L4765">    String originalColumnTypeName = rm.getColumnTypeName( index );</span>
<span class="fc" id="L4766">    v.setOriginalColumnTypeName( originalColumnTypeName );</span>

<span class="fc" id="L4768">    int originalPrecision = -1;</span>
<span class="pc bpc" id="L4769" title="1 of 2 branches missed.">    if ( !ignoreLength ) {</span>
      // Throws exception on MySQL
<span class="fc" id="L4771">      originalPrecision = rm.getPrecision( index );</span>
    }
<span class="fc" id="L4773">    v.setOriginalPrecision( originalPrecision );</span>

<span class="fc" id="L4775">    int originalScale = rm.getScale( index );</span>
<span class="fc" id="L4776">    v.setOriginalScale( originalScale );</span>

    // DISABLED FOR PERFORMANCE REASONS : PDI-1788
    //
    // boolean originalAutoIncrement=rm.isAutoIncrement(index); DISABLED FOR
    // PERFORMANCE REASONS : PDI-1788
    // v.setOriginalAutoIncrement(originalAutoIncrement);

    // int originalNullable=rm.isNullable(index); DISABLED FOR PERFORMANCE
    // REASONS : PDI-1788
    // v.setOriginalNullable(originalNullable);
    //

<span class="fc" id="L4789">    boolean originalSigned = false;</span>
    try {
<span class="fc" id="L4791">      originalSigned = rm.isSigned( index );</span>
<span class="nc" id="L4792">    } catch ( Exception ignored ) {</span>
      // This JDBC Driver doesn't support the isSigned method.
      // Nothing more we can do here.
<span class="fc" id="L4795">    }</span>
<span class="fc" id="L4796">    v.setOriginalSigned( originalSigned );</span>
<span class="fc" id="L4797">  }</span>

  @Override
  public IValueMeta getMetadataPreview( DatabaseMeta databaseMeta, ResultSet rs )
    throws HopDatabaseException {

    try {
      // Get some info out of the resultset
<span class="fc" id="L4805">      final String name = rs.getString( &quot;COLUMN_NAME&quot; );</span>
<span class="fc" id="L4806">      int originalColumnType = rs.getInt( &quot;DATA_TYPE&quot; );</span>
<span class="fc" id="L4807">      Object dg = rs.getObject( &quot;DECIMAL_DIGITS&quot; );</span>
<span class="fc bfc" id="L4808" title="All 2 branches covered.">      int originalScale = dg == null ? 0 : rs.getInt( &quot;DECIMAL_DIGITS&quot; );</span>
<span class="fc" id="L4809">      int originalPrecision = rs.getInt( &quot;COLUMN_SIZE&quot; );</span>
<span class="fc" id="L4810">      int originalColumnDisplaySize = originalPrecision;</span>
<span class="fc" id="L4811">      String originalColumnTypeName = rs.getString( &quot;TYPE_NAME&quot; );</span>
<span class="fc" id="L4812">      String originalColumnLabel = rs.getString( &quot;REMARKS&quot; );</span>
<span class="fc" id="L4813">      int length = -1;</span>
<span class="fc" id="L4814">      int precision = -1;</span>
<span class="fc" id="L4815">      int valtype = IValueMeta.TYPE_NONE;</span>
<span class="fc" id="L4816">      boolean isClob = false;</span>

<span class="pc bpc" id="L4818" title="3 of 13 branches missed.">      switch ( originalColumnType ) {</span>
        case java.sql.Types.CHAR:
        case java.sql.Types.VARCHAR:
        case java.sql.Types.NVARCHAR:
        case java.sql.Types.LONGVARCHAR: // Character Large Object
<span class="fc" id="L4823">          valtype = IValueMeta.TYPE_STRING;</span>
<span class="fc" id="L4824">          length = originalColumnDisplaySize;</span>
<span class="fc" id="L4825">          break;</span>

        case java.sql.Types.CLOB:
        case java.sql.Types.NCLOB:
<span class="fc" id="L4829">          valtype = IValueMeta.TYPE_STRING;</span>
<span class="fc" id="L4830">          length = DatabaseMeta.CLOB_LENGTH;</span>
<span class="fc" id="L4831">          isClob = true;</span>
<span class="fc" id="L4832">          break;</span>

        case java.sql.Types.BIGINT:
          // SQL BigInt is equivalent to a Java Long
          // And a Java Long is equivalent to a PDI Integer.
<span class="fc" id="L4837">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="fc" id="L4838">          precision = 0; // Max 9.223.372.036.854.775.807</span>
<span class="fc" id="L4839">          length = 15;</span>
<span class="fc" id="L4840">          break;</span>

        case java.sql.Types.INTEGER:
<span class="fc" id="L4843">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="fc" id="L4844">          precision = 0; // Max 2.147.483.647</span>
<span class="fc" id="L4845">          length = 9;</span>
<span class="fc" id="L4846">          break;</span>

        case java.sql.Types.SMALLINT:
<span class="fc" id="L4849">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="fc" id="L4850">          precision = 0; // Max 32.767</span>
<span class="fc" id="L4851">          length = 4;</span>
<span class="fc" id="L4852">          break;</span>

        case java.sql.Types.TINYINT:
<span class="fc" id="L4855">          valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="fc" id="L4856">          precision = 0; // Max 127</span>
<span class="fc" id="L4857">          length = 2;</span>
<span class="fc" id="L4858">          break;</span>

        case java.sql.Types.DECIMAL:
        case java.sql.Types.DOUBLE:
        case java.sql.Types.FLOAT:
        case java.sql.Types.REAL:
        case java.sql.Types.NUMERIC:
<span class="fc" id="L4865">          valtype = IValueMeta.TYPE_NUMBER;</span>
<span class="fc" id="L4866">          length = originalPrecision;</span>
<span class="fc" id="L4867">          precision = originalScale;</span>
<span class="pc bpc" id="L4868" title="1 of 2 branches missed.">          if ( length &gt;= 126 ) {</span>
<span class="nc" id="L4869">            length = -1;</span>
          }
<span class="pc bpc" id="L4871" title="1 of 2 branches missed.">          if ( precision &gt;= 126 ) {</span>
<span class="nc" id="L4872">            precision = -1;</span>
          }

<span class="fc bfc" id="L4875" title="All 6 branches covered.">          if ( originalColumnType == java.sql.Types.DOUBLE || originalColumnType == java.sql.Types.FLOAT || originalColumnType == java.sql.Types.REAL ) {</span>
<span class="fc bfc" id="L4876" title="All 2 branches covered.">            if ( precision == 0 ) {</span>
<span class="fc" id="L4877">              precision = -1; // precision is obviously incorrect if the type if</span>
              // Double/Float/Real
            }

            // If we're dealing with PostgreSQL and double precision types
<span class="pc bpc" id="L4882" title="7 of 8 branches missed.">            if ( databaseMeta.getIDatabase().isPostgresVariant() &amp;&amp; originalColumnType == java.sql.Types.DOUBLE</span>
              &amp;&amp; precision &gt;= 16 &amp;&amp; length &gt;= 16 ) {
<span class="nc" id="L4884">              precision = -1;</span>
<span class="nc" id="L4885">              length = -1;</span>
            }

            // MySQL: max resolution is double precision floating point (double)
            // The (12,31) that is given back is not correct
<span class="pc bpc" id="L4890" title="1 of 2 branches missed.">            if ( databaseMeta.isMySqlVariant() ) {</span>
<span class="nc bnc" id="L4891" title="All 2 branches missed.">              if ( precision &gt;= length ) {</span>
<span class="nc" id="L4892">                precision = -1;</span>
<span class="nc" id="L4893">                length = -1;</span>
                // MySQL: Double value is giving length of 22,
                // that exceeds the maximum length.
<span class="nc bnc" id="L4896" title="All 4 branches missed.">              } else if ( originalColumnType == java.sql.Types.DOUBLE &amp;&amp; length &gt; 15 ) {</span>
<span class="nc" id="L4897">                length = -1;</span>
              }
            }

            // if the length or precision needs a BIGNUMBER
<span class="pc bpc" id="L4902" title="1 of 4 branches missed.">            if ( length &gt; 15 || precision &gt; 15 ) {</span>
<span class="fc" id="L4903">              valtype = IValueMeta.TYPE_BIGNUMBER;</span>
            }
          } else {
<span class="fc bfc" id="L4906" title="All 2 branches covered.">            if ( precision == 0 ) {</span>
<span class="pc bpc" id="L4907" title="1 of 4 branches missed.">              if ( length &lt;= 18 &amp;&amp; length &gt; 0 ) { // Among others Oracle is affected</span>
                // here.
<span class="fc" id="L4909">                valtype = IValueMeta.TYPE_INTEGER; // Long can hold up to 18</span>
                // significant digits
<span class="pc bpc" id="L4911" title="1 of 2 branches missed.">              } else if ( length &gt; 18 ) {</span>
<span class="fc" id="L4912">                valtype = IValueMeta.TYPE_BIGNUMBER;</span>
              }
            } else { // we have a precision: keep NUMBER or change to BIGNUMBER?
<span class="pc bpc" id="L4915" title="3 of 4 branches missed.">              if ( length &gt; 15 || precision &gt; 15 ) {</span>
<span class="fc" id="L4916">                valtype = IValueMeta.TYPE_BIGNUMBER;</span>
              }
            }
          }

<span class="pc bpc" id="L4921" title="1 of 2 branches missed.">          if ( databaseMeta.getIDatabase().isPostgresVariant() ) {</span>
            // undefined size =&gt; arbitrary precision
<span class="nc bnc" id="L4923" title="All 6 branches missed.">            if ( originalColumnType == java.sql.Types.NUMERIC &amp;&amp; length == 0 &amp;&amp; precision == 0 ) {</span>
<span class="nc" id="L4924">              valtype = IValueMeta.TYPE_BIGNUMBER;</span>
<span class="nc" id="L4925">              length = -1;</span>
<span class="nc" id="L4926">              precision = -1;</span>
            }
          }

<span class="pc bpc" id="L4930" title="1 of 2 branches missed.">          if ( databaseMeta.getIDatabase().isOracleVariant() ) {</span>
<span class="nc bnc" id="L4931" title="All 4 branches missed.">            if ( precision == 0 &amp;&amp; length == 38 ) {</span>
<span class="nc bnc" id="L4932" title="All 2 branches missed.">              valtype = databaseMeta.getIDatabase().isStrictBigNumberInterpretation() ? TYPE_BIGNUMBER : TYPE_INTEGER;</span>
            }
<span class="nc bnc" id="L4934" title="All 4 branches missed.">            if ( precision &lt;= 0 &amp;&amp; length &lt;= 0 ) {</span>
              // undefined size: BIGNUMBER,
              // precision on Oracle can be 38, too
              // big for a Number type
<span class="nc" id="L4938">              valtype = IValueMeta.TYPE_BIGNUMBER;</span>
<span class="nc" id="L4939">              length = -1;</span>
<span class="nc" id="L4940">              precision = -1;</span>
            }
          }

          break;

        case java.sql.Types.TIMESTAMP:
<span class="pc bpc" id="L4947" title="1 of 2 branches missed.">          if ( databaseMeta.supportsTimestampDataType() ) {</span>
<span class="nc" id="L4948">            valtype = IValueMeta.TYPE_TIMESTAMP;</span>
<span class="nc" id="L4949">            length = originalScale;</span>
          }
          break;

        case java.sql.Types.DATE:
<span class="nc bnc" id="L4954" title="All 2 branches missed.">          if ( databaseMeta.getIDatabase().isTeradataVariant() ) {</span>
<span class="nc" id="L4955">            precision = 1;</span>
          }
        case java.sql.Types.TIME:
<span class="fc" id="L4958">          valtype = IValueMeta.TYPE_DATE;</span>
          //
<span class="pc bpc" id="L4960" title="1 of 2 branches missed.">          if ( databaseMeta.isMySqlVariant() ) {</span>
<span class="nc" id="L4961">            String property = databaseMeta.getConnectionProperties().getProperty( &quot;yearIsDateType&quot; );</span>
<span class="nc bnc" id="L4962" title="All 4 branches missed.">            if ( property != null &amp;&amp; property.equalsIgnoreCase( &quot;false&quot; )</span>
<span class="nc bnc" id="L4963" title="All 2 branches missed.">              &amp;&amp; &quot;YEAR&quot;.equalsIgnoreCase( originalColumnTypeName ) ) {</span>
<span class="nc" id="L4964">              valtype = IValueMeta.TYPE_INTEGER;</span>
<span class="nc" id="L4965">              precision = 0;</span>
<span class="nc" id="L4966">              length = 4;</span>
<span class="nc" id="L4967">              break;</span>
            }
<span class="nc" id="L4969">          }</span>
          break;

        case java.sql.Types.BOOLEAN:
        case java.sql.Types.BIT:
<span class="fc" id="L4974">          valtype = IValueMeta.TYPE_BOOLEAN;</span>
<span class="fc" id="L4975">          break;</span>

        case java.sql.Types.BINARY:
        case java.sql.Types.BLOB:
        case java.sql.Types.VARBINARY:
        case java.sql.Types.LONGVARBINARY:
<span class="nc" id="L4981">          valtype = IValueMeta.TYPE_BINARY;</span>

          
<span class="nc" id="L4984">          IDatabase db = databaseMeta.getIDatabase();</span>
<span class="nc" id="L4985">          boolean isOracle= db.isOracleVariant();</span>
          
<span class="nc bnc" id="L4987" title="All 4 branches missed.">          if ( databaseMeta.isDisplaySizeTwiceThePrecision()</span>
            &amp;&amp; ( 2 * originalPrecision ) == originalColumnDisplaySize ) {
            // set the length for &quot;CHAR(X) FOR BIT DATA&quot;
<span class="nc" id="L4990">            length = originalPrecision;</span>
<span class="nc bnc" id="L4991" title="All 6 branches missed.">          } else if ( ( databaseMeta.getIDatabase().isOracleVariant() )</span>
            &amp;&amp; ( originalColumnType == java.sql.Types.VARBINARY || originalColumnType == java.sql.Types.LONGVARBINARY ) ) {
            // set the length for Oracle &quot;RAW&quot; or &quot;LONGRAW&quot; data types
<span class="nc" id="L4994">            valtype = IValueMeta.TYPE_STRING;</span>
<span class="nc" id="L4995">            length = originalColumnDisplaySize;</span>
<span class="nc bnc" id="L4996" title="All 6 branches missed.">          } else if ( databaseMeta.isMySqlVariant()</span>
            &amp;&amp; ( originalColumnType == java.sql.Types.VARBINARY || originalColumnType == java.sql.Types.LONGVARBINARY ) ) {
            // PDI-6677 - don't call 'length = rm.getColumnDisplaySize(index);'
<span class="nc" id="L4999">            length = -1; // keep the length to -1, e.g. for string functions (e.g.</span>
            // CONCAT see PDI-4812)
<span class="nc bnc" id="L5001" title="All 2 branches missed.">          } else if ( databaseMeta.getIDatabase().isSqliteVariant() ) {</span>
<span class="nc" id="L5002">            valtype = IValueMeta.TYPE_STRING;</span>
          } else {
<span class="nc" id="L5004">            length = -1;</span>
          }
<span class="nc" id="L5006">          precision = -1;</span>
<span class="nc" id="L5007">          break;</span>

        default:
<span class="nc" id="L5010">          valtype = IValueMeta.TYPE_STRING;</span>
<span class="nc" id="L5011">          precision = originalScale;</span>
          break;
      }

<span class="fc" id="L5015">      IValueMeta v = ValueMetaFactory.createValueMeta( name, valtype );</span>
<span class="fc" id="L5016">      v.setLength( length );</span>
<span class="fc" id="L5017">      v.setPrecision( precision );</span>
<span class="fc" id="L5018">      v.setLargeTextField( isClob );</span>

      // Grab the comment as a description to the field as well.
<span class="fc" id="L5021">      v.setComments( originalColumnLabel );</span>
<span class="fc" id="L5022">      v.setOriginalColumnType( originalColumnType );</span>
<span class="fc" id="L5023">      v.setOriginalColumnTypeName( originalColumnTypeName );</span>
<span class="fc" id="L5024">      v.setOriginalPrecision( originalPrecision );</span>
<span class="fc" id="L5025">      v.setOriginalScale( originalScale );</span>
<span class="fc" id="L5026">      v.setOriginalSigned( originalSigned );</span>

<span class="fc" id="L5028">      return v;</span>
<span class="nc" id="L5029">    } catch ( Exception e ) {</span>
<span class="nc" id="L5030">      throw new HopDatabaseException( &quot;Error determining value metadata from SQL resultset metadata&quot;, e );</span>
    }
  }

  /**
   * Get a value from a result set column based on the current value metadata
   *
   * @param iDatabase the database metadata to use
   * @param resultSet         The JDBC result set to read from
   * @param index             The column index (1-based)
   * @return The Hop native data type based on the value metadata
   * @throws HopDatabaseException in case something goes wrong.
   */
  @Override
  public Object getValueFromResultSet( IDatabase iDatabase, ResultSet resultSet, int index )
    throws HopDatabaseException {
    try {
<span class="nc" id="L5047">      Object data = null;</span>

<span class="nc bnc" id="L5049" title="All 8 branches missed.">      switch ( getType() ) {</span>
        case IValueMeta.TYPE_BOOLEAN:
<span class="nc" id="L5051">          data = Boolean.valueOf( resultSet.getBoolean( index + 1 ) );</span>
<span class="nc" id="L5052">          break;</span>
        case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L5054">          data = new Double( resultSet.getDouble( index + 1 ) );</span>
<span class="nc" id="L5055">          break;</span>
        case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L5057">          data = resultSet.getBigDecimal( index + 1 );</span>
<span class="nc" id="L5058">          break;</span>
        case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L5060">          data = Long.valueOf( resultSet.getLong( index + 1 ) );</span>
<span class="nc" id="L5061">          break;</span>
        case IValueMeta.TYPE_STRING:
<span class="nc bnc" id="L5063" title="All 2 branches missed.">          if ( isStorageBinaryString() ) {</span>
<span class="nc" id="L5064">            data = resultSet.getBytes( index + 1 );</span>
          } else {
<span class="nc" id="L5066">            data = resultSet.getString( index + 1 );</span>
          }
<span class="nc" id="L5068">          break;</span>
        case IValueMeta.TYPE_BINARY:
<span class="nc bnc" id="L5070" title="All 2 branches missed.">          if ( iDatabase.supportsGetBlob() ) {</span>
<span class="nc" id="L5071">            Blob blob = resultSet.getBlob( index + 1 );</span>
<span class="nc bnc" id="L5072" title="All 2 branches missed.">            if ( blob != null ) {</span>
<span class="nc" id="L5073">              data = blob.getBytes( 1L, (int) blob.length() );</span>
            } else {
<span class="nc" id="L5075">              data = null;</span>
            }
<span class="nc" id="L5077">          } else {</span>
<span class="nc" id="L5078">            data = resultSet.getBytes( index + 1 );</span>
          }
<span class="nc" id="L5080">          break;</span>

        case IValueMeta.TYPE_DATE:
<span class="nc bnc" id="L5083" title="All 4 branches missed.">          if ( getPrecision() != 1 &amp;&amp; iDatabase.supportsTimeStampToDateConversion() ) {</span>
<span class="nc" id="L5084">            data = resultSet.getTimestamp( index + 1 );</span>
<span class="nc" id="L5085">            break; // Timestamp extends java.util.Date</span>
<span class="nc bnc" id="L5086" title="All 2 branches missed.">          } else if ( iDatabase.isNetezzaVariant() ) {</span>
            // PDI-10877 workaround for IBM netezza jdbc 'special' implementation
<span class="nc" id="L5088">            data = getNetezzaDateValueWorkaround( iDatabase, resultSet, index + 1 );</span>
<span class="nc" id="L5089">            break;</span>
          } else {
<span class="nc" id="L5091">            data = resultSet.getDate( index + 1 );</span>
<span class="nc" id="L5092">            break;</span>
          }
        default:
          break;
      }
<span class="nc bnc" id="L5097" title="All 2 branches missed.">      if ( resultSet.wasNull() ) {</span>
<span class="nc" id="L5098">        data = null;</span>
      }
<span class="nc" id="L5100">      return data;</span>
<span class="nc" id="L5101">    } catch ( SQLException e ) {</span>
<span class="nc" id="L5102">      throw new HopDatabaseException( &quot;Unable to get value '&quot; + toStringMeta() + &quot;' from database resultset, index &quot;</span>
        + index, e );
    }

  }

  private Object getNetezzaDateValueWorkaround( IDatabase iDatabase, ResultSet resultSet, int index )
    throws SQLException, HopDatabaseException {
<span class="nc" id="L5110">    Object data = null;</span>
<span class="nc" id="L5111">    int type = resultSet.getMetaData().getColumnType( index );</span>
<span class="nc bnc" id="L5112" title="All 2 branches missed.">    switch ( type ) {</span>
      case Types.TIME: {
<span class="nc" id="L5114">        data = resultSet.getTime( index );</span>
<span class="nc" id="L5115">        break;</span>
      }
      default: {
<span class="nc" id="L5118">        data = resultSet.getDate( index );</span>
      }
    }
<span class="nc" id="L5121">    return data;</span>
  }

  @Override
  public void setPreparedStatementValue( DatabaseMeta databaseMeta, PreparedStatement preparedStatement, int index,
                                         Object data ) throws HopDatabaseException {
    try {
<span class="pc bpc" id="L5128" title="6 of 8 branches missed.">      switch ( getType() ) {</span>
        case IValueMeta.TYPE_NUMBER:
<span class="nc bnc" id="L5130" title="All 2 branches missed.">          if ( !isNull( data ) ) {</span>
<span class="nc" id="L5131">            double num = getNumber( data ).doubleValue();</span>
<span class="nc bnc" id="L5132" title="All 4 branches missed.">            if ( databaseMeta.supportsFloatRoundingOnUpdate() &amp;&amp; getPrecision() &gt;= 0 ) {</span>
<span class="nc" id="L5133">              num = Const.round( num, getPrecision() );</span>
            }
<span class="nc" id="L5135">            preparedStatement.setDouble( index, num );</span>
<span class="nc" id="L5136">          } else {</span>
<span class="nc" id="L5137">            preparedStatement.setNull( index, java.sql.Types.DOUBLE );</span>
          }
<span class="nc" id="L5139">          break;</span>
        case IValueMeta.TYPE_INTEGER:
<span class="nc bnc" id="L5141" title="All 2 branches missed.">          if ( !isNull( data ) ) {</span>
<span class="nc bnc" id="L5142" title="All 2 branches missed.">            if ( databaseMeta.supportsSetLong() ) {</span>
<span class="nc" id="L5143">              preparedStatement.setLong( index, getInteger( data ).longValue() );</span>
            } else {
<span class="nc" id="L5145">              double d = getNumber( data ).doubleValue();</span>
<span class="nc bnc" id="L5146" title="All 4 branches missed.">              if ( databaseMeta.supportsFloatRoundingOnUpdate() &amp;&amp; getPrecision() &gt;= 0 ) {</span>
<span class="nc" id="L5147">                preparedStatement.setDouble( index, d );</span>
              } else {
<span class="nc" id="L5149">                preparedStatement.setDouble( index, Const.round( d, getPrecision() ) );</span>
              }
<span class="nc" id="L5151">            }</span>
          } else {
<span class="nc" id="L5153">            preparedStatement.setNull( index, java.sql.Types.INTEGER );</span>
          }
<span class="nc" id="L5155">          break;</span>
        case IValueMeta.TYPE_STRING:
<span class="pc bpc" id="L5157" title="1 of 2 branches missed.">          if ( !isNull( data ) ) {</span>
<span class="pc bpc" id="L5158" title="1 of 2 branches missed.">            if ( getLength() == DatabaseMeta.CLOB_LENGTH ) {</span>
<span class="nc" id="L5159">              setLength( databaseMeta.getMaxTextFieldLength() );</span>
            }

<span class="pc bpc" id="L5162" title="1 of 2 branches missed.">            if ( getLength() &lt;= databaseMeta.getMaxTextFieldLength() ) {</span>
<span class="fc" id="L5163">              preparedStatement.setString( index, getString( data ) );</span>
            } else {
<span class="nc" id="L5165">              String string = getString( data );</span>

<span class="nc" id="L5167">              int maxlen = databaseMeta.getMaxTextFieldLength();</span>
<span class="nc" id="L5168">              int len = string.length();</span>

              // Take the last maxlen characters of the string...
<span class="nc" id="L5171">              int begin = Math.max( len - maxlen, 0 );</span>
<span class="nc bnc" id="L5172" title="All 2 branches missed.">              if ( begin &gt; 0 ) {</span>
                // Truncate if logging result if it exceeds database maximum string field length
<span class="nc" id="L5174">                log.logMinimal( String.format( &quot;Truncating %d symbols of original message in '%s' field&quot;, begin, getName() ) );</span>
<span class="nc" id="L5175">                string = string.substring( begin );</span>
              }

<span class="nc bnc" id="L5178" title="All 2 branches missed.">              if ( databaseMeta.supportsSetCharacterStream() ) {</span>
<span class="nc" id="L5179">                preparedStatement.setCharacterStream( index, new StringReader( string ), string.length() );</span>
              } else {
<span class="nc" id="L5181">                preparedStatement.setString( index, string );</span>
              }
<span class="nc" id="L5183">            }</span>
          } else {
<span class="nc" id="L5185">            preparedStatement.setNull( index, java.sql.Types.VARCHAR );</span>
          }
<span class="nc" id="L5187">          break;</span>
        case IValueMeta.TYPE_DATE:
<span class="pc bpc" id="L5189" title="1 of 2 branches missed.">          if ( !isNull( data ) ) {</span>
            // Environment variable to disable timezone setting for the database updates
            // When it is set, timezone will not be taken into account and the value will be converted
            // into the local java timezone
<span class="pc bpc" id="L5193" title="1 of 4 branches missed.">            if ( getPrecision() == 1 || !databaseMeta.supportsTimeStampToDateConversion() ) {</span>
              // Convert to DATE!
<span class="fc" id="L5195">              long dat = getInteger( data ).longValue(); // converts using Date.getTime()</span>
<span class="fc" id="L5196">              java.sql.Date ddate = new java.sql.Date( dat );</span>
<span class="pc bpc" id="L5197" title="1 of 4 branches missed.">              if ( ignoreTimezone || this.getDateFormatTimeZone() == null ) {</span>
<span class="fc" id="L5198">                preparedStatement.setDate( index, ddate );</span>
              } else {
<span class="fc" id="L5200">                preparedStatement.setDate( index, ddate, Calendar.getInstance( this.getDateFormatTimeZone() ) );</span>
              }
<span class="fc" id="L5202">            } else {</span>
<span class="fc bfc" id="L5203" title="All 2 branches covered.">              if ( data instanceof java.sql.Timestamp ) {</span>
                // Preserve ns precision!
                //
<span class="pc bpc" id="L5206" title="1 of 4 branches missed.">                if ( ignoreTimezone || this.getDateFormatTimeZone() == null ) {</span>
<span class="fc" id="L5207">                  preparedStatement.setTimestamp( index, (java.sql.Timestamp) data );</span>
                } else {
<span class="fc" id="L5209">                  preparedStatement.setTimestamp( index, (java.sql.Timestamp) data, Calendar.getInstance( this</span>
<span class="fc" id="L5210">                    .getDateFormatTimeZone() ) );</span>
                }
              } else {
<span class="fc" id="L5213">                long dat = getInteger( data ).longValue(); // converts using Date.getTime()</span>
<span class="fc" id="L5214">                java.sql.Timestamp sdate = new java.sql.Timestamp( dat );</span>
<span class="pc bpc" id="L5215" title="1 of 4 branches missed.">                if ( ignoreTimezone || this.getDateFormatTimeZone() == null ) {</span>
<span class="fc" id="L5216">                  preparedStatement.setTimestamp( index, sdate );</span>
                } else {
<span class="fc" id="L5218">                  preparedStatement.setTimestamp( index, sdate, Calendar.getInstance( this.getDateFormatTimeZone() ) );</span>
                }
<span class="fc" id="L5220">              }</span>
            }
          } else {
<span class="nc bnc" id="L5223" title="All 4 branches missed.">            if ( getPrecision() == 1 || !databaseMeta.supportsTimeStampToDateConversion() ) {</span>
<span class="nc" id="L5224">              preparedStatement.setNull( index, java.sql.Types.DATE );</span>
            } else {
<span class="nc" id="L5226">              preparedStatement.setNull( index, java.sql.Types.TIMESTAMP );</span>
            }
          }
<span class="nc" id="L5229">          break;</span>
        case IValueMeta.TYPE_BOOLEAN:
<span class="nc bnc" id="L5231" title="All 2 branches missed.">          if ( databaseMeta.supportsBooleanDataType() ) {</span>
<span class="nc bnc" id="L5232" title="All 2 branches missed.">            if ( !isNull( data ) ) {</span>
<span class="nc" id="L5233">              preparedStatement.setBoolean( index, getBoolean( data ).booleanValue() );</span>
            } else {
<span class="nc" id="L5235">              preparedStatement.setNull( index, java.sql.Types.BOOLEAN );</span>
            }
          } else {
<span class="nc bnc" id="L5238" title="All 2 branches missed.">            if ( !isNull( data ) ) {</span>
<span class="nc bnc" id="L5239" title="All 2 branches missed.">              preparedStatement.setString( index, getBoolean( data ).booleanValue() ? &quot;Y&quot; : &quot;N&quot; );</span>
            } else {
<span class="nc" id="L5241">              preparedStatement.setNull( index, java.sql.Types.CHAR );</span>
            }
          }
<span class="nc" id="L5244">          break;</span>
        case IValueMeta.TYPE_BIGNUMBER:
<span class="nc bnc" id="L5246" title="All 2 branches missed.">          if ( !isNull( data ) ) {</span>
<span class="nc" id="L5247">            preparedStatement.setBigDecimal( index, getBigNumber( data ) );</span>
          } else {
<span class="nc" id="L5249">            preparedStatement.setNull( index, java.sql.Types.DECIMAL );</span>
          }
<span class="nc" id="L5251">          break;</span>
        case IValueMeta.TYPE_BINARY:
<span class="nc bnc" id="L5253" title="All 2 branches missed.">          if ( !isNull( data ) ) {</span>
<span class="nc" id="L5254">            preparedStatement.setBytes( index, getBinary( data ) );</span>
          } else {
<span class="nc" id="L5256">            preparedStatement.setNull( index, java.sql.Types.BINARY );</span>
          }
<span class="nc" id="L5258">          break;</span>
        default:
          // placeholder
<span class="nc" id="L5261">          preparedStatement.setNull( index, java.sql.Types.VARCHAR );</span>
          break;
      }
<span class="nc" id="L5264">    } catch ( Exception e ) {</span>
<span class="nc" id="L5265">      throw new HopDatabaseException( &quot;Error setting value #&quot; + index + &quot; [&quot; + toStringMeta()</span>
        + &quot;] on prepared statement&quot;, e );
<span class="fc" id="L5267">    }</span>
<span class="fc" id="L5268">  }</span>

  @Override
  public Object getNativeDataType( Object object ) throws HopValueException {
<span class="nc bnc" id="L5272" title="All 3 branches missed.">    switch ( getStorageType() ) {</span>
      case STORAGE_TYPE_BINARY_STRING:
<span class="nc" id="L5274">        return convertBinaryStringToNativeType( (byte[]) object );</span>
      case STORAGE_TYPE_INDEXED:
<span class="nc" id="L5276">        return index[ (Integer) object ];</span>
      case STORAGE_TYPE_NORMAL:
      default:
<span class="nc" id="L5279">        return object;</span>
    }
  }

  @Override
  public String getDatabaseColumnTypeDefinition( IDatabase iDatabase, String tk, String pk,
                                                 boolean use_autoinc, boolean add_fieldname, boolean add_cr ) {
<span class="nc" id="L5286">    return null; // No default suggestions...</span>
  }

  protected int getQuotesBeforeSymbol( String df, String symbols ) {
<span class="nc" id="L5290">    int quotes = 0;</span>
<span class="nc" id="L5291">    int stopPos = df.indexOf( symbols );</span>
<span class="nc bnc" id="L5292" title="All 2 branches missed.">    if ( stopPos &gt; 0 ) {</span>
<span class="nc" id="L5293">      int curPos = -1;</span>
      do {
<span class="nc" id="L5295">        curPos = df.indexOf( &quot;'&quot;, curPos + 1 );</span>
<span class="nc bnc" id="L5296" title="All 4 branches missed.">        if ( curPos &gt;= 0 &amp;&amp; curPos &lt; stopPos ) {</span>
<span class="nc" id="L5297">          quotes++;</span>
        }
<span class="nc bnc" id="L5299" title="All 4 branches missed.">      } while ( curPos &gt;= 0 &amp;&amp; curPos &lt; stopPos );</span>
    }
<span class="nc" id="L5301">    return quotes;</span>
  }

  @Override
  public Class&lt;?&gt; getNativeDataTypeClass() throws HopValueException {
    // Not implemented for base class
<span class="fc" id="L5307">    throw new HopValueException( getTypeDesc() + &quot; does not implement this method&quot; );</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>