<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueDataUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Hop Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.hop.core.row</a> &gt; <span class="el_source">ValueDataUtil.java</span></div><h1>ValueDataUtil.java</h1><pre class="source lang-java linenums">/*! ******************************************************************************
 *
 * Hop : The Hop Orchestration Platform
 *
 * http://www.project-hop.org
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.apache.hop.core.row;

import org.apache.commons.codec.language.DoubleMetaphone;
import org.apache.commons.codec.language.Metaphone;
import org.apache.commons.codec.language.RefinedSoundex;
import org.apache.commons.codec.language.Soundex;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.WordUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.vfs2.FileObject;
import org.apache.commons.vfs2.FileSystemException;
import org.apache.hop.core.Const;
import org.apache.hop.core.exception.HopFileNotFoundException;
import org.apache.hop.core.exception.HopValueException;
import org.apache.hop.core.fileinput.CharsetToolkit;
import org.apache.hop.core.util.HopJaroWinklerDistance;
import org.apache.hop.core.util.Utils;
import org.apache.hop.core.vfs.HopVfs;
import org.apache.hop.core.xml.XmlCheck;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.security.MessageDigest;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.zip.Adler32;
import java.util.zip.CRC32;
import java.util.zip.CheckedInputStream;

<span class="nc" id="L58">public class ValueDataUtil {</span>

<span class="fc" id="L60">  private static final Log log = LogFactory.getLog( ValueDataUtil.class );</span>

  /**
   * System property sets rounding mode of calculator's function ROUND(A,B)
   * &lt;ul&gt;
   * &lt;li&gt;
   * -DROUND_2_MODE=ROUND_HALF_EVEN - provides backward compatibility.&lt;/li&gt;
   * &lt;li&gt;
   * -DROUND_2_MODE=ROUND_HALF_CEILING or not specified - makes the effect of ROUND(A,B) like ROUND(A).&lt;/li&gt;
   * &lt;li&gt;
   * If incorrect value set - default value used (ROUND_CEILING).&lt;/li&gt;
   * &lt;/ul&gt;
   * See (PDI-9920)
   */
  private static final String SYS_PROPERTY_ROUND_2_MODE = &quot;ROUND_2_MODE&quot;;
  /**
   * Value of system property ROUND_2_MODE
   * Provides correct rounding (PDI-9920)
   */
  private static final String SYS_PROPERTY_ROUND_2_MODE_DEFAULT_VALUE = &quot;ROUND_HALF_CEILING&quot;;
  private static final int ROUND_2_MODE_DEFAULT_VALUE = Const.ROUND_HALF_CEILING;
  /**
   * Value of system property ROUND_2_MODE
   * Provides backward compatibility (PDI-9920)
   */
  private static final String SYS_PROPERTY_ROUND_2_MODE_BACKWARD_COMPATIBILITY_VALUE = &quot;ROUND_HALF_EVEN&quot;;
  private static final int ROUND_2_MODE_BACKWARD_COMPATIBILITY_VALUE = BigDecimal.ROUND_HALF_EVEN;

  /**
   * Rounding mode of the ROUND function with 2 arguments (value, precision).
   * &lt;ul&gt;
   * &lt;li&gt;
   * {@code org.apache.hop.core.Const.ROUND_HALF_CEILING} - ditto as ROUND(value).&lt;/li&gt;
   * &lt;li&gt;{@code java.math.BigDecimal.ROUND_HALF_EVEN} - backward compatibility&lt;/li&gt;
   * &lt;/ul&gt;
   */
<span class="fc" id="L96">  private static int ROUND_2_MODE = readRound2Mode();</span>

  private static int readRound2Mode() {
<span class="fc" id="L99">    int round2Mode = ROUND_2_MODE_DEFAULT_VALUE;</span>
<span class="fc" id="L100">    final String rpaValue = System.getProperty( SYS_PROPERTY_ROUND_2_MODE );</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">    if ( Utils.isEmpty( rpaValue ) ) {</span>
<span class="fc" id="L102">      round2Mode = ROUND_2_MODE_DEFAULT_VALUE;</span>
<span class="fc" id="L103">      log.debug( &quot;System property is omitted: ROUND_2_MODE. Default value used: &quot; + SYS_PROPERTY_ROUND_2_MODE_DEFAULT_VALUE + &quot;.&quot; );</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">    } else if ( SYS_PROPERTY_ROUND_2_MODE_DEFAULT_VALUE.equals( rpaValue ) ) {</span>
<span class="nc" id="L105">      round2Mode = ROUND_2_MODE_DEFAULT_VALUE;</span>
<span class="nc" id="L106">      log.debug( &quot;System property read: ROUND_2_MODE=&quot; + ROUND_2_MODE_DEFAULT_VALUE + &quot; (default value)&quot; );</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">    } else if ( SYS_PROPERTY_ROUND_2_MODE_BACKWARD_COMPATIBILITY_VALUE.equalsIgnoreCase( rpaValue ) ) {</span>
<span class="nc" id="L108">      round2Mode = ROUND_2_MODE_BACKWARD_COMPATIBILITY_VALUE;</span>
<span class="nc" id="L109">      log.debug( &quot;System property read: ROUND_2_MODE=&quot; + SYS_PROPERTY_ROUND_2_MODE_BACKWARD_COMPATIBILITY_VALUE</span>
        + &quot; (backward compatibility value)&quot; );
    } else {
<span class="nc" id="L112">      log.warn( &quot;Incorrect value of system property read: ROUND_2_MODE=&quot; + rpaValue + &quot;. Set to &quot; + SYS_PROPERTY_ROUND_2_MODE_DEFAULT_VALUE</span>
        + &quot; instead.&quot; );
    }
<span class="fc" id="L115">    return round2Mode;</span>
  }

  private static void throwsErrorOnFileNotFound( FileObject file ) throws HopFileNotFoundException, FileSystemException {
<span class="nc bnc" id="L119" title="All 4 branches missed.">    if ( file == null || !file.exists() ) {</span>
<span class="nc" id="L120">      throw new HopFileNotFoundException( &quot;File not found&quot;, file.getName().getPath() );</span>
    }
<span class="nc" id="L122">  }</span>

  /**
   * @deprecated Use {@link Const#ltrim(String)} instead
   */
  @Deprecated
  public static final String leftTrim( String string ) {
<span class="nc" id="L129">    return Const.ltrim( string );</span>
  }

  /**
   * @deprecated Use {@link Const#rtrim(String)} instead
   */
  @Deprecated
  public static final String rightTrim( String string ) {
<span class="nc" id="L137">    return Const.rtrim( string );</span>
  }

  /**
   * Determines whether or not a character is considered a space. A character is considered a space in Hop if it is a
   * space, a tab, a newline or a cariage return.
   *
   * @param c The character to verify if it is a space.
   * @return true if the character is a space. false otherwise.
   * @deprecated Use {@link Const#isSpace(char)} instead
   */
  @Deprecated
  public static final boolean isSpace( char c ) {
<span class="nc" id="L150">    return Const.isSpace( c );</span>
  }

  /**
   * Trims a string: removes the leading and trailing spaces of a String.
   *
   * @param string The string to trim
   * @return The trimmed string.
   * @deprecated Use {@link Const#trim(String)} instead
   */
  @Deprecated
  public static final String trim( String string ) {
<span class="nc" id="L162">    return Const.trim( string );</span>
  }

  /**
   * Levenshtein distance (LD) is a measure of the similarity between two strings, which we will refer to as the source
   * string (s) and the target string (t). The distance is the number of deletions, insertions, or substitutions
   * required to transform s into t.
   */
  public static Long getLevenshtein_Distance( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                              Object dataB ) {
<span class="nc bnc" id="L172" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L173">      return null;</span>
    }
<span class="nc" id="L175">    return new Long( StringUtils.getLevenshteinDistance( dataA.toString(), dataB.toString() ) );</span>
  }

  /**
   * DamerauLevenshtein distance is a measure of the similarity between two strings, which we will refer to as the
   * source string (s) and the target string (t). The distance is the number of deletions, insertions, or substitutions
   * required to transform s into t.
   */
  public static Long getDamerauLevenshtein_Distance( IValueMeta metaA, Object dataA,
                                                     IValueMeta metaB, Object dataB ) {
<span class="nc bnc" id="L185" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L186">      return null;</span>
    }
<span class="nc" id="L188">    return new Long( Utils.getDamerauLevenshteinDistance( dataA.toString(), dataB.toString() ) );</span>
  }


  /**
   * Jaro similitude is a measure of the similarity between two strings, which we will refer to as the source string (s)
   * and the target string (t).
   */
  public static Double getJaro_Similitude( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                           Object dataB ) {
<span class="nc bnc" id="L198" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L199">      return null;</span>
    }
<span class="nc" id="L201">    HopJaroWinklerDistance pjwd = new HopJaroWinklerDistance();</span>
<span class="nc" id="L202">    pjwd.apply( dataA.toString(), dataB.toString() );</span>
<span class="nc" id="L203">    return pjwd.getJaroDistance();</span>
  }

  /**
   * JaroWinkler similitude is a measure of the similarity between two strings, which we will refer to as the source
   * string (s) and the target string (t).
   */
  public static Double getJaroWinkler_Similitude( IValueMeta metaA, Object dataA,
                                                  IValueMeta metaB, Object dataB ) {
<span class="nc bnc" id="L212" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L213">      return null;</span>
    }
<span class="nc" id="L215">    HopJaroWinklerDistance pjwd = new HopJaroWinklerDistance();</span>
<span class="nc" id="L216">    pjwd.apply( dataA.toString(), dataB.toString() );</span>
<span class="nc" id="L217">    return pjwd.getJaroWinklerDistance();</span>
  }

  public static String get_Metaphone( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L222">      return null;</span>
    }
<span class="nc" id="L224">    return ( new Metaphone() ).metaphone( dataA.toString() );</span>
  }

  public static String get_Double_Metaphone( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L229">      return null;</span>
    }
<span class="nc" id="L231">    return ( new DoubleMetaphone() ).doubleMetaphone( dataA.toString() );</span>
  }

  public static String get_SoundEx( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L236">      return null;</span>
    }
<span class="nc" id="L238">    return ( new Soundex() ).encode( dataA.toString() );</span>
  }

  public static String get_RefinedSoundEx( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L243">      return null;</span>
    }
<span class="nc" id="L245">    return ( new RefinedSoundex() ).encode( dataA.toString() );</span>
  }

  public static String initCap( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L250">      return null;</span>
    }
<span class="nc" id="L252">    return WordUtils.capitalize( dataA.toString(), new char[] { ' ', '_', ',', ':', ';', '-' } );</span>
  }

  public static String upperCase( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L257">      return null;</span>
    }
<span class="nc" id="L259">    return dataA.toString().toUpperCase();</span>
  }

  public static String lowerCase( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L264">      return null;</span>
    }
<span class="nc" id="L266">    return dataA.toString().toLowerCase();</span>
  }

  public static String escapeXml(IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L270" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L271">      return null;</span>
    }
<span class="nc" id="L273">    return Const.escapeXml( dataA.toString() );</span>
  }

  public static String unEscapeXml(IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L277" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L278">      return null;</span>
    }
<span class="nc" id="L280">    return Const.unEscapeXml( dataA.toString() );</span>
  }

  public static String escapeHtml(IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L284" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L285">      return null;</span>
    }
<span class="nc" id="L287">    return Const.escapeHtml( dataA.toString() );</span>
  }

  public static String unEscapeHtml(IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L292">      return null;</span>
    }
<span class="nc" id="L294">    return Const.unEscapeHtml( dataA.toString() );</span>
  }

  public static String escapeSql(IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L299">      return null;</span>
    }
<span class="nc" id="L301">    return Const.escapeSql( dataA.toString() );</span>
  }

  public static String useCDATA( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L306">      return null;</span>
    }
<span class="nc" id="L308">    return &quot;&lt;![CDATA[&quot; + dataA.toString() + &quot;]]&gt;&quot;;</span>

  }

  public static String removeCR( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L314">      return null;</span>
    }
<span class="nc" id="L316">    return Const.removeCR( dataA.toString() );</span>
  }

  public static String removeLF( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L321">      return null;</span>
    }
<span class="nc" id="L323">    return Const.removeLF( dataA.toString() );</span>
  }

  public static String removeCRLF( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L328">      return null;</span>
    }
<span class="nc" id="L330">    return Const.removeCRLF( dataA.toString() );</span>
  }

  public static String removeTAB( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L335">      return null;</span>
    }
<span class="nc" id="L337">    return Const.removeTAB( dataA.toString() );</span>
  }

  public static String getDigits( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L341" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L342">      return null;</span>
    }
<span class="nc" id="L344">    return Const.getDigitsOnly( dataA.toString() );</span>
  }

  public static String removeDigits( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L349">      return null;</span>
    }
<span class="nc" id="L351">    return Const.removeDigits( dataA.toString() );</span>
  }

  public static long stringLen( IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L356">      return 0;</span>
    }
<span class="nc" id="L358">    return dataA.toString().length();</span>
  }

  /**
   * @deprecated Use {@link ValueDataUtil#createChecksum(IValueMeta, Object, String, boolean)} instead
   */
  @Deprecated
  public static String createChecksum( IValueMeta metaA, Object dataA, String type ) {
<span class="nc" id="L366">    String checksum = null;</span>
    try {
<span class="nc" id="L368">      checksum = createChecksum( metaA, dataA, type, false );</span>
<span class="nc" id="L369">    } catch ( HopFileNotFoundException e ) {</span>
      // Ignore
<span class="nc" id="L371">    }</span>
<span class="nc" id="L372">    return checksum;</span>
  }

  /**
   * @param metaA        The IValueMeta
   * @param dataA        Filename
   * @param type         Algorithm to be used when computing the checksum (MD5 or SHA-1)
   * @param failIfNoFile Indicates if the pipeline should fail if no file is found
   * @return File's checksum
   * @throws HopFileNotFoundException
   */
  public static String createChecksum( IValueMeta metaA, Object dataA, String type, boolean failIfNoFile )
    throws HopFileNotFoundException {
<span class="nc bnc" id="L385" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L386">      return null;</span>
    }

<span class="nc" id="L389">    String md5Hash = null;</span>
<span class="nc" id="L390">    FileObject file = null;</span>
<span class="nc" id="L391">    InputStream in = null;</span>
    try {
<span class="nc" id="L393">      file = HopVfs.getFileObject( dataA.toString() );</span>
<span class="nc" id="L394">      throwsErrorOnFileNotFound( file );</span>
<span class="nc" id="L395">      in = HopVfs.getInputStream( file );</span>
<span class="nc" id="L396">      int bytes = in.available();</span>
<span class="nc" id="L397">      byte[] buffer = new byte[ bytes ];</span>
<span class="nc" id="L398">      in.read( buffer );</span>

<span class="nc" id="L400">      StringBuffer md5HashBuff = new StringBuffer( 32 );</span>
<span class="nc" id="L401">      byte[] b = MessageDigest.getInstance( type ).digest( buffer );</span>
<span class="nc" id="L402">      int len = b.length;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">      for ( int x = 0; x &lt; len; x++ ) {</span>
<span class="nc" id="L404">        md5HashBuff.append( String.format( &quot;%02x&quot;, b[ x ] ) );</span>
      }

<span class="nc" id="L407">      md5Hash = md5HashBuff.toString();</span>

<span class="nc" id="L409">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      if ( failIfNoFile ) {</span>
<span class="nc" id="L411">        throw e;</span>
      }
<span class="nc" id="L413">      log.debug( e.getMessage() );</span>
<span class="nc" id="L414">    } catch ( Exception e ) {</span>
<span class="nc" id="L415">      log.debug( e.getMessage() );</span>
    } finally {
<span class="nc" id="L417">      IOUtils.closeQuietly( file );</span>
<span class="nc" id="L418">      IOUtils.closeQuietly( in );</span>
    }
<span class="nc" id="L420">    return md5Hash;</span>
  }

  /**
   * @deprecated Use {@link ValueDataUtil#checksumCRC32(IValueMeta, Object, boolean)} instead
   */
  @Deprecated
  public static Long ChecksumCRC32( IValueMeta metaA, Object dataA ) {
<span class="nc" id="L428">    long checksum = 0;</span>
    try {
<span class="nc" id="L430">      checksum = checksumCRC32( metaA, dataA, false );</span>
<span class="nc" id="L431">    } catch ( HopFileNotFoundException e ) {</span>
      // Ignore
<span class="nc" id="L433">    }</span>
<span class="nc" id="L434">    return checksum;</span>
  }

  /**
   * @param metaA        The IValueMeta
   * @param dataA        Filename
   * @param failIfNoFile Indicates if the pipeline should fail if no file is found
   * @return File's CRC32 checksum
   * @throws HopFileNotFoundException
   */
  public static Long checksumCRC32( IValueMeta metaA, Object dataA, boolean failIfNoFile )
    throws HopFileNotFoundException {
<span class="nc" id="L446">    long checksum = 0;</span>

<span class="nc bnc" id="L448" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L449">      return checksum;</span>
    }

<span class="nc" id="L452">    FileObject file = null;</span>
<span class="nc" id="L453">    CheckedInputStream cis = null;</span>
    try {
<span class="nc" id="L455">      file = HopVfs.getFileObject( dataA.toString() );</span>
<span class="nc" id="L456">      throwsErrorOnFileNotFound( file );</span>
<span class="nc" id="L457">      cis = null;</span>

      // Computer CRC32 checksum
<span class="nc" id="L460">      cis = new CheckedInputStream( HopVfs.getInputStream( file ), new CRC32() );</span>
<span class="nc" id="L461">      byte[] buf = new byte[ 128 ];</span>
<span class="nc" id="L462">      int readSize = 0;</span>
      do {
<span class="nc" id="L464">        readSize = cis.read( buf );</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">      } while ( readSize &gt;= 0 );</span>

<span class="nc" id="L467">      checksum = cis.getChecksum().getValue();</span>

<span class="nc" id="L469">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">      if ( failIfNoFile ) {</span>
<span class="nc" id="L471">        throw e;</span>
      }
<span class="nc" id="L473">      log.debug( e.getMessage() );</span>
<span class="nc" id="L474">    } catch ( Exception e ) {</span>
<span class="nc" id="L475">      log.debug( e.getMessage() );</span>
    } finally {
<span class="nc" id="L477">      IOUtils.closeQuietly( file );</span>
<span class="nc" id="L478">      IOUtils.closeQuietly( cis );</span>
    }
<span class="nc" id="L480">    return checksum;</span>
  }

  /**
   * @deprecated Use {@link ValueDataUtil#checksumAdler32(IValueMeta, Object, boolean)} instead
   */
  @Deprecated
  public static Long ChecksumAdler32( IValueMeta metaA, Object dataA ) {
<span class="nc" id="L488">    long checksum = 0;</span>
    try {
<span class="nc" id="L490">      checksum = checksumAdler32( metaA, dataA, false );</span>
<span class="nc" id="L491">    } catch ( HopFileNotFoundException e ) {</span>
      // Ignore
<span class="nc" id="L493">    }</span>
<span class="nc" id="L494">    return checksum;</span>
  }

  /**
   * @param metaA        The IValueMeta
   * @param dataA        Filename
   * @param failIfNoFile Indicates if the pipeline should fail if no file is found
   * @return File's Adler32 checksum
   * @throws HopFileNotFoundException
   */
  public static Long checksumAdler32( IValueMeta metaA, Object dataA, boolean failIfNoFile )
    throws HopFileNotFoundException {
<span class="nc" id="L506">    long checksum = 0;</span>

<span class="nc bnc" id="L508" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L509">      return checksum;</span>
    }

<span class="nc" id="L512">    FileObject file = null;</span>
<span class="nc" id="L513">    CheckedInputStream cis = null;</span>
    try {
<span class="nc" id="L515">      file = HopVfs.getFileObject( dataA.toString() );</span>
<span class="nc" id="L516">      throwsErrorOnFileNotFound( file );</span>
<span class="nc" id="L517">      cis = null;</span>

      // Computer Adler-32 checksum
<span class="nc" id="L520">      cis = new CheckedInputStream( HopVfs.getInputStream( file ), new Adler32() );</span>

<span class="nc" id="L522">      byte[] buf = new byte[ 128 ];</span>
<span class="nc" id="L523">      int readSize = 0;</span>
      do {
<span class="nc" id="L525">        readSize = cis.read( buf );</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">      } while ( readSize &gt;= 0 );</span>
<span class="nc" id="L527">      checksum = cis.getChecksum().getValue();</span>

<span class="nc" id="L529">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">      if ( failIfNoFile ) {</span>
<span class="nc" id="L531">        throw e;</span>
      }
<span class="nc" id="L533">      log.debug( e.getMessage() );</span>
<span class="nc" id="L534">    } catch ( Exception e ) {</span>
<span class="nc" id="L535">      log.debug( e.getMessage() );</span>
    } finally {
<span class="nc" id="L537">      IOUtils.closeQuietly( file );</span>
<span class="nc" id="L538">      IOUtils.closeQuietly( cis );</span>
    }
<span class="nc" id="L540">    return checksum;</span>
  }

  public static Object plus( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L544" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L545">      return null;</span>
    }

<span class="nc bnc" id="L548" title="All 6 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_STRING:
<span class="nc" id="L550">        return metaA.getString( dataA ) + metaB.getString( dataB );</span>
      case IValueMeta.TYPE_NUMBER: {
<span class="nc" id="L552">        Double valueA = metaA.getNumber( dataA );</span>
<span class="nc" id="L553">        Double valueB = metaB.getNumber( dataB );</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if ( valueB == null ) {</span>
<span class="nc" id="L555">          return valueA;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        } else if ( valueA == null ) {</span>
<span class="nc" id="L557">          return valueB;</span>
        } else {
<span class="nc" id="L559">          return new Double( valueA.doubleValue() + valueB.doubleValue() );</span>
        }
      }
      case IValueMeta.TYPE_INTEGER: {
<span class="nc" id="L563">        Long valueA = metaA.getInteger( dataA );</span>
<span class="nc" id="L564">        Long valueB = metaB.getInteger( dataB );</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if ( valueB == null ) {</span>
<span class="nc" id="L566">          return valueA;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        } else if ( valueA == null ) {</span>
<span class="nc" id="L568">          return valueB;</span>
        } else {
<span class="nc" id="L570">          return new Long( valueA.longValue() + valueB.longValue() );</span>
        }
      }
      case IValueMeta.TYPE_BOOLEAN: {
<span class="nc" id="L574">        Boolean valueA = metaA.getBoolean( dataA );</span>
<span class="nc" id="L575">        Boolean valueB = metaB.getBoolean( dataB );</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if ( valueB == null ) {</span>
<span class="nc" id="L577">          return valueA;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        } else if ( valueA == null ) {</span>
<span class="nc" id="L579">          return valueB;</span>
        } else {
<span class="nc bnc" id="L581" title="All 4 branches missed.">          return Boolean.valueOf( valueA.booleanValue() || valueB.booleanValue() );</span>
        }
      }
      case IValueMeta.TYPE_BIGNUMBER: {
<span class="nc" id="L585">        BigDecimal valueA = metaA.getBigNumber( dataA );</span>
<span class="nc" id="L586">        BigDecimal valueB = metaB.getBigNumber( dataB );</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if ( valueB == null ) {</span>
<span class="nc" id="L588">          return valueA;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        } else if ( valueA == null ) {</span>
<span class="nc" id="L590">          return valueB;</span>
        } else {
<span class="nc" id="L592">          return valueA.add( valueB );</span>
        }
      }
      default:
<span class="nc" id="L596">        throw new HopValueException( &quot;The 'plus' function only works on numeric data and Strings.&quot; );</span>
    }
  }

  public static Object plus3( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB,
                              IValueMeta metaC, Object dataC ) throws HopValueException {
<span class="nc bnc" id="L602" title="All 6 branches missed.">    if ( dataA == null || dataB == null || dataC == null ) {</span>
<span class="nc" id="L603">      return null;</span>
    }

<span class="nc bnc" id="L606" title="All 6 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_STRING:
<span class="nc" id="L608">        return metaA.getString( dataA ) + metaB.getString( dataB ) + metaC.getString( dataC );</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L610">        return new Double( metaA.getNumber( dataA ).doubleValue()</span>
<span class="nc" id="L611">          + metaB.getNumber( dataB ).doubleValue() + metaC.getNumber( dataC ).doubleValue() );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L613">        return new Long( metaA.getInteger( dataA ).longValue()</span>
<span class="nc" id="L614">          + metaB.getInteger( dataB ).longValue() + metaC.getInteger( dataC ).longValue() );</span>
      case IValueMeta.TYPE_BOOLEAN:
<span class="nc bnc" id="L616" title="All 2 branches missed.">        return Boolean.valueOf( metaA.getBoolean( dataA ).booleanValue()</span>
<span class="nc bnc" id="L617" title="All 4 branches missed.">          || metaB.getBoolean( dataB ).booleanValue() || metaB.getBoolean( dataC ).booleanValue() );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L619">        return metaA.getBigNumber( dataA ).add( metaB.getBigNumber( dataB ).add( metaC.getBigNumber( dataC ) ) );</span>

      default:
<span class="nc" id="L622">        throw new HopValueException( &quot;The 'plus' function only works on numeric data and Strings.&quot; );</span>
    }
  }

  public static Object sum( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L627" title="All 4 branches missed.">    if ( dataA == null &amp;&amp; dataB == null ) {</span>
<span class="nc" id="L628">      return null;</span>
    }
<span class="nc bnc" id="L630" title="All 4 branches missed.">    if ( dataA == null &amp;&amp; dataB != null ) {</span>
<span class="nc" id="L631">      Object value = metaA.convertData( metaB, dataB );</span>
<span class="nc" id="L632">      metaA.setStorageType( IValueMeta.STORAGE_TYPE_NORMAL );</span>
<span class="nc" id="L633">      return value;</span>
    }
<span class="nc bnc" id="L635" title="All 4 branches missed.">    if ( dataA != null &amp;&amp; dataB == null ) {</span>
<span class="nc" id="L636">      return dataA;</span>
    }

<span class="nc" id="L639">    return plus( metaA, dataA, metaB, dataB );</span>
  }

  /**
   * @deprecated Use {@link ValueDataUtil#loadFileContentInBinary(IValueMeta, Object, boolean)} instead
   */
  @Deprecated
  public static Object loadFileContentInBinary( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc" id="L647">    Object content = null;</span>
    try {
<span class="nc" id="L649">      content = loadFileContentInBinary( metaA, dataA, true );</span>
<span class="nc" id="L650">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc" id="L651">      throw new HopValueException();</span>
<span class="nc" id="L652">    }</span>
<span class="nc" id="L653">    return content;</span>
  }

  /**
   * @param metaA        The IValueMeta
   * @param dataA        Filename
   * @param failIfNoFile Indicates if the pipeline should fail if no file is found
   * @return File's content in binary
   * @throws HopValueException
   * @throws HopFileNotFoundException
   */
  public static byte[] loadFileContentInBinary( IValueMeta metaA, Object dataA, boolean failIfNoFile )
    throws HopValueException, HopFileNotFoundException {
<span class="nc bnc" id="L666" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L667">      return null;</span>
    }

<span class="nc" id="L670">    byte[] content = null;</span>
<span class="nc" id="L671">    FileObject file = null;</span>
<span class="nc" id="L672">    InputStream is = null;</span>

    try {
<span class="nc" id="L675">      file = HopVfs.getFileObject( dataA.toString() );</span>
<span class="nc" id="L676">      throwsErrorOnFileNotFound( file );</span>
<span class="nc" id="L677">      is = HopVfs.getInputStream( file );</span>
<span class="nc" id="L678">      int fileSize = (int) file.getContent().getSize();</span>
<span class="nc" id="L679">      content = new byte[ fileSize ];</span>
<span class="nc" id="L680">      is.read( content, 0, fileSize );</span>
<span class="nc" id="L681">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">      if ( failIfNoFile ) {</span>
<span class="nc" id="L683">        throw e;</span>
      }
<span class="nc" id="L685">      log.debug( e.getMessage() );</span>
<span class="nc" id="L686">    } catch ( Exception e ) {</span>
<span class="nc" id="L687">      throw new HopValueException( e );</span>
    } finally {
<span class="nc" id="L689">      IOUtils.closeQuietly( file );</span>
<span class="nc" id="L690">      IOUtils.closeQuietly( is );</span>
    }
<span class="nc" id="L692">    return content;</span>
  }

  public static Object minus( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L696" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L697">      return null;</span>
    }

<span class="nc bnc" id="L700" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L702">        return new Double( metaA.getNumber( dataA ).doubleValue() - metaB.getNumber( dataB ).doubleValue() );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L704">        return new Long( metaA.getInteger( dataA ).longValue() - metaB.getInteger( dataB ).longValue() );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L706">        return metaA.getBigNumber( dataA ).subtract( metaB.getBigNumber( dataB ) );</span>
      default:
<span class="nc" id="L708">        return new Long( metaA.getInteger( dataA ).longValue() - metaB.getInteger( dataB ).longValue() );</span>
    }
  }

  public static Object multiply( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L713" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L714">      return null;</span>
    }

<span class="nc bnc" id="L717" title="All 8 branches missed.">    if ( ( metaB.isString() &amp;&amp; metaA.isNumeric() ) || ( metaB.isNumeric() &amp;&amp; metaA.isString() ) ) {</span>
<span class="nc" id="L718">      return multiplyString( metaA, dataA, metaB, dataB );</span>
    }

<span class="nc" id="L721">    return multiplyNumeric( metaA, dataA, metaB, dataB );</span>
  }

  protected static Object multiplyNumeric( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                           Object dataB ) throws HopValueException {
<span class="nc bnc" id="L726" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L728">        return multiplyDoubles( metaA.getNumber( dataA ), metaB.getNumber( dataB ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L730">        return multiplyLongs( metaA.getInteger( dataA ), metaB.getInteger( dataB ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L732">        return multiplyBigDecimals( metaA.getBigNumber( dataA ), metaB.getBigNumber( dataB ), null );</span>

      default:
<span class="nc" id="L735">        throw new HopValueException(</span>
          &quot;The 'multiply' function only works on numeric data optionally multiplying strings.&quot; );
    }
  }

  public static Double multiplyDoubles( Double a, Double b ) {
<span class="nc" id="L741">    return new Double( a.doubleValue() * b.doubleValue() );</span>
  }

  public static Long multiplyLongs( Long a, Long b ) {
<span class="nc" id="L745">    return new Long( a.longValue() * b.longValue() );</span>
  }

  // Get BigNumber size to be considered in mathematical operations
  private static int getMaxPrecision( BigDecimal a, BigDecimal b ) {
<span class="nc bnc" id="L750" title="All 2 branches missed.">    return a.precision() &gt;= b.precision() ? a.precision() : b.precision();</span>
  }

  // Get BigNumber max scale (length of decimal part)
  private static int getMaxScale( BigDecimal a, BigDecimal b ) {
<span class="nc bnc" id="L755" title="All 2 branches missed.">    return a.scale() &gt;= b.scale() ? a.scale() : b.scale();</span>
  }

  // If decimal part has only zeros, remove it. Otherwise scale it to maxScale
  private static BigDecimal removeTrailingZeroFractionOrScale( BigDecimal a, int maxScale ) {
<span class="nc bnc" id="L760" title="All 2 branches missed.">    if ( a.remainder( BigDecimal.ONE ).compareTo( BigDecimal.ZERO ) == 0 ) {</span>
<span class="nc" id="L761">      return a.setScale( 0 );</span>
    }

<span class="nc" id="L764">    return a.setScale( maxScale, RoundingMode.HALF_EVEN );</span>
  }

  public static BigDecimal multiplyBigDecimals( BigDecimal a, BigDecimal b, MathContext mc ) {
<span class="nc bnc" id="L768" title="All 2 branches missed.">    if ( mc == null ) {</span>
<span class="nc" id="L769">      mc = new MathContext( getMaxPrecision( a, b ), RoundingMode.HALF_EVEN );</span>
    }

<span class="nc" id="L772">    return removeTrailingZeroFractionOrScale( a.multiply( b, mc ), getMaxScale( a, b ) );</span>
  }

  protected static Object multiplyString( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                          Object dataB ) throws HopValueException {
    StringBuffer s;
<span class="nc" id="L778">    String append = &quot;&quot;;</span>
    int n;
<span class="nc bnc" id="L780" title="All 2 branches missed.">    if ( metaB.isString() ) {</span>
<span class="nc" id="L781">      s = new StringBuffer( metaB.getString( dataB ) );</span>
<span class="nc" id="L782">      append = metaB.getString( dataB );</span>
<span class="nc" id="L783">      n = metaA.getInteger( dataA ).intValue();</span>
    } else {
<span class="nc" id="L785">      s = new StringBuffer( metaA.getString( dataA ) );</span>
<span class="nc" id="L786">      append = metaA.getString( dataA );</span>
<span class="nc" id="L787">      n = metaB.getInteger( dataB ).intValue();</span>
    }

<span class="nc bnc" id="L790" title="All 2 branches missed.">    if ( n == 0 ) {</span>
<span class="nc" id="L791">      s.setLength( 0 );</span>
    } else {
<span class="nc bnc" id="L793" title="All 2 branches missed.">      for ( int i = 1; i &lt; n; i++ ) {</span>
<span class="nc" id="L794">        s.append( append );</span>
      }
    }

<span class="nc" id="L798">    return s.toString();</span>
  }

  public static Object divide( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L802" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L803">      return null;</span>
    }

<span class="nc bnc" id="L806" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L808">        return divideDoubles( metaA.getNumber( dataA ), metaB.getNumber( dataB ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L810">        return divideLongs( metaA.getInteger( dataA ), metaB.getInteger( dataB ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L812">        return divideBigDecimals( metaA.getBigNumber( dataA ), metaB.getBigNumber( dataB ), null );</span>

      default:
<span class="nc" id="L815">        throw new HopValueException( &quot;The 'divide' function only works on numeric data.&quot; );</span>
    }
  }

  public static Double divideDoubles( Double a, Double b ) {
<span class="nc" id="L820">    return new Double( a.doubleValue() / b.doubleValue() );</span>
  }

  public static Long divideLongs( Long a, Long b ) {
<span class="nc" id="L824">    return new Long( a.longValue() / b.longValue() );</span>
  }

  public static BigDecimal divideBigDecimals( BigDecimal a, BigDecimal b, MathContext mc ) {
<span class="nc bnc" id="L828" title="All 2 branches missed.">    if ( mc == null ) {</span>
<span class="nc" id="L829">      mc = new MathContext( getMaxPrecision( a, b ), RoundingMode.HALF_EVEN );</span>
    }

<span class="nc" id="L832">    BigDecimal result = a.divide( b, mc );</span>
<span class="nc" id="L833">    return removeTrailingZeroFractionOrScale( result, result.scale() );</span>
  }

  public static Object sqrt( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L837" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L838">      return null;</span>
    }

<span class="nc bnc" id="L841" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L843">        return new Double( Math.sqrt( metaA.getNumber( dataA ).doubleValue() ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L845">        return new Long( Math.round( Math.sqrt( metaA.getNumber( dataA ).doubleValue() ) ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L847">        return BigDecimal.valueOf( Math.sqrt( metaA.getNumber( dataA ).doubleValue() ) );</span>

      default:
<span class="nc" id="L850">        throw new HopValueException( &quot;The 'sqrt' function only works on numeric data.&quot; );</span>
    }
  }

  /**
   * 100 * A / B
   *
   * @param metaA
   * @param dataA
   * @param metaB
   * @param dataB
   * @return
   * @throws HopValueException
   */
  public static Object percent1( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L865" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L866">      return null;</span>
    }

<span class="nc bnc" id="L869" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L871">        return divideDoubles( multiplyDoubles( 100.0D, metaA.getNumber( dataA ) ), metaB.getNumber( dataB ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L873">        return divideLongs( multiplyLongs( 100L, metaA.getInteger( dataA ) ), metaB.getInteger( dataB ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L875">        return divideBigDecimals(</span>
<span class="nc" id="L876">          multiplyBigDecimals( metaA.getBigNumber( dataA ), new BigDecimal( 100 ), null ), metaB</span>
<span class="nc" id="L877">            .getBigNumber( dataB ), null );</span>

      default:
<span class="nc" id="L880">        throw new HopValueException( &quot;The 'A/B in %' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * A - ( A * B / 100 )
   *
   * @param metaA
   * @param dataA
   * @param metaB
   * @param dataB
   * @return
   * @throws HopValueException
   */
  public static Object percent2( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L895" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L896">      return null;</span>
    }

<span class="nc bnc" id="L899" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L901">        return new Double( metaA.getNumber( dataA ).doubleValue()</span>
<span class="nc" id="L902">          - divideDoubles( multiplyDoubles( metaA.getNumber( dataA ), metaB.getNumber( dataB ) ), 100.0D ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L904">        return new Long( metaA.getInteger( dataA ).longValue()</span>
<span class="nc" id="L905">          - divideLongs( multiplyLongs( metaA.getInteger( dataA ), metaB.getInteger( dataB ) ), 100L ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L907">        return metaA.getBigNumber( dataA ).subtract(</span>
<span class="nc" id="L908">          divideBigDecimals( multiplyBigDecimals(</span>
<span class="nc" id="L909">            metaB.getBigNumber( dataB ), metaA.getBigNumber( dataA ), null ), new BigDecimal( 100 ), null ) );</span>
      default:
<span class="nc" id="L911">        throw new HopValueException( &quot;The 'A-B%' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * A + ( A * B / 100 )
   *
   * @param metaA
   * @param dataA
   * @param metaB
   * @param dataB
   * @return
   * @throws HopValueException
   */
  public static Object percent3( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L926" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L927">      return null;</span>
    }

<span class="nc bnc" id="L930" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L932">        return new Double( metaA.getNumber( dataA ).doubleValue()</span>
<span class="nc" id="L933">          + divideDoubles( multiplyDoubles( metaA.getNumber( dataA ), metaB.getNumber( dataB ) ), 100.0D ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L935">        return new Long( metaA.getInteger( dataA ).longValue()</span>
<span class="nc" id="L936">          + divideLongs( multiplyLongs( metaA.getInteger( dataA ), metaB.getInteger( dataB ) ), 100L ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L938">        return metaA.getBigNumber( dataA ).add(</span>
<span class="nc" id="L939">          divideBigDecimals( multiplyBigDecimals(</span>
<span class="nc" id="L940">            metaB.getBigNumber( dataB ), metaA.getBigNumber( dataA ), null ), new BigDecimal( 100 ), null ) );</span>
      default:
<span class="nc" id="L942">        throw new HopValueException( &quot;The 'A+B%' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * A + B * C
   *
   * @param metaA
   * @param dataA
   * @param metaB
   * @param dataB
   * @return
   * @throws HopValueException
   */
  public static Object combination1( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                     Object dataB, IValueMeta metaC, Object dataC ) throws HopValueException {
<span class="nc bnc" id="L958" title="All 6 branches missed.">    if ( dataA == null || dataB == null || dataC == null ) {</span>
<span class="nc" id="L959">      return null;</span>
    }

<span class="nc bnc" id="L962" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L964">        return new Double( metaA.getNumber( dataA ).doubleValue()</span>
<span class="nc" id="L965">          + ( metaB.getNumber( dataB ).doubleValue() * metaC.getNumber( dataC ).doubleValue() ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L967">        return new Long( metaA.getInteger( dataA ).longValue()</span>
<span class="nc" id="L968">          + ( metaB.getInteger( dataB ).longValue() * metaC.getInteger( dataC ).longValue() ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L970">        return metaA.getBigNumber( dataA ).add(</span>
<span class="nc" id="L971">          multiplyBigDecimals( metaB.getBigNumber( dataB ), metaC.getBigNumber( dataC ), null ) );</span>

      default:
<span class="nc" id="L974">        throw new HopValueException( &quot;The 'combination1' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * SQRT( A*A + B*B )
   *
   * @param metaA
   * @param dataA
   * @param metaB
   * @param dataB
   * @return
   * @throws HopValueException
   */
  public static Object combination2( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L989" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L990">      return null;</span>
    }

<span class="nc bnc" id="L993" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L995">        return new Double( Math.sqrt( metaA.getNumber( dataA ).doubleValue()</span>
<span class="nc" id="L996">          * metaA.getNumber( dataA ).doubleValue() + metaB.getNumber( dataB ).doubleValue()</span>
<span class="nc" id="L997">          * metaB.getNumber( dataB ).doubleValue() ) );</span>

      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1000">        return new Long( Math.round( Math.sqrt( metaA.getInteger( dataA ).longValue()</span>
<span class="nc" id="L1001">          * metaA.getInteger( dataA ).longValue() + metaB.getInteger( dataB ).longValue()</span>
<span class="nc" id="L1002">          / metaB.getInteger( dataB ).longValue() ) ) );</span>

      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1005">        return BigDecimal.valueOf( Math.sqrt( metaA.getNumber( dataA ).doubleValue()</span>
<span class="nc" id="L1006">          * metaA.getNumber( dataA ).doubleValue() + metaB.getNumber( dataB ).doubleValue()</span>
<span class="nc" id="L1007">          * metaB.getNumber( dataB ).doubleValue() ) );</span>

      default:
<span class="nc" id="L1010">        throw new HopValueException( &quot;The 'combination2' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * Rounding with no decimal places (using default rounding method ROUND_HALF_CEILING)
   *
   * @param metaA Metadata of value to round
   * @param dataA Value to round
   * @return The rounded value
   * @throws HopValueException
   */
  public static Object round( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1024">      return null;</span>
    }

<span class="nc bnc" id="L1027" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1029">        return new Double( Math.round( metaA.getNumber( dataA ).doubleValue() ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1031">        return metaA.getInteger( dataA );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1033">        return new BigDecimal( Math.round( metaA.getNumber( dataA ).doubleValue() ) );</span>

      default:
<span class="nc" id="L1036">        throw new HopValueException( &quot;The 'round' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * Rounding with no decimal places with a given rounding method
   *
   * @param metaA        Metadata of value to round
   * @param dataA        Value to round
   * @param roundingMode The mode for rounding, e.g. java.math.BigDecimal.ROUND_HALF_EVEN
   * @return The rounded value
   * @throws HopValueException
   */
  public static Object round( IValueMeta metaA, Object dataA, int roundingMode ) throws HopValueException {
<span class="nc bnc" id="L1050" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1051">      return null;</span>
    }

<span class="nc bnc" id="L1054" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      // Use overloaded Const.round(value, precision, mode)
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1057">        return new Double( Const.round( metaA.getNumber( dataA ), 0, roundingMode ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1059">        return new Long( Const.round( metaA.getInteger( dataA ), 0, roundingMode ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1061">        return Const.round( metaA.getBigNumber( dataA ), 0, roundingMode );</span>
      default:
<span class="nc" id="L1063">        throw new HopValueException( &quot;The 'round' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * Rounding with decimal places (using default rounding method ROUND_HALF_EVEN)
   *
   * @param metaA Metadata of value to round
   * @param dataA Value to round
   * @param metaB Metadata of decimal places
   * @param dataB decimal places
   * @return The rounded value
   * @throws HopValueException
   */
  public static Object round( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB )
    throws HopValueException {
<span class="nc" id="L1079">    final Object r = round( metaA, dataA, metaB, dataB, ROUND_2_MODE );</span>
<span class="nc" id="L1080">    return r;</span>
  }

  /**
   * Rounding with decimal places with a given rounding method
   *
   * @param metaA        Metadata of value to round
   * @param dataA        Value to round
   * @param metaB        Metadata of decimal places
   * @param dataB        decimal places
   * @param roundingMode roundingMode The mode for rounding, e.g. java.math.BigDecimal.ROUND_HALF_EVEN
   * @return The rounded value
   * @throws HopValueException
   */
  public static Object round( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB,
                              int roundingMode ) throws HopValueException {
<span class="nc bnc" id="L1096" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L1097">      return null;</span>
    }

<span class="nc bnc" id="L1100" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1102">        return new Double( Const.round( metaA.getNumber( dataA ).doubleValue(), metaB.getInteger( dataB ).intValue(),</span>
          roundingMode ) );
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1105">        return new Long( Const.round( metaA.getInteger( dataA ).longValue(), metaB.getInteger( dataB ).intValue(),</span>
          roundingMode ) );
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1108">        return Const.round( metaA.getBigNumber( dataA ), metaB.getInteger( dataB ).intValue(), roundingMode );</span>
      default:
<span class="nc" id="L1110">        throw new HopValueException( &quot;The 'round' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * Rounding with decimal places with a given rounding method
   *
   * @param metaA Metadata of value to round
   * @param dataA Value to round
   * @param metaB Metadata of decimal places
   * @param dataB decimal places
   * @param metaC Metadata of rounding mode
   * @param dataC rounding mode, e.g. java.math.BigDecimal.ROUND_HALF_EVEN
   * @return The rounded value
   * @throws HopValueException
   */
  public static Object round( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB,
                              IValueMeta metaC, Object dataC ) throws HopValueException {
<span class="nc bnc" id="L1128" title="All 6 branches missed.">    if ( dataA == null || dataB == null || dataC == null ) {</span>
<span class="nc" id="L1129">      return null;</span>
    }
<span class="nc" id="L1131">    Long valueC = metaC.getInteger( dataC );</span>
<span class="nc bnc" id="L1132" title="All 6 branches missed.">    if ( valueC == null || valueC &lt; Const.ROUND_HALF_CEILING || valueC &gt; BigDecimal.ROUND_HALF_EVEN ) {</span>
<span class="nc" id="L1133">      throw new HopValueException( &quot;The 'round_custom' arg C has incorrect value: &quot; + valueC );</span>
    }
<span class="nc" id="L1135">    int roundingMode = valueC.intValue();</span>
<span class="nc" id="L1136">    return round( metaA, dataA, metaB, dataB, roundingMode );</span>
  }

  public static Object ceil( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1140" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1141">      return null;</span>
    }
<span class="nc bnc" id="L1143" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1145">        return new Double( Math.ceil( metaA.getNumber( dataA ).doubleValue() ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1147">        return metaA.getInteger( dataA );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1149">        return new BigDecimal( Math.ceil( metaA.getNumber( dataA ).doubleValue() ) );</span>

      default:
<span class="nc" id="L1152">        throw new HopValueException( &quot;The 'ceil' function only works on numeric data&quot; );</span>
    }
  }

  public static Object floor( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1158">      return null;</span>
    }
<span class="nc bnc" id="L1160" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1162">        return new Double( Math.floor( metaA.getNumber( dataA ).doubleValue() ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1164">        return metaA.getInteger( dataA );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1166">        return new BigDecimal( Math.floor( metaA.getNumber( dataA ).doubleValue() ) );</span>

      default:
<span class="nc" id="L1169">        throw new HopValueException( &quot;The 'floor' function only works on numeric data&quot; );</span>
    }
  }

  public static Object abs( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1175">      return null;</span>
    }

<span class="nc bnc" id="L1178" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1180">        return new Double( Math.abs( metaA.getNumber( dataA ).doubleValue() ) );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1182">        return metaA.getInteger( Math.abs( metaA.getNumber( dataA ).longValue() ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1184">        return new BigDecimal( Math.abs( metaA.getNumber( dataA ).doubleValue() ) );</span>

      default:
<span class="nc" id="L1187">        throw new HopValueException( &quot;The 'abs' function only works on numeric data&quot; );</span>
    }
  }

  /**
   * Returns the remainder (modulus) of A / B.
   *
   * @param metaA
   * @param dataA The dividend
   * @param metaB
   * @param dataB The divisor
   * @return The remainder
   * @throws HopValueException
   */
  public static Object remainder( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L1202" title="All 4 branches missed.">    if ( dataA == null || dataB == null ) {</span>
<span class="nc" id="L1203">      return null;</span>
    }

<span class="nc bnc" id="L1206" title="All 4 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L1208">        return new Double( metaA.getNumber( dataA ).doubleValue() % metaB.getNumber( dataB ).doubleValue() );</span>
      case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L1210">        return new Long( metaA.getInteger( dataA ) % metaB.getInteger( dataB ) );</span>
      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L1212">        BigDecimal aValue = metaA.getBigNumber( dataA );</span>
<span class="nc" id="L1213">        BigDecimal bValue = metaA.getBigNumber( dataB );</span>
<span class="nc" id="L1214">        BigDecimal result = aValue.remainder( bValue, new MathContext( getMaxPrecision( aValue, bValue ), RoundingMode.HALF_EVEN ) );</span>
<span class="nc" id="L1215">        return removeTrailingZeroFractionOrScale( result, result.scale() );</span>
      default:
<span class="nc" id="L1217">        throw new HopValueException( &quot;The 'remainder' function only works on numeric data&quot; );</span>
    }
  }

  public static Object nvl( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {
<span class="nc bnc" id="L1222" title="All 8 branches missed.">    switch ( metaA.getType() ) {</span>
      case IValueMeta.TYPE_STRING:
<span class="nc bnc" id="L1224" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1225">          return metaB.getString( dataB );</span>
        } else {
<span class="nc" id="L1227">          return metaA.getString( dataA );</span>
        }

      case IValueMeta.TYPE_NUMBER:
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1232">          return metaB.getNumber( dataB );</span>
        } else {
<span class="nc" id="L1234">          return metaA.getNumber( dataA );</span>
        }

      case IValueMeta.TYPE_INTEGER:
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1239">          return metaB.getInteger( dataB );</span>
        } else {
<span class="nc" id="L1241">          return metaA.getInteger( dataA );</span>
        }

      case IValueMeta.TYPE_BIGNUMBER:
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1246">          return metaB.getBigNumber( dataB );</span>
        } else {
<span class="nc" id="L1248">          return metaA.getBigNumber( dataA );</span>
        }

      case IValueMeta.TYPE_DATE:
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1253">          return metaB.getDate( dataB );</span>
        } else {
<span class="nc" id="L1255">          return metaA.getDate( dataA );</span>
        }

      case IValueMeta.TYPE_BOOLEAN:
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1260">          return metaB.getBoolean( dataB );</span>
        } else {
<span class="nc" id="L1262">          return metaA.getBoolean( dataA );</span>
        }

      case IValueMeta.TYPE_BINARY:
<span class="nc bnc" id="L1266" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1267">          return metaB.getBinary( dataB );</span>
        } else {
<span class="nc" id="L1269">          return metaA.getBinary( dataA );</span>
        }

      default:
<span class="nc bnc" id="L1273" title="All 2 branches missed.">        if ( dataA == null ) {</span>
<span class="nc" id="L1274">          return metaB.getNativeDataType( dataB );</span>
        } else {
<span class="nc" id="L1276">          return metaA.getNativeDataType( dataA );</span>
        }
    }
  }

  public static Object removeTimeFromDate( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc" id="L1282">    Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1283">    Date date = metaA.getDate( dataA );</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">    if ( date != null ) {</span>
<span class="nc" id="L1285">      cal.setTime( date );</span>
<span class="nc" id="L1286">      return Const.removeTimeFromDate( date );</span>
    } else {
<span class="nc" id="L1288">      return null;</span>
    }
  }

  public static Object addTimeToDate( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                      Object dataB, IValueMeta metaC, Object dataC ) throws HopValueException {
<span class="nc bnc" id="L1294" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1295">      return null;</span>
    }

    try {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">      if ( dataC == null ) {</span>
<span class="nc" id="L1300">        return Const.addTimeToDate( metaA.getDate( dataA ), metaB.getString( dataB ), null );</span>
      } else {
<span class="nc" id="L1302">        return Const.addTimeToDate( metaA.getDate( dataA ), metaB.getString( dataB ), metaC.getString( dataC ) );</span>
      }
<span class="nc" id="L1304">    } catch ( Exception e ) {</span>
<span class="nc" id="L1305">      throw new HopValueException( e );</span>
    }
  }

  public static Object addDays( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {

<span class="nc" id="L1311">    Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1312">    cal.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1313">    cal.add( Calendar.DAY_OF_YEAR, metaB.getInteger( dataB ).intValue() );</span>

<span class="nc" id="L1315">    return cal.getTime();</span>
  }

  public static Object addHours( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {

<span class="nc" id="L1320">    Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1321">    cal.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1322">    cal.add( Calendar.HOUR_OF_DAY, metaB.getInteger( dataB ).intValue() );</span>

<span class="nc" id="L1324">    return cal.getTime();</span>
  }

  public static Object addMinutes( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {

<span class="nc" id="L1329">    Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1330">    cal.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1331">    cal.add( Calendar.MINUTE, metaB.getInteger( dataB ).intValue() );</span>

<span class="nc" id="L1333">    return cal.getTime();</span>
  }

  public static Object addSeconds( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {

<span class="nc" id="L1338">    Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1339">    cal.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1340">    cal.add( Calendar.SECOND, metaB.getInteger( dataB ).intValue() );</span>

<span class="nc" id="L1342">    return cal.getTime();</span>
  }

  public static Object addMonths( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB ) throws HopValueException {

<span class="nc bnc" id="L1347" title="All 4 branches missed.">    if ( dataA != null &amp;&amp; dataB != null ) {</span>
<span class="nc" id="L1348">      Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1349">      cal.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1350">      int year = cal.get( Calendar.YEAR );</span>
<span class="nc" id="L1351">      int month = cal.get( Calendar.MONTH );</span>
<span class="nc" id="L1352">      int day = cal.get( Calendar.DAY_OF_MONTH );</span>

<span class="nc" id="L1354">      month += metaB.getInteger( dataB ).intValue();</span>

<span class="nc" id="L1356">      int newyear = year + (int) Math.floor( month / 12 );</span>
<span class="nc" id="L1357">      int newmonth = month % 12;</span>

<span class="nc" id="L1359">      cal.set( newyear, newmonth, 1 );</span>
<span class="nc" id="L1360">      int newday = cal.getActualMaximum( Calendar.DAY_OF_MONTH );</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">      if ( newday &lt; day ) {</span>
<span class="nc" id="L1362">        cal.set( Calendar.DAY_OF_MONTH, newday );</span>
      } else {
<span class="nc" id="L1364">        cal.set( Calendar.DAY_OF_MONTH, day );</span>
      }

<span class="nc" id="L1367">      return ( cal.getTime() );</span>
    } else {
<span class="nc" id="L1369">      throw new HopValueException( &quot;Unable to add months with a null value&quot; );</span>
    }

  }

  /**
   * Returns the number of days that have elapsed between dataA and dataB.
   *
   * @param metaA
   * @param dataA      The &quot;end date&quot;
   * @param metaB
   * @param dataB      The &quot;start date&quot;
   * @param resultType The &quot;result type&quot; (ms, s, mn, h, d)
   * @return Number of days
   * @throws HopValueException
   */

  public static Object DateDiff( IValueMeta metaA, Object dataA, IValueMeta metaB, Object dataB,
                                 String resultType ) throws HopValueException {

<span class="nc bnc" id="L1389" title="All 4 branches missed.">    if ( dataA != null &amp;&amp; dataB != null ) {</span>
<span class="nc" id="L1390">      Date startDate = metaB.getDate( dataB );</span>
<span class="nc" id="L1391">      Date endDate = metaA.getDate( dataA );</span>

<span class="nc" id="L1393">      Calendar stDateCal = Calendar.getInstance();</span>
<span class="nc" id="L1394">      Calendar endDateCal = Calendar.getInstance();</span>
<span class="nc" id="L1395">      stDateCal.setTime( startDate );</span>
<span class="nc" id="L1396">      endDateCal.setTime( endDate );</span>

<span class="nc" id="L1398">      long endL = endDateCal.getTimeInMillis() + endDateCal.getTimeZone().getOffset( endDateCal.getTimeInMillis() );</span>
<span class="nc" id="L1399">      long startL = stDateCal.getTimeInMillis() + stDateCal.getTimeZone().getOffset( stDateCal.getTimeInMillis() );</span>
<span class="nc" id="L1400">      long diff = endL - startL;</span>

<span class="nc bnc" id="L1402" title="All 2 branches missed.">      if ( Utils.isEmpty( resultType ) ) {</span>
<span class="nc" id="L1403">        return new Long( diff / 86400000 );</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">      } else if ( resultType.equals( &quot;ms&quot; ) ) {</span>
<span class="nc" id="L1405">        return new Long( diff );</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">      } else if ( resultType.equals( &quot;s&quot; ) ) {</span>
<span class="nc" id="L1407">        return new Long( diff / 1000 ); // second</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">      } else if ( resultType.equals( &quot;mn&quot; ) ) {</span>
<span class="nc" id="L1409">        return new Long( diff / 60000 ); // minute</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">      } else if ( resultType.equals( &quot;h&quot; ) ) {</span>
<span class="nc" id="L1411">        return new Long( diff / 3600000 ); // hour</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">      } else if ( resultType.equals( &quot;d&quot; ) ) {</span>
<span class="nc" id="L1413">        return new Long( diff / 86400000 );</span>
      } else {
<span class="nc" id="L1415">        throw new HopValueException( &quot;Unknown result type option '&quot; + resultType + &quot;'&quot; );</span>
      }
    } else {
<span class="nc" id="L1418">      return null;</span>
    }
  }

  public static Object DateWorkingDiff( IValueMeta metaA, Object dataA, IValueMeta metaB,
                                        Object dataB ) throws HopValueException {
<span class="pc bpc" id="L1424" title="2 of 4 branches missed.">    if ( dataA != null &amp;&amp; dataB != null ) {</span>
<span class="fc" id="L1425">      Date fromDate = metaB.getDate( dataB );</span>
<span class="fc" id="L1426">      Date toDate = metaA.getDate( dataA );</span>
<span class="fc" id="L1427">      boolean singminus = false;</span>

<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">      if ( fromDate.after( toDate ) ) {</span>
<span class="nc" id="L1430">        singminus = true;</span>
<span class="nc" id="L1431">        Date temp = fromDate;</span>
<span class="nc" id="L1432">        fromDate = toDate;</span>
<span class="nc" id="L1433">        toDate = temp;</span>
      }
<span class="fc" id="L1435">      Calendar calFrom = Calendar.getInstance();</span>
<span class="fc" id="L1436">      calFrom.setTime( fromDate );</span>
<span class="fc" id="L1437">      Calendar calTo = Calendar.getInstance();</span>
<span class="fc" id="L1438">      calTo.setTime( toDate );</span>
<span class="fc" id="L1439">      int iNoOfWorkingDays = 0;</span>
      do {
<span class="fc bfc" id="L1441" title="All 2 branches covered.">        if ( calFrom.get( Calendar.DAY_OF_WEEK ) != Calendar.SATURDAY</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">          &amp;&amp; calFrom.get( Calendar.DAY_OF_WEEK ) != Calendar.SUNDAY ) {</span>
<span class="fc" id="L1443">          iNoOfWorkingDays += 1;</span>
        }
<span class="fc" id="L1445">        calFrom.add( Calendar.DATE, 1 );</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">      } while ( calFrom.getTimeInMillis() &lt;= calTo.getTimeInMillis() );</span>
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">      return new Long( singminus ? -iNoOfWorkingDays : iNoOfWorkingDays );</span>
    } else {
<span class="nc" id="L1449">      return null;</span>
    }
  }

  public static Object yearOfDate( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1454" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1455">      return null;</span>
    }

<span class="nc" id="L1458">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1459">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1460">    return new Long( calendar.get( Calendar.YEAR ) );</span>

  }

  public static Object monthOfDate( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1465" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1466">      return null;</span>
    }

<span class="nc" id="L1469">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1470">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1471">    return new Long( calendar.get( Calendar.MONTH ) + 1 );</span>

  }

  public static Object quarterOfDate( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1476" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1477">      return null;</span>
    }

<span class="nc" id="L1480">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1481">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1482">    return new Long( ( calendar.get( Calendar.MONTH ) + 3 ) / 3 );</span>
  }

  public static Object dayOfYear( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1486" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1487">      return null;</span>
    }

<span class="nc" id="L1490">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1491">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1492">    return new Long( calendar.get( Calendar.DAY_OF_YEAR ) );</span>
  }

  public static Object dayOfMonth( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1496" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1497">      return null;</span>
    }

<span class="nc" id="L1500">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1501">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1502">    return new Long( calendar.get( Calendar.DAY_OF_MONTH ) );</span>
  }

  public static Object hourOfDay( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1507">      return null;</span>
    }

<span class="fc" id="L1510">    Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L1511">    calendar.setTime( metaA.getDate( dataA ) );</span>

<span class="fc" id="L1513">    Boolean oldDateCalculation = Boolean.parseBoolean(</span>
<span class="fc" id="L1514">      Const.getEnvironmentVariable( Const.HOP_COMPATIBILITY_CALCULATION_TIMEZONE_DECOMPOSITION, &quot;false&quot; ) );</span>
<span class="fc bfc" id="L1515" title="All 2 branches covered.">    if ( !oldDateCalculation ) {</span>
<span class="fc" id="L1516">      calendar.setTimeZone( metaA.getDateFormatTimeZone() );</span>
    }

<span class="fc" id="L1519">    return new Long( calendar.get( Calendar.HOUR_OF_DAY ) );</span>
  }

  public static Object minuteOfHour( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1523" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1524">      return null;</span>
    }

<span class="nc" id="L1527">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1528">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1529">    return new Long( calendar.get( Calendar.MINUTE ) );</span>
  }

  public static Object secondOfMinute( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1533" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1534">      return null;</span>
    }

<span class="nc" id="L1537">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1538">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1539">    return new Long( calendar.get( Calendar.SECOND ) );</span>
  }

  public static Object dayOfWeek( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1543" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1544">      return null;</span>
    }

<span class="nc" id="L1547">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1548">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1549">    return new Long( calendar.get( Calendar.DAY_OF_WEEK ) );</span>
  }

  public static Object weekOfYear( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1553" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1554">      return null;</span>
    }

<span class="nc" id="L1557">    Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1558">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1559">    return new Long( calendar.get( Calendar.WEEK_OF_YEAR ) );</span>
  }

  public static Object weekOfYearISO8601( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1563" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1564">      return null;</span>
    }

<span class="nc" id="L1567">    Calendar calendar = Calendar.getInstance( Locale.ENGLISH );</span>
<span class="nc" id="L1568">    calendar.setMinimalDaysInFirstWeek( 4 );</span>
<span class="nc" id="L1569">    calendar.setFirstDayOfWeek( Calendar.MONDAY );</span>
<span class="nc" id="L1570">    calendar.setTime( metaA.getDate( dataA ) );</span>
<span class="nc" id="L1571">    return new Long( calendar.get( Calendar.WEEK_OF_YEAR ) );</span>

  }

  public static Object yearOfDateISO8601( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1576" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1577">      return null;</span>
    }

<span class="nc" id="L1580">    Calendar calendar = Calendar.getInstance( Locale.ENGLISH );</span>
<span class="nc" id="L1581">    calendar.setMinimalDaysInFirstWeek( 4 );</span>
<span class="nc" id="L1582">    calendar.setFirstDayOfWeek( Calendar.MONDAY );</span>
<span class="nc" id="L1583">    calendar.setTime( metaA.getDate( dataA ) );</span>

<span class="nc" id="L1585">    int week = calendar.get( Calendar.WEEK_OF_YEAR );</span>
<span class="nc" id="L1586">    int month = calendar.get( Calendar.MONTH );</span>
<span class="nc" id="L1587">    int year = calendar.get( Calendar.YEAR );</span>

    // fix up for the year taking into account ISO8601 weeks
<span class="nc bnc" id="L1590" title="All 4 branches missed.">    if ( week &gt;= 52 &amp;&amp; month == 0 ) {</span>
<span class="nc" id="L1591">      year--;</span>
    }
<span class="nc bnc" id="L1593" title="All 4 branches missed.">    if ( week &lt;= 2 &amp;&amp; month == 11 ) {</span>
<span class="nc" id="L1594">      year++;</span>
    }

<span class="nc" id="L1597">    return new Long( year );</span>
  }

  /**
   * Change a hexadecimal string into normal ASCII representation. E.g. if Value contains string &quot;61&quot; afterwards it
   * would contain value &quot;a&quot;. If the hexadecimal string is of odd length a leading zero will be used.
   * &lt;p&gt;
   * Note that only the low byte of a character will be processed, this is for binary pipelines.
   *
   * @return Value itself
   * @throws HopValueException
   */
  public static String hexToByteDecode( IValueMeta meta, Object data ) throws HopValueException {
<span class="nc bnc" id="L1610" title="All 2 branches missed.">    if ( meta.isNull( data ) ) {</span>
<span class="nc" id="L1611">      return null;</span>
    }

<span class="nc" id="L1614">    String hexString = meta.getString( data );</span>

<span class="nc" id="L1616">    int len = hexString.length();</span>
<span class="nc" id="L1617">    char[] chArray = new char[ ( len + 1 ) / 2 ];</span>
<span class="nc" id="L1618">    boolean evenByte = true;</span>
<span class="nc" id="L1619">    int nextByte = 0;</span>

    // we assume a leading 0 if the length is not even.
<span class="nc bnc" id="L1622" title="All 2 branches missed.">    if ( ( len % 2 ) == 1 ) {</span>
<span class="nc" id="L1623">      evenByte = false;</span>
    }

    int nibble;
    int i, j;
<span class="nc bnc" id="L1628" title="All 2 branches missed.">    for ( i = 0, j = 0; i &lt; len; i++ ) {</span>
<span class="nc" id="L1629">      char c = hexString.charAt( i );</span>

<span class="nc bnc" id="L1631" title="All 4 branches missed.">      if ( ( c &gt;= '0' ) &amp;&amp; ( c &lt;= '9' ) ) {</span>
<span class="nc" id="L1632">        nibble = c - '0';</span>
<span class="nc bnc" id="L1633" title="All 4 branches missed.">      } else if ( ( c &gt;= 'A' ) &amp;&amp; ( c &lt;= 'F' ) ) {</span>
<span class="nc" id="L1634">        nibble = c - 'A' + 0x0A;</span>
<span class="nc bnc" id="L1635" title="All 4 branches missed.">      } else if ( ( c &gt;= 'a' ) &amp;&amp; ( c &lt;= 'f' ) ) {</span>
<span class="nc" id="L1636">        nibble = c - 'a' + 0x0A;</span>
      } else {
<span class="nc" id="L1638">        throw new HopValueException( &quot;invalid hex digit '&quot; + c + &quot;'.&quot; );</span>
      }

<span class="nc bnc" id="L1641" title="All 2 branches missed.">      if ( evenByte ) {</span>
<span class="nc" id="L1642">        nextByte = ( nibble &lt;&lt; 4 );</span>
      } else {
<span class="nc" id="L1644">        nextByte += nibble;</span>
<span class="nc" id="L1645">        chArray[ j ] = (char) nextByte;</span>
<span class="nc" id="L1646">        j++;</span>
      }

<span class="nc bnc" id="L1649" title="All 2 branches missed.">      evenByte = !evenByte;</span>
    }
<span class="nc" id="L1651">    return new String( chArray );</span>
  }

  /**
   * Change a string into its hexadecimal representation. E.g. if Value contains string &quot;a&quot; afterwards it would contain
   * value &quot;0061&quot;.
   * &lt;p&gt;
   * Note that pipelines happen in groups of 4 hex characters, so the value of a characters is always in the range
   * 0-65535.
   *
   * @return
   * @throws HopValueException
   */
  public static String byteToHexEncode( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc bnc" id="L1665" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1666">      return null;</span>
    }

<span class="nc" id="L1669">    final char[] hexDigits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };</span>

    // depending on the use case, this code might deliver the wrong values due to extra conversion with toCharArray
    // see Checksum transform and PDI-5190
    // &quot;Add Checksum transform gives incorrect results (MD5, CRC32, ADLER32, SHA-1 are affected)&quot;
<span class="nc" id="L1674">    String hex = metaA.getString( dataA );</span>

<span class="nc" id="L1676">    char[] s = hex.toCharArray();</span>
<span class="nc" id="L1677">    StringBuffer hexString = new StringBuffer( 2 * s.length );</span>

<span class="nc bnc" id="L1679" title="All 2 branches missed.">    for ( int i = 0; i &lt; s.length; i++ ) {</span>
<span class="nc" id="L1680">      hexString.append( hexDigits[ ( s[ i ] &amp; 0x00F0 ) &gt;&gt; 4 ] ); // hi nibble</span>
<span class="nc" id="L1681">      hexString.append( hexDigits[ s[ i ] &amp; 0x000F ] ); // lo nibble</span>
    }

<span class="nc" id="L1684">    return hexString.toString();</span>
  }

  /**
   * Change a string into its hexadecimal representation. E.g. if Value contains string &quot;a&quot; afterwards it would contain
   * value &quot;0061&quot;.
   * &lt;p&gt;
   * Note that pipelines happen in groups of 4 hex characters, so the value of a characters is always in the range
   * 0-65535.
   *
   * @return A string with Hex code
   * @throws HopValueException In case of a data conversion problem.
   */
  public static String charToHexEncode( IValueMeta meta, Object data ) throws HopValueException {
<span class="nc" id="L1698">    final char[] hexDigits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };</span>

<span class="nc bnc" id="L1700" title="All 2 branches missed.">    if ( meta.isNull( data ) ) {</span>
<span class="nc" id="L1701">      return null;</span>
    }

<span class="nc" id="L1704">    String hex = meta.getString( data );</span>

<span class="nc" id="L1706">    char[] s = hex.toCharArray();</span>
<span class="nc" id="L1707">    StringBuffer hexString = new StringBuffer( 2 * s.length );</span>

<span class="nc bnc" id="L1709" title="All 2 branches missed.">    for ( int i = 0; i &lt; s.length; i++ ) {</span>
<span class="nc" id="L1710">      hexString.append( hexDigits[ ( s[ i ] &amp; 0xF000 ) &gt;&gt; 12 ] ); // hex 1</span>
<span class="nc" id="L1711">      hexString.append( hexDigits[ ( s[ i ] &amp; 0x0F00 ) &gt;&gt; 8 ] ); // hex 2</span>
<span class="nc" id="L1712">      hexString.append( hexDigits[ ( s[ i ] &amp; 0x00F0 ) &gt;&gt; 4 ] ); // hex 3</span>
<span class="nc" id="L1713">      hexString.append( hexDigits[ s[ i ] &amp; 0x000F ] ); // hex 4</span>
    }

<span class="nc" id="L1716">    return hexString.toString();</span>
  }

  /**
   * Change a hexadecimal string into normal ASCII representation. E.g. if Value contains string &quot;61&quot; afterwards it
   * would contain value &quot;a&quot;. If the hexadecimal string is of a wrong length leading zeroes will be used.
   * &lt;p&gt;
   * Note that pipelines happen in groups of 4 hex characters, so the value of a characters is always in the range
   * 0-65535.
   *
   * @return A hex-to-char decoded String
   * @throws HopValueException
   */
  public static String hexToCharDecode( IValueMeta meta, Object data ) throws HopValueException {
<span class="nc bnc" id="L1730" title="All 2 branches missed.">    if ( meta.isNull( data ) ) {</span>
<span class="nc" id="L1731">      return null;</span>
    }

<span class="nc" id="L1734">    String hexString = meta.getString( data );</span>

<span class="nc" id="L1736">    int len = hexString.length();</span>
<span class="nc" id="L1737">    char[] chArray = new char[ ( len + 3 ) / 4 ];</span>
    int charNr;
<span class="nc" id="L1739">    int nextChar = 0;</span>

    // we assume a leading 0s if the length is not right.
<span class="nc" id="L1742">    charNr = ( len % 4 );</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">    if ( charNr == 0 ) {</span>
<span class="nc" id="L1744">      charNr = 4;</span>
    }

    int nibble;
    int i, j;
<span class="nc bnc" id="L1749" title="All 2 branches missed.">    for ( i = 0, j = 0; i &lt; len; i++ ) {</span>
<span class="nc" id="L1750">      char c = hexString.charAt( i );</span>

<span class="nc bnc" id="L1752" title="All 4 branches missed.">      if ( ( c &gt;= '0' ) &amp;&amp; ( c &lt;= '9' ) ) {</span>
<span class="nc" id="L1753">        nibble = c - '0';</span>
<span class="nc bnc" id="L1754" title="All 4 branches missed.">      } else if ( ( c &gt;= 'A' ) &amp;&amp; ( c &lt;= 'F' ) ) {</span>
<span class="nc" id="L1755">        nibble = c - 'A' + 0x0A;</span>
<span class="nc bnc" id="L1756" title="All 4 branches missed.">      } else if ( ( c &gt;= 'a' ) &amp;&amp; ( c &lt;= 'f' ) ) {</span>
<span class="nc" id="L1757">        nibble = c - 'a' + 0x0A;</span>
      } else {
<span class="nc" id="L1759">        throw new HopValueException( &quot;invalid hex digit '&quot; + c + &quot;'.&quot; );</span>
      }

<span class="nc bnc" id="L1762" title="All 2 branches missed.">      if ( charNr == 4 ) {</span>
<span class="nc" id="L1763">        nextChar = ( nibble &lt;&lt; 12 );</span>
<span class="nc" id="L1764">        charNr--;</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">      } else if ( charNr == 3 ) {</span>
<span class="nc" id="L1766">        nextChar += ( nibble &lt;&lt; 8 );</span>
<span class="nc" id="L1767">        charNr--;</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">      } else if ( charNr == 2 ) {</span>
<span class="nc" id="L1769">        nextChar += ( nibble &lt;&lt; 4 );</span>
<span class="nc" id="L1770">        charNr--;</span>
      } else {
        // charNr == 1
<span class="nc" id="L1773">        nextChar += nibble;</span>
<span class="nc" id="L1774">        chArray[ j ] = (char) nextChar;</span>
<span class="nc" id="L1775">        charNr = 4;</span>
<span class="nc" id="L1776">        j++;</span>
      }
    }

<span class="nc" id="L1780">    return new String( chArray );</span>
  }

  /**
   * Right pad a string: adds spaces to a string until a certain length. If the length is smaller then the limit
   * specified, the String is truncated.
   *
   * @param ret   The string to pad
   * @param limit The desired length of the padded string.
   * @return The padded String.
   */
  public static final String rightPad( String ret, int limit ) {
<span class="nc" id="L1792">    return Const.rightPad( ret, limit );</span>
  }

  /**
   * Right pad a StringBuffer: adds spaces to a string until a certain length. If the length is smaller then the limit
   * specified, the String is truncated.
   *
   * @param ret   The StringBuffer to pad
   * @param limit The desired length of the padded string.
   * @return The padded String.
   */
  public static final String rightPad( StringBuffer ret, int limit ) {
<span class="nc" id="L1804">    return Const.rightPad( ret, limit );</span>
  }

  /**
   * Replace value occurances in a String with another value.
   *
   * @param string The original String.
   * @param repl   The text to replace
   * @param with   The new text bit
   * @return The resulting string with the text pieces replaced.
   */
  public static final String replace( String string, String repl, String with ) {
<span class="nc" id="L1816">    StringBuffer str = new StringBuffer( string );</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">    for ( int i = str.length() - 1; i &gt;= 0; i-- ) {</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">      if ( str.substring( i ).startsWith( repl ) ) {</span>
<span class="nc" id="L1819">        str.delete( i, i + repl.length() );</span>
<span class="nc" id="L1820">        str.insert( i, with );</span>
      }
    }
<span class="nc" id="L1823">    return str.toString();</span>
  }

  /**
   * Alternate faster version of string replace using a stringbuffer as input.
   *
   * @param str  The string where we want to replace in
   * @param code The code to search for
   * @param repl The replacement string for code
   */
  public static void replaceBuffer( StringBuffer str, String code, String repl ) {
<span class="nc" id="L1834">    int clength = code.length();</span>

<span class="nc" id="L1836">    int i = str.length() - clength;</span>

<span class="nc bnc" id="L1838" title="All 2 branches missed.">    while ( i &gt;= 0 ) {</span>
<span class="nc" id="L1839">      String look = str.substring( i, i + clength );</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">      if ( look.equalsIgnoreCase( code ) ) {</span>
        // Look for a match!
<span class="nc" id="L1842">        str.replace( i, i + clength, repl );</span>
      }
<span class="nc" id="L1844">      i--;</span>
<span class="nc" id="L1845">    }</span>
<span class="nc" id="L1846">  }</span>

  /**
   * Count the number of spaces to the left of a text. (leading)
   *
   * @param field The text to examine
   * @return The number of leading spaces found.
   */
  public static final int nrSpacesBefore( String field ) {
<span class="nc" id="L1855">    int nr = 0;</span>
<span class="nc" id="L1856">    int len = field.length();</span>
<span class="nc bnc" id="L1857" title="All 4 branches missed.">    while ( nr &lt; len &amp;&amp; field.charAt( nr ) == ' ' ) {</span>
<span class="nc" id="L1858">      nr++;</span>
    }
<span class="nc" id="L1860">    return nr;</span>
  }

  /**
   * Count the number of spaces to the right of a text. (trailing)
   *
   * @param field The text to examine
   * @return The number of trailing spaces found.
   */
  public static final int nrSpacesAfter( String field ) {
<span class="nc" id="L1870">    int nr = 0;</span>
<span class="nc" id="L1871">    int len = field.length();</span>
<span class="nc bnc" id="L1872" title="All 4 branches missed.">    while ( nr &lt; len &amp;&amp; field.charAt( field.length() - 1 - nr ) == ' ' ) {</span>
<span class="nc" id="L1873">      nr++;</span>
    }
<span class="nc" id="L1875">    return nr;</span>
  }

  /**
   * Checks whether or not a String consists only of spaces.
   *
   * @param str The string to check
   * @return true if the string has nothing but spaces.
   */
  public static final boolean onlySpaces( String str ) {
<span class="nc bnc" id="L1885" title="All 2 branches missed.">    for ( int i = 0; i &lt; str.length(); i++ ) {</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">      if ( !isSpace( str.charAt( i ) ) ) {</span>
<span class="nc" id="L1887">        return false;</span>
      }
    }
<span class="nc" id="L1890">    return true;</span>
  }

  /**
   * Checks an xml file is well formed.
   *
   * @param metaA        The IValueMeta
   * @param dataA        The value (filename)
   * @param failIfNoFile Indicates if the pipeline should fail if no file is found
   * @return true if the file is well formed.
   * @throws HopFileNotFoundException
   */
  public static boolean isXmlFileWellFormed(IValueMeta metaA, Object dataA, boolean failIfNoFile )
    throws HopFileNotFoundException {
<span class="nc bnc" id="L1904" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1905">      return false;</span>
    }

<span class="nc" id="L1908">    String filename = dataA.toString();</span>
<span class="nc" id="L1909">    FileObject file = null;</span>
    try {
<span class="nc" id="L1911">      file = HopVfs.getFileObject( filename );</span>
<span class="nc" id="L1912">      throwsErrorOnFileNotFound( file );</span>
<span class="nc" id="L1913">      return XmlCheck.isXmlFileWellFormed( file );</span>
<span class="nc" id="L1914">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">      if ( failIfNoFile ) {</span>
<span class="nc" id="L1916">        throw e;</span>
      }
<span class="nc" id="L1918">      log.debug( e.getMessage() );</span>
<span class="nc" id="L1919">    } catch ( Exception e ) {</span>
<span class="nc" id="L1920">      log.debug( e.getMessage() );</span>
    } finally {
<span class="nc" id="L1922">      IOUtils.closeQuietly( file );</span>
    }
<span class="nc" id="L1924">    return false;</span>
  }

  /**
   * Checks an xml string is well formed.
   *
   * @param metaA The IValueMeta
   * @param dataA The value (filename)
   * @return true if the file is well formed.
   */
  public static boolean isXmlWellFormed(IValueMeta metaA, Object dataA ) {
<span class="nc bnc" id="L1935" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1936">      return false;</span>
    }
    try {
<span class="nc" id="L1939">      return XmlCheck.isXmlWellFormed( new ByteArrayInputStream( metaA.getBinary( dataA ) ) );</span>
<span class="nc" id="L1940">    } catch ( Exception e ) {</span>
<span class="nc" id="L1941">      log.debug( e.getMessage() );</span>
    }
<span class="nc" id="L1943">    return false;</span>
  }

  /**
   * Get file encoding.
   *
   * @param metaA The IValueMeta
   * @param dataA The value (filename)
   * @return file encoding.
   * @deprecated Use {@link ValueDataUtil#getFileEncoding(IValueMeta, Object, boolean)} instead
   */
  @Deprecated
  public static String getFileEncoding( IValueMeta metaA, Object dataA ) throws HopValueException {
<span class="nc" id="L1956">    String encoding = null;</span>
    try {
<span class="nc" id="L1958">      encoding = getFileEncoding( metaA, dataA, true );</span>
<span class="nc" id="L1959">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc" id="L1960">      throw new HopValueException();</span>
<span class="nc" id="L1961">    }</span>
<span class="nc" id="L1962">    return encoding;</span>
  }

  /**
   * Get file encoding.
   *
   * @param metaA        The IValueMeta
   * @param dataA        The value (filename)
   * @param failIfNoFile Indicates if the pipeline should fail if no file is found
   * @return file encoding.
   * @throws HopFileNotFoundException
   * @throws HopValueException
   */
  public static String getFileEncoding( IValueMeta metaA, Object dataA, boolean failIfNoFile )
    throws HopValueException, HopFileNotFoundException {
<span class="nc bnc" id="L1977" title="All 2 branches missed.">    if ( dataA == null ) {</span>
<span class="nc" id="L1978">      return null;</span>
    }

<span class="nc" id="L1981">    String encoding = null;</span>
<span class="nc" id="L1982">    FileObject file = null;</span>
    try {
<span class="nc" id="L1984">      file = HopVfs.getFileObject( metaA.getString( dataA ) );</span>
<span class="nc" id="L1985">      throwsErrorOnFileNotFound( file );</span>
<span class="nc" id="L1986">      encoding = CharsetToolkit.guessEncodingName( file );</span>
<span class="nc" id="L1987">    } catch ( HopFileNotFoundException e ) {</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">      if ( failIfNoFile ) {</span>
<span class="nc" id="L1989">        throw e;</span>
      }
<span class="nc" id="L1991">      log.debug( e.getMessage() );</span>
<span class="nc" id="L1992">    } catch ( Exception e ) {</span>
<span class="nc" id="L1993">      throw new HopValueException( e );</span>
    } finally {
<span class="nc" id="L1995">      IOUtils.closeQuietly( file );</span>
    }
<span class="nc" id="L1997">    return encoding;</span>
  }

  /**
   * Default utility method to get exact zero value according to IValueMeta. Using
   * this utility method saves from ClassCastExceptions later.
   *
   * @param type
   * @return
   * @throws HopValueException
   */
  public static Object getZeroForValueMetaType( IValueMeta type ) throws HopValueException {
<span class="nc bnc" id="L2009" title="All 2 branches missed.">    if ( type == null ) {</span>
<span class="nc" id="L2010">      throw new HopValueException( &quot;API error. IValueMeta can't be null!&quot; );</span>
    }

<span class="nc bnc" id="L2013" title="All 5 branches missed.">    switch ( type.getType() ) {</span>
      case ( IValueMeta.TYPE_INTEGER ): {
<span class="nc" id="L2015">        return new Long( 0 );</span>
      }
      case ( IValueMeta.TYPE_NUMBER ): {
<span class="nc" id="L2018">        return new Double( 0 );</span>
      }
      case ( IValueMeta.TYPE_BIGNUMBER ): {
<span class="nc" id="L2021">        return new BigDecimal( 0 );</span>
      }
      case ( IValueMeta.TYPE_STRING ): {
<span class="nc" id="L2024">        return &quot;&quot;;</span>
      }
      default: {
<span class="nc" id="L2027">        throw new HopValueException( &quot;get zero function undefined for data type: &quot; + type.getType() );</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>