<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Database.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Hop Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.hop.core.database</a> &gt; <span class="el_source">Database.java</span></div><h1>Database.java</h1><pre class="source lang-java linenums">// CHECKSTYLE:FileLength:OFF
/*! ******************************************************************************
 *
 * Hop : The Hop Orchestration Platform
 *
 * http://www.project-hop.org
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.apache.hop.core.database;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.vfs2.FileObject;
import org.apache.hop.core.Const;
import org.apache.hop.core.Counter;
import org.apache.hop.core.DbCache;
import org.apache.hop.core.DbCacheEntry;
import org.apache.hop.core.IProgressMonitor;
import org.apache.hop.core.Result;
import org.apache.hop.core.RowMetaAndData;
import org.apache.hop.core.database.map.DatabaseConnectionMap;
import org.apache.hop.core.database.util.DatabaseLogExceptionFactory;
import org.apache.hop.core.encryption.Encr;
import org.apache.hop.core.exception.HopDatabaseBatchException;
import org.apache.hop.core.exception.HopDatabaseException;
import org.apache.hop.core.exception.HopException;
import org.apache.hop.core.exception.HopValueException;
import org.apache.hop.core.extension.ExtensionPointHandler;
import org.apache.hop.core.extension.HopExtensionPoint;
import org.apache.hop.core.logging.DefaultLogLevel;
import org.apache.hop.core.logging.ILoggingObject;
import org.apache.hop.core.logging.LogChannel;
import org.apache.hop.core.logging.ILogChannel;
import org.apache.hop.core.logging.LogLevel;
import org.apache.hop.core.logging.LogStatus;
import org.apache.hop.core.logging.ILogTableCore;
import org.apache.hop.core.logging.LogTableField;
import org.apache.hop.core.logging.LoggingObjectType;
import org.apache.hop.core.logging.Metrics;
import org.apache.hop.core.plugins.IPlugin;
import org.apache.hop.core.plugins.PluginRegistry;
import org.apache.hop.core.row.IRowMeta;
import org.apache.hop.core.row.IValueMeta;
import org.apache.hop.core.row.RowDataUtil;
import org.apache.hop.core.row.RowMeta;
import org.apache.hop.core.row.value.ValueMetaBase;
import org.apache.hop.core.row.value.ValueMetaBigNumber;
import org.apache.hop.core.row.value.ValueMetaBinary;
import org.apache.hop.core.row.value.ValueMetaBoolean;
import org.apache.hop.core.row.value.ValueMetaDate;
import org.apache.hop.core.row.value.ValueMetaFactory;
import org.apache.hop.core.row.value.ValueMetaInteger;
import org.apache.hop.core.row.value.ValueMetaInternetAddress;
import org.apache.hop.core.row.value.ValueMetaNone;
import org.apache.hop.core.row.value.ValueMetaNumber;
import org.apache.hop.core.row.value.ValueMetaString;
import org.apache.hop.core.row.value.ValueMetaTimestamp;
import org.apache.hop.core.util.Utils;
import org.apache.hop.core.variables.IVariables;
import org.apache.hop.core.variables.Variables;
import org.apache.hop.core.vfs.HopVfs;
import org.apache.hop.i18n.BaseMessages;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.BatchUpdateException;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Database handles the process of connecting to, reading from, writing to and updating databases. The database specific
 * parameters are defined in DatabaseInfo.
 *
 * @author Matt
 * @since 05-04-2003
 */
public class Database implements IVariables, ILoggingObject {
  /**
   * for i18n purposes, needed by Translator!!
   */
<span class="fc" id="L119">  private static final Class&lt;?&gt; PKG = Database.class;</span>

<span class="fc" id="L121">  private static final Map&lt;String, Set&lt;String&gt;&gt; registeredDrivers = new HashMap&lt;String, Set&lt;String&gt;&gt;();</span>

  private DatabaseMeta databaseMeta;

  private static final String DATA_SERVICES_PLUGIN_ID = &quot;HopThin&quot;;

  private int rowlimit;
  private int commitsize;

  private Connection connection;

  private Statement sel_stmt;
  private PreparedStatement pstmt;
  private PreparedStatement prepStatementLookup;
  private PreparedStatement prepStatementUpdate;
  private PreparedStatement prepStatementInsert;
  private PreparedStatement pstmt_seq;
  private CallableStatement cstmt;

  // private ResultSetMetaData rsmd;
  private DatabaseMetaData dbmd;

  private IRowMeta rowMeta;

  private int written;

  private ILogChannel log;
  private ILoggingObject parentLoggingObject;
<span class="fc" id="L149">  private static final String[] TABLE_TYPES_TO_GET = { &quot;TABLE&quot;, &quot;VIEW&quot; };</span>
  private static final String TABLES_META_DATA_TABLE_NAME = &quot;TABLE_NAME&quot;;

  /**
   * Number of times a connection was opened using this object. Only used in the context of a database connection map
   */
  private volatile int opened;

  /**
   * The copy is equal to opened at the time of creation.
   */
  private volatile int copy;

  private String connectionGroup;
  private String partitionId;

<span class="pc" id="L165">  private IVariables variables = new Variables();</span>

<span class="pc" id="L167">  private LogLevel logLevel = DefaultLogLevel.getLogLevel();</span>

  private String containerObjectId;

  private int nrExecutedCommits;

  private static List&lt;IValueMeta&gt; valueMetaPluginClasses;

  static {
    try {
<span class="fc" id="L177">      valueMetaPluginClasses = ValueMetaFactory.getValueMetaPluginClasses();</span>
<span class="fc" id="L178">      Collections.sort( valueMetaPluginClasses, ( o1, o2 ) -&gt; {</span>
        // Reverse the sort list
<span class="fc" id="L180">        return ( Integer.valueOf( o1.getType() ).compareTo( Integer.valueOf( o2.getType() ) ) ) * -1;</span>
      } );
<span class="nc" id="L182">    } catch ( Exception e ) {</span>
<span class="nc" id="L183">      throw new RuntimeException( &quot;Unable to get list of instantiated value meta plugin classes&quot;, e );</span>
<span class="fc" id="L184">    }</span>
<span class="fc" id="L185">  }</span>

  /**
   * Construct a new Database Connection
   *
   * @param databaseMeta The Database Connection Info to construct the connection with.
   * @deprecated Please specify the parent object so that we can see which object is initiating a database connection
   */
  @Deprecated
<span class="nc" id="L194">  public Database( DatabaseMeta databaseMeta ) {</span>
<span class="nc" id="L195">    this.parentLoggingObject = null;</span>
<span class="nc" id="L196">    this.databaseMeta = databaseMeta;</span>
<span class="nc" id="L197">    shareVariablesWith( databaseMeta );</span>

    // In this case we don't have the parent object, so we don't know which
    // object makes the connection.
    // We also don't know what log level to attach to it, so we have to stick to
    // the default
    // As such, this constructor is @deprecated.
    //
<span class="nc" id="L205">    log = new LogChannel( this );</span>
<span class="nc" id="L206">    logLevel = log.getLogLevel();</span>
<span class="nc" id="L207">    containerObjectId = log.getContainerObjectId();</span>

<span class="nc" id="L209">    pstmt = null;</span>
<span class="nc" id="L210">    rowMeta = null;</span>
<span class="nc" id="L211">    dbmd = null;</span>

<span class="nc" id="L213">    rowlimit = 0;</span>

<span class="nc" id="L215">    written = 0;</span>

<span class="nc" id="L217">    opened = copy = 0;</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L220">      log.logDetailed( &quot;New database connection defined&quot; );</span>
    }
<span class="nc" id="L222">  }</span>

  /**
   * Construct a new Database Connection
   *
   * @param databaseMeta The Database Connection Info to construct the connection with.
   */
<span class="fc" id="L229">  public Database( ILoggingObject parentObject, DatabaseMeta databaseMeta ) {</span>
<span class="fc" id="L230">    this.parentLoggingObject = parentObject;</span>
<span class="fc" id="L231">    this.databaseMeta = databaseMeta;</span>

<span class="fc" id="L233">    shareVariablesWith( databaseMeta );</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">    if ( parentObject instanceof IVariables ) {</span>
<span class="nc" id="L235">      shareVariablesWith( (IVariables) parentObject );</span>
    }

<span class="fc" id="L238">    log = new LogChannel( this, parentObject );</span>
<span class="fc" id="L239">    this.containerObjectId = log.getContainerObjectId();</span>
<span class="fc" id="L240">    this.logLevel = log.getLogLevel();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    if ( parentObject != null ) {</span>
<span class="fc" id="L242">      log.setGatheringMetrics( parentObject.isGatheringMetrics() );</span>
    }

<span class="fc" id="L245">    pstmt = null;</span>
<span class="fc" id="L246">    rowMeta = null;</span>
<span class="fc" id="L247">    dbmd = null;</span>

<span class="fc" id="L249">    rowlimit = 0;</span>

<span class="fc" id="L251">    written = 0;</span>

<span class="fc" id="L253">    opened = copy = 0;</span>

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L256">      log.logDetailed( &quot;New database connection defined&quot; );</span>
    }
<span class="fc" id="L258">  }</span>

  /**
   * This implementation is NullPointerException subject, and may not follow fundamental equals contract.
   * &lt;p/&gt;
   * Databases equality is based on {@link DatabaseMeta} equality.
   */
  @Override
  public boolean equals( Object obj ) {
<span class="nc" id="L267">    Database other = (Database) obj;</span>
<span class="nc" id="L268">    return this.databaseMeta.equals( other.databaseMeta );</span>
  }

  /**
   * Allows for the injection of a &quot;life&quot; connection, generated by a piece of software outside of Hop.
   *
   * @param connection
   */
  public void setConnection( Connection connection ) {
<span class="fc" id="L277">    this.connection = connection;</span>
<span class="fc" id="L278">  }</span>

  /**
   * @return Returns the connection.
   */
  public Connection getConnection() {
<span class="fc" id="L284">    return connection;</span>
  }

  /**
   * Set the maximum number of records to retrieve from a query.
   *
   * @param rows
   */
  public void setQueryLimit( int rows ) {
<span class="nc" id="L293">    rowlimit = rows;</span>
<span class="nc" id="L294">  }</span>

  /**
   * @return Returns the prepStatementInsert.
   */
  public PreparedStatement getPrepStatementInsert() {
<span class="nc" id="L300">    return prepStatementInsert;</span>
  }

  /**
   * @return Returns the prepStatementLookup.
   */
  public PreparedStatement getPrepStatementLookup() {
<span class="nc" id="L307">    return prepStatementLookup;</span>
  }

  /**
   * @return Returns the prepStatementUpdate.
   */
  public PreparedStatement getPrepStatementUpdate() {
<span class="nc" id="L314">    return prepStatementUpdate;</span>
  }

  /**
   * Open the database connection.
   *
   * @throws HopDatabaseException if something went wrong.
   */
  public void connect() throws HopDatabaseException {
<span class="fc" id="L323">    connect( null );</span>
<span class="fc" id="L324">  }</span>

  /**
   * Open the database connection.
   *
   * @param partitionId the partition ID in the cluster to connect to.
   * @throws HopDatabaseException if something went wrong.
   */
  public void connect( String partitionId ) throws HopDatabaseException {
<span class="fc" id="L333">    connect( null, partitionId );</span>
<span class="fc" id="L334">  }</span>

  public synchronized void connect( String group, String partitionId ) throws HopDatabaseException {
    try {

<span class="fc" id="L339">      log.snap( Metrics.METRIC_DATABASE_CONNECT_START, databaseMeta.getName() );</span>

      // Before anything else, let's see if we already have a connection defined
      // for this group/partition!
      // The group is called after the thread-name of the pipeline or workflow
      // that is running
      // The name of that thread name is expected to be unique (it is in Hop)
      // So the deal is that if there is another thread using that, we go for
      // it.
      //
<span class="fc bfc" id="L349" title="All 2 branches covered.">      if ( !Utils.isEmpty( group ) ) {</span>
<span class="fc" id="L350">        this.connectionGroup = group;</span>
<span class="fc" id="L351">        this.partitionId = partitionId;</span>

        // Try to find the connection for the group
<span class="fc" id="L354">        Database lookup = DatabaseConnectionMap.getInstance().getOrStoreIfAbsent( group, partitionId, this );</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if ( lookup == null ) {</span>
          // There was no mapped value before
<span class="fc" id="L357">          lookup = this;</span>
        }
<span class="fc" id="L359">        lookup.shareConnectionWith( partitionId, this );</span>
<span class="fc" id="L360">      } else {</span>
        // Proceed with a normal connect
<span class="fc" id="L362">        normalConnect( partitionId );</span>
      }

      try {
<span class="fc" id="L366">        ExtensionPointHandler.callExtensionPoint( log, HopExtensionPoint.DatabaseConnected.id, this );</span>
<span class="nc" id="L367">      } catch ( HopException e ) {</span>
<span class="nc" id="L368">        throw new HopDatabaseException( e );</span>
<span class="fc" id="L369">      }</span>

    } finally {
<span class="fc" id="L372">      log.snap( Metrics.METRIC_DATABASE_CONNECT_STOP, databaseMeta.getName() );</span>

    }
<span class="fc" id="L375">  }</span>

  private synchronized void shareConnectionWith( String partitionId, Database anotherDb )
    throws HopDatabaseException {
    // inside synchronized block we can increment 'opened' directly
<span class="fc" id="L380">    this.opened++;</span>

<span class="fc bfc" id="L382" title="All 2 branches covered.">    if ( this.connection == null ) {</span>
<span class="fc" id="L383">      normalConnect( partitionId );</span>
<span class="fc" id="L384">      this.copy = this.opened;</span>

      // If we have a connection group or transaction ID, disable auto commit!
      //
<span class="fc" id="L388">      setAutoCommit( false );</span>
    }

<span class="fc" id="L391">    anotherDb.connection = this.connection;</span>
<span class="fc" id="L392">    anotherDb.copy = this.opened;</span>
<span class="fc" id="L393">  }</span>

  /**
   * Open the database connection. The algorithm is:
   * &lt;ol&gt;
   * &lt;li&gt;If &lt;code&gt;databaseMeta.isUsingConnectionPool()&lt;/code&gt;, then the connection's datasource is looked up in the
   * pool&lt;/li&gt;
   * &lt;li&gt;otherwise, the connection is established via {@linkplain java.sql.DriverManager}&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @param partitionId the partition ID in the cluster to connect to.
   * @throws HopDatabaseException if something went wrong.
   */
  public void normalConnect( String partitionId ) throws HopDatabaseException {
<span class="nc bnc" id="L407" title="All 2 branches missed.">    if ( databaseMeta == null ) {</span>
<span class="nc" id="L408">      throw new HopDatabaseException( &quot;No valid database connection defined!&quot; );</span>
    }

    try {

      // Connect to the database
      //
<span class="nc" id="L415">      connectUsingClass( databaseMeta.getDriverClass(), partitionId );</span>

      // See if we need to execute extra SQL statements...
      //
<span class="nc" id="L419">      String sql = environmentSubstitute( databaseMeta.getConnectSql() );</span>

      // only execute if the SQL is not empty, null and is not just a bunch of
      // spaces, tabs, CR etc.
<span class="nc bnc" id="L423" title="All 4 branches missed.">      if ( !Utils.isEmpty( sql ) &amp;&amp; !Const.onlySpaces( sql ) ) {</span>
<span class="nc" id="L424">        execStatements( sql );</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L426">          log.logDetailed( &quot;Executed connect time SQL statements:&quot; + Const.CR + sql );</span>
        }
      }
<span class="nc" id="L429">    } catch ( Exception e ) {</span>
<span class="nc" id="L430">      throw new HopDatabaseException( &quot;Error occurred while trying to connect to the database&quot;, e );</span>
<span class="nc" id="L431">    }</span>
<span class="nc" id="L432">  }</span>

  /**
   * Connect using the correct classname
   *
   * @param classname for example &quot;org.gjt.mm.mysql.Driver&quot;
   * @return true if the connect was successful, false if something went wrong.
   */
  private void connectUsingClass( String classname, String partitionId ) throws HopDatabaseException {
    // Install and load the jdbc Driver
    IPlugin plugin =
<span class="nc" id="L443">      PluginRegistry.getInstance().getPlugin( DatabasePluginType.class, databaseMeta.getIDatabase() );</span>

    try {
<span class="nc" id="L446">      synchronized ( java.sql.DriverManager.class ) {</span>
<span class="nc" id="L447">        ClassLoader classLoader = PluginRegistry.getInstance().getClassLoader( plugin );</span>
<span class="nc" id="L448">        Class&lt;?&gt; driverClass = classLoader.loadClass( classname );</span>

        // Only need DelegatingDriver for drivers not from our classloader
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if ( driverClass.getClassLoader() != this.getClass().getClassLoader() ) {</span>
          String pluginId =
<span class="nc" id="L453">            PluginRegistry.getInstance().getPluginId( DatabasePluginType.class, databaseMeta.getIDatabase() );</span>
<span class="nc" id="L454">          Set&lt;String&gt; registeredDriversFromPlugin = registeredDrivers.get( pluginId );</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">          if ( registeredDriversFromPlugin == null ) {</span>
<span class="nc" id="L456">            registeredDriversFromPlugin = new HashSet&lt;String&gt;();</span>
<span class="nc" id="L457">            registeredDrivers.put( pluginId, registeredDriversFromPlugin );</span>
          }
          // Prevent registering multiple delegating drivers for same class, plugin
<span class="nc bnc" id="L460" title="All 2 branches missed.">          if ( !registeredDriversFromPlugin.contains( driverClass.getCanonicalName() ) ) {</span>
<span class="nc" id="L461">            DriverManager.registerDriver( new DelegatingDriver( (Driver) driverClass.newInstance() ) );</span>
<span class="nc" id="L462">            registeredDriversFromPlugin.add( driverClass.getCanonicalName() );</span>
          }
<span class="nc" id="L464">        } else {</span>
          // Trigger static register block in driver class
<span class="nc" id="L466">          Class.forName( classname );</span>
        }
<span class="nc" id="L468">      }</span>
<span class="nc" id="L469">    } catch ( NoClassDefFoundError | ClassNotFoundException e  ) {</span>
<span class="nc" id="L470">      throw new HopDatabaseException( BaseMessages.getString( PKG,</span>
<span class="nc" id="L471">        &quot;Database.Exception.UnableToFindClassMissingDriver&quot;, classname, plugin.getName() ), e );    </span>
<span class="nc" id="L472">    } catch ( Exception e ) {</span>
<span class="nc" id="L473">      throw new HopDatabaseException( &quot;Exception while loading class&quot;, e );</span>
<span class="nc" id="L474">    }</span>

    try {
<span class="nc" id="L477">      String url = environmentSubstitute( databaseMeta.getURL() );</span>

<span class="nc" id="L479">      String username = environmentSubstitute( databaseMeta.getUsername() );</span>
<span class="nc" id="L480">      String password = Encr.decryptPasswordOptionallyEncrypted( environmentSubstitute( databaseMeta.getPassword() ) );</span>

<span class="nc" id="L482">      Properties properties = databaseMeta.getConnectionProperties();</span>

<span class="nc bnc" id="L484" title="All 2 branches missed.">      if ( databaseMeta.supportsOptionsInURL() ) {</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">        if ( !Utils.isEmpty( username ) || !Utils.isEmpty( password ) ) {</span>
          // Allow for empty username with given password, in this case username must be given with one space
<span class="nc" id="L487">          properties.put( &quot;user&quot;, Const.NVL( username, &quot; &quot; ) );</span>
<span class="nc" id="L488">          properties.put( &quot;password&quot;, Const.NVL( password, &quot;&quot; ) );</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">          if ( databaseMeta.getIDatabase().isMsSqlServerNativeVariant() ) {</span>
            // Handle MSSQL Instance name. Would rather this was handled in the dialect
            // but cannot (without refactor) get to variablespace for variable substitution from
            // a BaseDatabaseMeta subclass.
<span class="nc" id="L493">            String instance = environmentSubstitute( databaseMeta.getSqlServerInstance() );</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            if ( !Utils.isEmpty( instance ) ) {</span>
<span class="nc" id="L495">              url += &quot;;instanceName=&quot; + instance;</span>
            }
          }
<span class="nc" id="L498">          connection = DriverManager.getConnection( url, properties );</span>
        } else {
          // Perhaps the username is in the URL or no username is required...
<span class="nc" id="L501">          connection = DriverManager.getConnection( url, properties );</span>
        }
      } else {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if ( !Utils.isEmpty( username ) ) {</span>
<span class="nc" id="L505">          properties.put( &quot;user&quot;, username );</span>
        }
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if ( !Utils.isEmpty( password ) ) {</span>
<span class="nc" id="L508">          properties.put( &quot;password&quot;, password );</span>
        }

<span class="nc" id="L511">        connection = DriverManager.getConnection( url, properties );</span>
      }
<span class="nc" id="L513">    } catch ( SQLException e ) {</span>
<span class="nc" id="L514">      throw new HopDatabaseException( &quot;Error connecting to database: (using class &quot; + classname + &quot;)&quot;, e );</span>
<span class="nc" id="L515">    } catch ( Throwable e ) {</span>
<span class="nc" id="L516">      throw new HopDatabaseException( &quot;Error connecting to database: (using class &quot; + classname + &quot;)&quot;, e );</span>
<span class="nc" id="L517">    }</span>
<span class="nc" id="L518">  }</span>

  /**
   * Disconnect from the database and close all open prepared statements.
   */
  public synchronized void disconnect() {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">    if ( connection == null ) {</span>
<span class="nc" id="L525">      return; // Nothing to do...</span>
    }
    try {
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">      if ( connection.isClosed() ) {</span>
<span class="nc" id="L529">        return; // Nothing to do...</span>
      }
<span class="nc" id="L531">    } catch ( SQLException ex ) {</span>
      // cannot do anything about this but log it
<span class="nc" id="L533">      log.logError( &quot;Error checking closing connection:&quot; + Const.CR + ex.getMessage() );</span>
<span class="nc" id="L534">      log.logError( Const.getStackTracker( ex ) );</span>
<span class="fc" id="L535">    }</span>

<span class="fc bfc" id="L537" title="All 2 branches covered.">    if ( pstmt != null ) {</span>
      try {
<span class="fc" id="L539">        pstmt.close();</span>
<span class="fc" id="L540">      } catch ( SQLException ex ) {</span>
        // cannot do anything about this but log it
<span class="fc" id="L542">        log.logError( &quot;Error closing statement:&quot; + Const.CR + ex.getMessage() );</span>
<span class="fc" id="L543">        log.logError( Const.getStackTracker( ex ) );</span>
<span class="fc" id="L544">      }</span>
<span class="fc" id="L545">      pstmt = null;</span>
    }
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">    if ( prepStatementLookup != null ) {</span>
      try {
<span class="nc" id="L549">        prepStatementLookup.close();</span>
<span class="nc" id="L550">      } catch ( SQLException ex ) {</span>
        // cannot do anything about this but log it
<span class="nc" id="L552">        log.logError( &quot;Error closing lookup statement:&quot; + Const.CR + ex.getMessage() );</span>
<span class="nc" id="L553">        log.logError( Const.getStackTracker( ex ) );</span>
<span class="nc" id="L554">      }</span>
<span class="nc" id="L555">      prepStatementLookup = null;</span>
    }
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">    if ( prepStatementInsert != null ) {</span>
      try {
<span class="nc" id="L559">        prepStatementInsert.close();</span>
<span class="nc" id="L560">      } catch ( SQLException ex ) {</span>
        // cannot do anything about this but log it
<span class="nc" id="L562">        log.logError( &quot;Error closing insert statement:&quot; + Const.CR + ex.getMessage() );</span>
<span class="nc" id="L563">        log.logError( Const.getStackTracker( ex ) );</span>
<span class="nc" id="L564">      }</span>
<span class="nc" id="L565">      prepStatementInsert = null;</span>
    }
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">    if ( prepStatementUpdate != null ) {</span>
      try {
<span class="nc" id="L569">        prepStatementUpdate.close();</span>
<span class="nc" id="L570">      } catch ( SQLException ex ) {</span>
        // cannot do anything about this but log it
<span class="nc" id="L572">        log.logError( &quot;Error closing update statement:&quot; + Const.CR + ex.getMessage() );</span>
<span class="nc" id="L573">        log.logError( Const.getStackTracker( ex ) );</span>
<span class="nc" id="L574">      }</span>
<span class="nc" id="L575">      prepStatementUpdate = null;</span>
    }
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">    if ( pstmt_seq != null ) {</span>
      try {
<span class="nc" id="L579">        pstmt_seq.close();</span>
<span class="nc" id="L580">      } catch ( SQLException ex ) {</span>
        // cannot do anything about this but log it
<span class="nc" id="L582">        log.logError( &quot;Error closing seq statement:&quot; + Const.CR + ex.getMessage() );</span>
<span class="nc" id="L583">        log.logError( Const.getStackTracker( ex ) );</span>
<span class="nc" id="L584">      }</span>
<span class="nc" id="L585">      pstmt_seq = null;</span>
    }

    // See if there are other transforms using this connection in a connection
    // group.
    // If so, we will hold commit &amp; connection close until then.
    //
<span class="fc bfc" id="L592" title="All 2 branches covered.">    if ( !Utils.isEmpty( connectionGroup ) ) {</span>
<span class="fc" id="L593">      return;</span>
    } else {
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">      if ( !isAutoCommit() ) {</span>
        // Do we really still need this commit??
        try {
<span class="fc" id="L598">          commit();</span>
<span class="nc" id="L599">        } catch ( HopDatabaseException ex ) {</span>
          // cannot do anything about this but log it
<span class="nc" id="L601">          log.logError( &quot;Error committing:&quot; + Const.CR + ex.getMessage() );</span>
<span class="nc" id="L602">          log.logError( Const.getStackTracker( ex ) );</span>
<span class="fc" id="L603">        }</span>
      }
    }
    try {
<span class="fc" id="L607">      ExtensionPointHandler.callExtensionPoint( log, HopExtensionPoint.DatabaseDisconnected.id, this );</span>
<span class="nc" id="L608">    } catch ( HopException e ) {</span>
<span class="nc" id="L609">      log.logError( &quot;Error disconnecting from database:&quot; + Const.CR + e.getMessage() );</span>
<span class="nc" id="L610">      log.logError( Const.getStackTracker( e ) );</span>
    } finally {
      // Always close the connection, irrespective of what happens above...
      try {
<span class="fc" id="L614">        closeConnectionOnly();</span>
<span class="nc" id="L615">      } catch ( HopDatabaseException ignoredKde ) { // The only exception thrown from closeConnectionOnly()</span>
        // cannot do anything about this but log it
<span class="nc" id="L617">        log.logError(</span>
<span class="nc" id="L618">          &quot;Error disconnecting from database - closeConnectionOnly failed:&quot; + Const.CR + ignoredKde.getMessage() );</span>
<span class="nc" id="L619">        log.logError( Const.getStackTracker( ignoredKde ) );</span>
<span class="fc" id="L620">      }</span>
    }
<span class="fc" id="L622">  }</span>

  /**
   * Only for unique connections usage, typically you use disconnect() to disconnect() from the database.
   *
   * @throws HopDatabaseException in case there is an error during connection close.
   */
  public synchronized void closeConnectionOnly() throws HopDatabaseException {
    try {
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">      if ( connection != null ) {</span>
<span class="fc" id="L632">        connection.close();</span>
<span class="fc" id="L633">        connection = null;</span>
      }

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">      if ( log.isDetailed() ) {</span>
<span class="nc" id="L637">        log.logDetailed( &quot;Connection to database closed!&quot; );</span>
      }
<span class="nc" id="L639">    } catch ( SQLException e ) {</span>
<span class="nc" id="L640">      throw new HopDatabaseException( &quot;Error disconnecting from database '&quot; + toString() + &quot;'&quot;, e );</span>
<span class="fc" id="L641">    }</span>
<span class="fc" id="L642">  }</span>

  /**
   * Cancel the open/running queries on the database connection
   *
   * @throws HopDatabaseException
   */
  public void cancelQuery() throws HopDatabaseException {
    // Canceling statements only if we're not streaming results on MySQL with
    // the v3 driver
    //
<span class="nc bnc" id="L653" title="All 2 branches missed.">    if ( databaseMeta.isMySqlVariant()</span>
<span class="nc bnc" id="L654" title="All 4 branches missed.">      &amp;&amp; databaseMeta.isStreamingResults() &amp;&amp; getDatabaseMetaData().getDriverMajorVersion() == 3 ) {</span>
<span class="nc" id="L655">      return;</span>
    }

<span class="nc" id="L658">    cancelStatement( pstmt );</span>
<span class="nc" id="L659">    cancelStatement( sel_stmt );</span>
<span class="nc" id="L660">  }</span>

  /**
   * Cancel an open/running SQL statement
   *
   * @param statement the statement to cancel
   * @throws HopDatabaseException
   */
  public void cancelStatement( Statement statement ) throws HopDatabaseException {
    try {
<span class="nc bnc" id="L670" title="All 2 branches missed.">      if ( statement != null ) {</span>
<span class="nc" id="L671">        statement.cancel();</span>
      }
<span class="nc bnc" id="L673" title="All 2 branches missed.">      if ( log.isDebug() ) {</span>
<span class="nc" id="L674">        log.logDebug( &quot;Statement canceled!&quot; );</span>
      }
<span class="nc" id="L676">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L677">      throw new HopDatabaseException( &quot;Error cancelling statement&quot;, ex );</span>
<span class="nc" id="L678">    }</span>
<span class="nc" id="L679">  }</span>

  /**
   * Specify after how many rows a commit needs to occur when inserting or updating values.
   *
   * @param commsize The number of rows to wait before doing a commit on the connection.
   */
  public void setCommit( int commsize ) {
<span class="fc" id="L687">    commitsize = commsize;</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">    String onOff = ( commitsize &lt;= 0 ? &quot;on&quot; : &quot;off&quot; );</span>
    try {
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">      connection.setAutoCommit( commitsize &lt;= 0 );</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">      if ( log.isDetailed() ) {</span>
<span class="nc" id="L692">        log.logDetailed( &quot;Auto commit &quot; + onOff );</span>
      }
<span class="fc" id="L694">    } catch ( Exception e ) {</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">      if ( log.isDebug() ) {</span>
<span class="nc" id="L696">        log.logDebug( &quot;Can't turn auto commit &quot; + onOff + Const.CR + Const.getSimpleStackTrace( e ) + Const.CR + Const.getStackTracker( e ) );</span>
      }
<span class="fc" id="L698">    }</span>
<span class="fc" id="L699">  }</span>

  public void setAutoCommit( boolean useAutoCommit ) throws HopDatabaseException {
    try {
<span class="fc" id="L703">      connection.setAutoCommit( useAutoCommit );</span>
<span class="nc" id="L704">    } catch ( SQLException e ) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">      if ( useAutoCommit ) {</span>
<span class="nc" id="L706">        throw new HopDatabaseException( BaseMessages.getString(</span>
<span class="nc" id="L707">          PKG, &quot;Database.Exception.UnableToEnableAutoCommit&quot;, toString() ) );</span>
      } else {
<span class="nc" id="L709">        throw new HopDatabaseException( BaseMessages.getString(</span>
<span class="nc" id="L710">          PKG, &quot;Database.Exception.UnableToDisableAutoCommit&quot;, toString() ) );</span>
      }

<span class="fc" id="L713">    }</span>
<span class="fc" id="L714">  }</span>

  /**
   * Perform a commit the connection if this is supported by the database
   */
  public void commit() throws HopDatabaseException {
<span class="fc" id="L720">    commit( false );</span>
<span class="fc" id="L721">  }</span>

  public void commit( boolean force ) throws HopDatabaseException {
    try {
      // Don't do the commit, wait until the end of the pipeline.
      // When the last database copy (opened counter) is about to be closed, we
      // do a commit
      // There is one catch, we need to catch the rollback
      // The pipeline will stop everything and then we'll do the rollback.
      // The flag is in &quot;performRollback&quot;, private only
      //
<span class="pc bpc" id="L732" title="3 of 4 branches missed.">      if ( !Utils.isEmpty( connectionGroup ) &amp;&amp; !force ) {</span>
<span class="nc" id="L733">        return;</span>
      }
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">      if ( getDatabaseMetaData().supportsTransactions() ) {</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if ( log.isDebug() ) {</span>
<span class="nc" id="L737">          log.logDebug( &quot;Commit on database connection [&quot; + toString() + &quot;]&quot; );</span>
        }
<span class="nc" id="L739">        connection.commit();</span>
<span class="nc" id="L740">        nrExecutedCommits++;</span>
      } else {
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L743">          log.logDetailed( &quot;No commit possible on database connection [&quot; + toString() + &quot;]&quot; );</span>
        }
      }
<span class="nc" id="L746">    } catch ( Exception e ) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">      if ( databaseMeta.supportsEmptyTransactions() ) {</span>
<span class="nc" id="L748">        throw new HopDatabaseException( &quot;Error comitting connection&quot;, e );</span>
      }
<span class="fc" id="L750">    }</span>
<span class="fc" id="L751">  }</span>

  /**
   * This methods may be removed in future.
   *
   * @param logTable
   * @throws HopDatabaseException
   */
  public void commitLog( ILogTableCore logTable ) throws HopDatabaseException {
<span class="nc" id="L760">    this.commitLog( false, logTable );</span>
<span class="nc" id="L761">  }</span>

  /**
   * This methods may be removed in future.
   *
   * @param force
   * @param logTable
   * @throws HopDatabaseException
   */
  public void commitLog( boolean force, ILogTableCore logTable ) throws HopDatabaseException {
    try {
<span class="nc" id="L772">      commitInternal( force );</span>
<span class="nc" id="L773">    } catch ( Exception e ) {</span>
<span class="nc" id="L774">      DatabaseLogExceptionFactory.getExceptionStrategy( logTable )</span>
<span class="nc" id="L775">        .registerException( log, e, PKG, &quot;Database.Error.UnableToCommitToLogTable&quot;,</span>
<span class="nc" id="L776">          logTable.getActualTableName() );</span>
<span class="nc" id="L777">    }</span>
<span class="nc" id="L778">  }</span>

  /**
   * this is a copy of {@link #commit(boolean)} - but delegates exception handling to caller. Can be possibly be removed
   * in future.
   *
   * @param force
   * @throws HopDatabaseException
   * @throws SQLException
   */
  @Deprecated
  private void commitInternal( boolean force ) throws HopDatabaseException, SQLException {
<span class="nc bnc" id="L790" title="All 4 branches missed.">    if ( !Utils.isEmpty( connectionGroup ) &amp;&amp; !force ) {</span>
<span class="nc" id="L791">      return;</span>
    }
<span class="nc bnc" id="L793" title="All 2 branches missed.">    if ( getDatabaseMetaData().supportsTransactions() ) {</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">      if ( log.isDebug() ) {</span>
<span class="nc" id="L795">        log.logDebug( &quot;Commit on database connection [&quot; + toString() + &quot;]&quot; );</span>
      }
<span class="nc" id="L797">      connection.commit();</span>
<span class="nc" id="L798">      nrExecutedCommits++;</span>
    } else {
<span class="nc bnc" id="L800" title="All 2 branches missed.">      if ( log.isDetailed() ) {</span>
<span class="nc" id="L801">        log.logDetailed( &quot;No commit possible on database connection [&quot; + toString() + &quot;]&quot; );</span>
      }
    }
<span class="nc" id="L804">  }</span>

  public void rollback() throws HopDatabaseException {
<span class="nc" id="L807">    rollback( false );</span>
<span class="nc" id="L808">  }</span>

  public void rollback( boolean force ) throws HopDatabaseException {
    try {
<span class="nc bnc" id="L812" title="All 4 branches missed.">      if ( !Utils.isEmpty( connectionGroup ) &amp;&amp; !force ) {</span>
<span class="nc" id="L813">        return; // Will be handled by Pipeline --&gt; endProcessing()</span>
      }
<span class="nc bnc" id="L815" title="All 2 branches missed.">      if ( getDatabaseMetaData().supportsTransactions() ) {</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if ( connection != null ) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L818">            log.logDebug( &quot;Rollback on database connection [&quot; + toString() + &quot;]&quot; );</span>
          }
<span class="nc" id="L820">          connection.rollback();</span>
        }
      } else {
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L824">          log.logDetailed( &quot;No rollback possible on database connection [&quot; + toString() + &quot;]&quot; );</span>
        }
      }

<span class="nc" id="L828">    } catch ( SQLException e ) {</span>
<span class="nc" id="L829">      throw new HopDatabaseException( &quot;Error performing rollback on connection&quot;, e );</span>
<span class="nc" id="L830">    }</span>
<span class="nc" id="L831">  }</span>

  /**
   * Prepare inserting values into a table, using the fields &amp; values in a Row
   *
   * @param rowMeta   The row metadata to determine which values need to be inserted
   * @param tableName The name of the table in which we want to insert rows
   * @throws HopDatabaseException if something went wrong.
   */
  public void prepareInsert( IRowMeta rowMeta, String tableName ) throws HopDatabaseException {
<span class="nc" id="L841">    prepareInsert( rowMeta, null, tableName );</span>
<span class="nc" id="L842">  }</span>

  /**
   * Prepare inserting values into a table, using the fields &amp; values in a Row
   *
   * @param rowMeta    The metadata row to determine which values need to be inserted
   * @param schemaName The name of the schema in which we want to insert rows
   * @param tableName  The name of the table in which we want to insert rows
   * @throws HopDatabaseException if something went wrong.
   */
  public void prepareInsert( IRowMeta rowMeta, String schemaName, String tableName )
    throws HopDatabaseException {
<span class="nc bnc" id="L854" title="All 2 branches missed.">    if ( rowMeta.size() == 0 ) {</span>
<span class="nc" id="L855">      throw new HopDatabaseException( &quot;No fields in row, can't insert!&quot; );</span>
    }

<span class="nc" id="L858">    String ins = getInsertStatement( schemaName, tableName, rowMeta );</span>

<span class="nc bnc" id="L860" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L861">      log.logDetailed( &quot;Preparing statement: &quot; + Const.CR + ins );</span>
    }
<span class="nc" id="L863">    prepStatementInsert = prepareSql( ins );</span>
<span class="nc" id="L864">  }</span>

  /**
   * Prepare a statement to be executed on the database. (does not return generated keys)
   *
   * @param sql The SQL to be prepared
   * @return The PreparedStatement object.
   * @throws HopDatabaseException
   */
  public PreparedStatement prepareSql(String sql ) throws HopDatabaseException {
<span class="fc" id="L874">    return prepareSql( sql, false );</span>
  }

  /**
   * Prepare a statement to be executed on the database.
   *
   * @param sql        The SQL to be prepared
   * @param returnKeys set to true if you want to return generated keys from an insert statement
   * @return The PreparedStatement object.
   * @throws HopDatabaseException
   */
  public PreparedStatement prepareSql(String sql, boolean returnKeys ) throws HopDatabaseException {
<span class="fc" id="L886">    IDatabase iDatabase = databaseMeta.getIDatabase();</span>
<span class="fc" id="L887">    boolean supportsAutoGeneratedKeys = iDatabase.supportsAutoGeneratedKeys();</span>

    try {
<span class="pc bpc" id="L890" title="1 of 4 branches missed.">      if ( returnKeys &amp;&amp; supportsAutoGeneratedKeys ) {</span>
<span class="nc" id="L891">        return connection.prepareStatement( databaseMeta.stripCR( sql ), Statement.RETURN_GENERATED_KEYS );</span>
      } else {
<span class="fc" id="L893">        return connection.prepareStatement( databaseMeta.stripCR( sql ) );</span>
      }
<span class="nc" id="L895">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L896">      throw new HopDatabaseException( &quot;Couldn't prepare statement:&quot; + Const.CR + sql, ex );</span>
    }
  }

  public void closeLookup() throws HopDatabaseException {
<span class="nc" id="L901">    closePreparedStatement( pstmt );</span>
<span class="nc" id="L902">    pstmt = null;</span>
<span class="nc" id="L903">  }</span>

  public void closePreparedStatement( PreparedStatement ps ) throws HopDatabaseException {
<span class="nc bnc" id="L906" title="All 2 branches missed.">    if ( ps != null ) {</span>
      try {
<span class="nc" id="L908">        ps.close();</span>
<span class="nc" id="L909">      } catch ( SQLException e ) {</span>
<span class="nc" id="L910">        throw new HopDatabaseException( &quot;Error closing prepared statement&quot;, e );</span>
<span class="nc" id="L911">      }</span>
    }
<span class="nc" id="L913">  }</span>

  public void closeInsert() throws HopDatabaseException {
<span class="nc bnc" id="L916" title="All 2 branches missed.">    if ( prepStatementInsert != null ) {</span>
      try {
<span class="nc" id="L918">        prepStatementInsert.close();</span>
<span class="nc" id="L919">        prepStatementInsert = null;</span>
<span class="nc" id="L920">      } catch ( SQLException e ) {</span>
<span class="nc" id="L921">        throw new HopDatabaseException( &quot;Error closing insert prepared statement.&quot;, e );</span>
<span class="nc" id="L922">      }</span>
    }
<span class="nc" id="L924">  }</span>

  public void closeUpdate() throws HopDatabaseException {
<span class="nc bnc" id="L927" title="All 2 branches missed.">    if ( prepStatementUpdate != null ) {</span>
      try {
<span class="nc" id="L929">        prepStatementUpdate.close();</span>
<span class="nc" id="L930">        prepStatementUpdate = null;</span>
<span class="nc" id="L931">      } catch ( SQLException e ) {</span>
<span class="nc" id="L932">        throw new HopDatabaseException( &quot;Error closing update prepared statement.&quot;, e );</span>
<span class="nc" id="L933">      }</span>
    }
<span class="nc" id="L935">  }</span>

  public void setValues( IRowMeta rowMeta, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L938">    setValues( rowMeta, data, pstmt );</span>
<span class="nc" id="L939">  }</span>

  public void setValues( RowMetaAndData row ) throws HopDatabaseException {
<span class="nc" id="L942">    setValues( row.getRowMeta(), row.getData() );</span>
<span class="nc" id="L943">  }</span>

  public void setValuesInsert( IRowMeta rowMeta, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L946">    setValues( rowMeta, data, prepStatementInsert );</span>
<span class="nc" id="L947">  }</span>

  public void setValuesInsert( RowMetaAndData row ) throws HopDatabaseException {
<span class="nc" id="L950">    setValues( row.getRowMeta(), row.getData(), prepStatementInsert );</span>
<span class="nc" id="L951">  }</span>

  public void setValuesUpdate( IRowMeta rowMeta, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L954">    setValues( rowMeta, data, prepStatementUpdate );</span>
<span class="nc" id="L955">  }</span>

  public void setValuesLookup( IRowMeta rowMeta, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L958">    setValues( rowMeta, data, prepStatementLookup );</span>
<span class="nc" id="L959">  }</span>

  public void setProcValues( IRowMeta rowMeta, Object[] data, int[] argnrs, String[] argdir, boolean result )
    throws HopDatabaseException {
    int pos;

<span class="nc bnc" id="L965" title="All 2 branches missed.">    if ( result ) {</span>
<span class="nc" id="L966">      pos = 2;</span>
    } else {
<span class="nc" id="L968">      pos = 1;</span>
    }

<span class="nc bnc" id="L971" title="All 2 branches missed.">    for ( int i = 0; i &lt; argnrs.length; i++ ) {</span>
<span class="nc bnc" id="L972" title="All 4 branches missed.">      if ( argdir[ i ].equalsIgnoreCase( &quot;IN&quot; ) || argdir[ i ].equalsIgnoreCase( &quot;INOUT&quot; ) ) {</span>
<span class="nc" id="L973">        IValueMeta valueMeta = rowMeta.getValueMeta( argnrs[ i ] );</span>
<span class="nc" id="L974">        Object value = data[ argnrs[ i ] ];</span>

<span class="nc" id="L976">        setValue( cstmt, valueMeta, value, pos );</span>
<span class="nc" id="L977">        pos++;</span>
<span class="nc" id="L978">      } else {</span>
<span class="nc" id="L979">        pos++; // next parameter when OUT</span>
      }
    }
<span class="nc" id="L982">  }</span>

  public void setValue( PreparedStatement ps, IValueMeta v, Object object, int pos )
    throws HopDatabaseException {

<span class="nc" id="L987">    v.setPreparedStatementValue( databaseMeta, ps, pos, object );</span>

<span class="nc" id="L989">  }</span>

  public void setValues( RowMetaAndData row, PreparedStatement ps ) throws HopDatabaseException {
<span class="nc" id="L992">    setValues( row.getRowMeta(), row.getData(), ps );</span>
<span class="nc" id="L993">  }</span>

  public void setValues( IRowMeta rowMeta, Object[] data, PreparedStatement ps )
    throws HopDatabaseException {
    // now set the values in the row!
<span class="nc bnc" id="L998" title="All 2 branches missed.">    for ( int i = 0; i &lt; rowMeta.size(); i++ ) {</span>
<span class="nc" id="L999">      IValueMeta v = rowMeta.getValueMeta( i );</span>
<span class="nc" id="L1000">      Object object = data[ i ];</span>

      try {
<span class="nc" id="L1003">        setValue( ps, v, object, i + 1 );</span>
<span class="nc" id="L1004">      } catch ( HopDatabaseException e ) {</span>
<span class="nc" id="L1005">        throw new HopDatabaseException( &quot;offending row : &quot; + rowMeta, e );</span>
<span class="nc" id="L1006">      }</span>
    }
<span class="nc" id="L1008">  }</span>

  /**
   * Sets the values of the preparedStatement pstmt.
   *
   * @param rowMeta
   * @param data
   */
  public void setValues( IRowMeta rowMeta, Object[] data, PreparedStatement ps, int ignoreThisValueIndex )
    throws HopDatabaseException {
    // now set the values in the row!
<span class="nc" id="L1019">    int index = 0;</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">    for ( int i = 0; i &lt; rowMeta.size(); i++ ) {</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">      if ( i != ignoreThisValueIndex ) {</span>
<span class="nc" id="L1022">        IValueMeta v = rowMeta.getValueMeta( i );</span>
<span class="nc" id="L1023">        Object object = data[ i ];</span>

        try {
<span class="nc" id="L1026">          setValue( ps, v, object, index + 1 );</span>
<span class="nc" id="L1027">          index++;</span>
<span class="nc" id="L1028">        } catch ( HopDatabaseException e ) {</span>
<span class="nc" id="L1029">          throw new HopDatabaseException( &quot;offending row : &quot; + rowMeta, e );</span>
<span class="nc" id="L1030">        }</span>
      }
    }
<span class="nc" id="L1033">  }</span>

  /**
   * @param ps The prepared insert statement to use
   * @return The generated keys in auto-increment fields
   * @throws HopDatabaseException in case something goes wrong retrieving the keys.
   */
  public RowMetaAndData getGeneratedKeys( PreparedStatement ps ) throws HopDatabaseException {
<span class="nc" id="L1041">    ResultSet keys = null;</span>
    try {
<span class="nc" id="L1043">      keys = ps.getGeneratedKeys(); // 1 row of keys</span>
<span class="nc" id="L1044">      ResultSetMetaData resultSetMetaData = keys.getMetaData();</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">      if ( resultSetMetaData == null ) {</span>
<span class="nc" id="L1046">        resultSetMetaData = ps.getMetaData();</span>
      }
      IRowMeta rowMeta;
<span class="nc bnc" id="L1049" title="All 2 branches missed.">      if ( resultSetMetaData == null ) {</span>
<span class="nc" id="L1050">        rowMeta = new RowMeta();</span>
<span class="nc" id="L1051">        rowMeta.addValueMeta( new ValueMetaInteger( &quot;ai-key&quot; ) );</span>
      } else {
<span class="nc" id="L1053">        rowMeta = getRowInfo( resultSetMetaData, false, false );</span>
      }

<span class="nc" id="L1056">      return new RowMetaAndData( rowMeta, getRow( keys, resultSetMetaData, rowMeta ) );</span>
<span class="nc" id="L1057">    } catch ( Exception ex ) {</span>
<span class="nc" id="L1058">      throw new HopDatabaseException( &quot;Unable to retrieve key(s) from auto-increment field(s)&quot;, ex );</span>
    } finally {
<span class="nc bnc" id="L1060" title="All 2 branches missed.">      if ( keys != null ) {</span>
        try {
<span class="nc" id="L1062">          keys.close();</span>
<span class="nc" id="L1063">        } catch ( SQLException e ) {</span>
<span class="nc" id="L1064">          throw new HopDatabaseException( &quot;Unable to close resultset of auto-generated keys&quot;, e );</span>
<span class="nc" id="L1065">        }</span>
      }
    }
  }

  public Long getNextSequenceValue( String sequenceName, String keyfield ) throws HopDatabaseException {
<span class="nc" id="L1071">    return getNextSequenceValue( null, sequenceName, keyfield );</span>
  }

  public Long getNextSequenceValue( String schemaName, String sequenceName, String keyfield )
    throws HopDatabaseException {
<span class="nc" id="L1076">    Long retval = null;</span>

<span class="nc" id="L1078">    String schemaSequence = databaseMeta.getQuotedSchemaTableCombination( schemaName, sequenceName );</span>

    try {
<span class="nc bnc" id="L1081" title="All 2 branches missed.">      if ( pstmt_seq == null ) {</span>
<span class="nc" id="L1082">        pstmt_seq =</span>
<span class="nc" id="L1083">          connection.prepareStatement( databaseMeta.getSeqNextvalSql( databaseMeta.stripCR( schemaSequence ) ) );</span>
      }
<span class="nc" id="L1085">      ResultSet rs = null;</span>
      try {
<span class="nc" id="L1087">        rs = pstmt_seq.executeQuery();</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        if ( rs.next() ) {</span>
<span class="nc" id="L1089">          retval = Long.valueOf( rs.getLong( 1 ) );</span>
        }
      } finally {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if ( rs != null ) {</span>
<span class="nc" id="L1093">          rs.close();</span>
        }
      }
<span class="nc" id="L1096">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L1097">      throw new HopDatabaseException( &quot;Unable to get next value for sequence : &quot; + schemaSequence, ex );</span>
<span class="nc" id="L1098">    }</span>

<span class="nc" id="L1100">    return retval;</span>
  }

  public void insertRow( String tableName, IRowMeta fields, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L1104">    insertRow( null, tableName, fields, data );</span>
<span class="nc" id="L1105">  }</span>

  public void insertRow( String schemaName, String tableName, IRowMeta fields, Object[] data )
    throws HopDatabaseException {
<span class="nc" id="L1109">    prepareInsert( fields, schemaName, tableName );</span>
<span class="nc" id="L1110">    setValuesInsert( fields, data );</span>
<span class="nc" id="L1111">    insertRow();</span>
<span class="nc" id="L1112">    closeInsert();</span>
<span class="nc" id="L1113">  }</span>

  public String getInsertStatement( String tableName, IRowMeta fields ) {
<span class="nc" id="L1116">    return getInsertStatement( null, tableName, fields );</span>
  }

  public String getInsertStatement( String schemaName, String tableName, IRowMeta fields ) {
<span class="nc" id="L1120">    StringBuilder ins = new StringBuilder( 128 );</span>

<span class="nc" id="L1122">    String schemaTable = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>
<span class="nc" id="L1123">    ins.append( &quot;INSERT INTO &quot; ).append( schemaTable ).append( &quot; (&quot; );</span>

    // now add the names in the row:
<span class="nc bnc" id="L1126" title="All 2 branches missed.">    for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">      if ( i &gt; 0 ) {</span>
<span class="nc" id="L1128">        ins.append( &quot;, &quot; );</span>
      }
<span class="nc" id="L1130">      String name = fields.getValueMeta( i ).getName();</span>
<span class="nc" id="L1131">      ins.append( databaseMeta.quoteField( name ) );</span>
    }
<span class="nc" id="L1133">    ins.append( &quot;) VALUES (&quot; );</span>

    // Add placeholders...
<span class="nc bnc" id="L1136" title="All 2 branches missed.">    for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">      if ( i &gt; 0 ) {</span>
<span class="nc" id="L1138">        ins.append( &quot;, &quot; );</span>
      }
<span class="nc" id="L1140">      ins.append( &quot; ?&quot; );</span>
    }
<span class="nc" id="L1142">    ins.append( ')' );</span>

<span class="nc" id="L1144">    return ins.toString();</span>
  }

  public void insertRow() throws HopDatabaseException {
<span class="nc" id="L1148">    insertRow( prepStatementInsert );</span>
<span class="nc" id="L1149">  }</span>

  public void insertRow( boolean batch ) throws HopDatabaseException {
<span class="nc" id="L1152">    insertRow( prepStatementInsert, batch );</span>
<span class="nc" id="L1153">  }</span>

  public void updateRow() throws HopDatabaseException {
<span class="nc" id="L1156">    insertRow( prepStatementUpdate );</span>
<span class="nc" id="L1157">  }</span>

  public void insertRow( PreparedStatement ps ) throws HopDatabaseException {
<span class="nc" id="L1160">    insertRow( ps, false );</span>
<span class="nc" id="L1161">  }</span>

  /**
   * Insert a row into the database using a prepared statement that has all values set.
   *
   * @param ps    The prepared statement
   * @param batch True if you want to use batch inserts (size = commit size)
   * @return true if the rows are safe: if batch of rows was sent to the database OR if a commit was done.
   * @throws HopDatabaseException
   */
  public boolean insertRow( PreparedStatement ps, boolean batch ) throws HopDatabaseException {
<span class="nc" id="L1172">    return insertRow( ps, batch, true );</span>
  }

  public boolean getUseBatchInsert( boolean batch ) throws HopDatabaseException {
    try {
<span class="pc bpc" id="L1177" title="2 of 6 branches missed.">      return batch &amp;&amp; getDatabaseMetaData().supportsBatchUpdates() &amp;&amp; databaseMeta.supportsBatchUpdates()</span>
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">        &amp;&amp; Utils.isEmpty( connectionGroup );</span>
<span class="nc" id="L1179">    } catch ( SQLException e ) {</span>
<span class="nc" id="L1180">      throw createHopDatabaseBatchException( &quot;Error determining whether to use batch&quot;, e );</span>
    }
  }

  /**
   * Insert a row into the database using a prepared statement that has all values set.
   *
   * @param ps           The prepared statement
   * @param batch        True if you want to use batch inserts (size = commit size)
   * @param handleCommit True if you want to handle the commit here after the commit size (False e.g. in case the transform
   *                     handles this, see TableOutput)
   * @return true if the rows are safe: if batch of rows was sent to the database OR if a commit was done.
   * @throws HopDatabaseException
   */
  public boolean insertRow( PreparedStatement ps, boolean batch, boolean handleCommit ) throws HopDatabaseException {
<span class="fc" id="L1195">    String debug = &quot;insertRow start&quot;;</span>
<span class="fc" id="L1196">    boolean rowsAreSafe = false;</span>
<span class="fc" id="L1197">    boolean isBatchUpdate = false;</span>

    try {
      // Unique connections and Batch inserts don't mix when you want to roll
      // back on certain databases.
      // That's why we disable the batch insert in that case.
      //
<span class="fc" id="L1204">      boolean useBatchInsert = getUseBatchInsert( batch );</span>

      //
      // Add support for batch inserts...
      //
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">      if ( !isAutoCommit() ) {</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        if ( useBatchInsert ) {</span>
<span class="fc" id="L1211">          debug = &quot;insertRow add batch&quot;;</span>
<span class="fc" id="L1212">          ps.addBatch(); // Add the batch, but don't forget to run the batch</span>
        } else {
<span class="fc" id="L1214">          debug = &quot;insertRow exec update&quot;;</span>
<span class="fc" id="L1215">          ps.executeUpdate();</span>
        }
      } else {
<span class="nc" id="L1218">        ps.executeUpdate();</span>
      }

<span class="fc" id="L1221">      written++;</span>

<span class="fc bfc" id="L1223" title="All 2 branches covered.">      if ( handleCommit ) { // some transforms handle the commit themselves (see e.g.</span>
        // TableOutput transform)
<span class="pc bpc" id="L1225" title="2 of 4 branches missed.">        if ( !isAutoCommit() &amp;&amp; ( written % commitsize ) == 0 ) {</span>
<span class="pc bpc" id="L1226" title="1 of 2 branches missed.">          if ( useBatchInsert ) {</span>
<span class="fc" id="L1227">            isBatchUpdate = true;</span>
<span class="fc" id="L1228">            debug = &quot;insertRow executeBatch commit&quot;;</span>
<span class="nc" id="L1229">            ps.executeBatch();</span>
<span class="nc" id="L1230">            commit();</span>
<span class="nc" id="L1231">            ps.clearBatch();</span>
          } else {
<span class="nc" id="L1233">            debug = &quot;insertRow normal commit&quot;;</span>
<span class="nc" id="L1234">            commit();</span>
          }
<span class="nc" id="L1236">          written = 0;</span>
<span class="nc" id="L1237">          rowsAreSafe = true;</span>
        }
      }

<span class="fc" id="L1241">      return rowsAreSafe;</span>
<span class="nc" id="L1242">    } catch ( BatchUpdateException ex ) {</span>
<span class="nc" id="L1243">      throw createHopDatabaseBatchException( &quot;Error updating batch&quot;, ex );</span>
<span class="fc" id="L1244">    } catch ( SQLException ex ) {</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">      if ( isBatchUpdate ) {</span>
<span class="fc" id="L1246">        throw createHopDatabaseBatchException( &quot;Error updating batch&quot;, ex );</span>
      } else {
<span class="fc" id="L1248">        throw new HopDatabaseException( &quot;Error inserting/updating row&quot;, ex );</span>
      }
<span class="nc" id="L1250">    } catch ( Exception e ) {</span>
<span class="nc" id="L1251">      throw new HopDatabaseException( &quot;Unexpected error inserting/updating row in part [&quot; + debug + &quot;]&quot;, e );</span>
    }
  }

  /**
   * Clears batch of insert prepared statement
   *
   * @throws HopDatabaseException
   * @deprecated
   */
  @Deprecated
  public void clearInsertBatch() throws HopDatabaseException {
<span class="nc" id="L1263">    clearBatch( prepStatementInsert );</span>
<span class="nc" id="L1264">  }</span>

  public void clearBatch( PreparedStatement preparedStatement ) throws HopDatabaseException {
    try {
<span class="nc" id="L1268">      preparedStatement.clearBatch();</span>
<span class="nc" id="L1269">    } catch ( SQLException e ) {</span>
<span class="nc" id="L1270">      throw new HopDatabaseException( &quot;Unable to clear batch for prepared statement&quot;, e );</span>
<span class="nc" id="L1271">    }</span>
<span class="nc" id="L1272">  }</span>

  public void executeAndClearBatch( PreparedStatement preparedStatement ) throws HopDatabaseException {
    try {
<span class="pc bpc" id="L1276" title="2 of 4 branches missed.">      if ( written &gt; 0 &amp;&amp; getDatabaseMetaData().supportsBatchUpdates() ) {</span>
<span class="fc" id="L1277">        preparedStatement.executeBatch();</span>
      }

<span class="fc" id="L1280">      written = 0;</span>
<span class="fc" id="L1281">      preparedStatement.clearBatch();</span>
<span class="nc" id="L1282">    } catch ( SQLException e ) {</span>
<span class="nc" id="L1283">      throw new HopDatabaseException( &quot;Unable to clear batch for prepared statement&quot;, e );</span>
<span class="fc" id="L1284">    }</span>
<span class="fc" id="L1285">  }</span>

  public void insertFinished( boolean batch ) throws HopDatabaseException {
<span class="nc" id="L1288">    insertFinished( prepStatementInsert, batch );</span>
<span class="nc" id="L1289">    prepStatementInsert = null;</span>
<span class="nc" id="L1290">  }</span>

  /**
   * Close the passed prepared statement. This object's &quot;written&quot; property is passed to the method that does the execute
   * and commit.
   *
   * @param ps
   * @param batch
   * @throws HopDatabaseException
   */
  public void emptyAndCommit( PreparedStatement ps, boolean batch ) throws HopDatabaseException {
<span class="nc" id="L1301">    emptyAndCommit( ps, batch, written );</span>
<span class="nc" id="L1302">  }</span>

  /**
   * Close the prepared statement of the insert statement.
   *
   * @param ps           The prepared statement to empty and close.
   * @param batch        true if you are using batch processing
   * @param batchCounter The number of rows on the batch queue
   * @throws HopDatabaseException
   */
  public void emptyAndCommit( PreparedStatement ps, boolean batch, int batchCounter ) throws HopDatabaseException {
<span class="fc" id="L1313">    boolean isBatchUpdate = false;</span>
    try {
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">      if ( ps != null ) {</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        if ( !isAutoCommit() ) {</span>
          // Execute the batch or just perform a commit.
<span class="pc bpc" id="L1318" title="3 of 6 branches missed.">          if ( batch &amp;&amp; getDatabaseMetaData().supportsBatchUpdates() &amp;&amp; batchCounter &gt; 0 ) {</span>
            // The problem with the batch counters is that you can't just
            // execute the current batch.
            // Certain databases have a problem if you execute the batch and if
            // there are no statements in it.
            // You can't just catch the exception either because you would have
            // to roll back on certain databases before you can then continue to
            // do anything.
            // That leaves the task of keeping track of the number of rows up to
            // our responsibility.
<span class="fc" id="L1328">            isBatchUpdate = true;</span>
<span class="nc" id="L1329">            ps.executeBatch();</span>
<span class="nc" id="L1330">            commit();</span>
<span class="nc" id="L1331">            ps.clearBatch();</span>
          } else {
<span class="nc" id="L1333">            commit();</span>
          }
        }

        // Let's not forget to close the prepared statement.
        //
<span class="nc" id="L1339">        ps.close();</span>
      }
<span class="nc" id="L1341">    } catch ( BatchUpdateException ex ) {</span>
<span class="nc" id="L1342">      throw createHopDatabaseBatchException( &quot;Error updating batch&quot;, ex );</span>
<span class="fc" id="L1343">    } catch ( SQLException ex ) {</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">      if ( isBatchUpdate ) {</span>
<span class="fc" id="L1345">        throw createHopDatabaseBatchException( &quot;Error updating batch&quot;, ex );</span>
      } else {
<span class="fc" id="L1347">        throw new HopDatabaseException( &quot;Unable to empty ps and commit connection.&quot;, ex );</span>
      }
<span class="nc" id="L1349">    }</span>
<span class="nc" id="L1350">  }</span>

  public static HopDatabaseBatchException createHopDatabaseBatchException( String message, SQLException ex ) {
<span class="fc" id="L1353">    HopDatabaseBatchException kdbe = new HopDatabaseBatchException( message, ex );</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">    if ( ex instanceof BatchUpdateException ) {</span>
<span class="fc" id="L1355">      kdbe.setUpdateCounts( ( (BatchUpdateException) ex ).getUpdateCounts() );</span>
    } else {
      // Null update count forces rollback of batch
<span class="fc" id="L1358">      kdbe.setUpdateCounts( null );</span>
    }
<span class="fc" id="L1360">    List&lt;Exception&gt; exceptions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1361">    SQLException nextException = ex.getNextException();</span>
<span class="fc" id="L1362">    SQLException oldException = null;</span>

    // This construction is specifically done for some JDBC drivers, these
    // drivers
    // always return the same exception on getNextException() (and thus go
    // into an infinite loop).
    // So it's not &quot;equals&quot; but != (comments from Sven Boden).
<span class="pc bpc" id="L1369" title="1 of 4 branches missed.">    while ( ( nextException != null ) &amp;&amp; ( oldException != nextException ) ) {</span>
<span class="fc" id="L1370">      exceptions.add( nextException );</span>
<span class="fc" id="L1371">      oldException = nextException;</span>
<span class="fc" id="L1372">      nextException = nextException.getNextException();</span>
    }
<span class="fc" id="L1374">    kdbe.setExceptionsList( exceptions );</span>
<span class="fc" id="L1375">    return kdbe;</span>
  }

  /**
   * Close the prepared statement of the insert statement.
   *
   * @param ps    The prepared statement to empty and close.
   * @param batch true if you are using batch processing (typically true for this method)
   * @throws HopDatabaseException
   * @deprecated use emptyAndCommit() instead (pass in the number of rows left in the batch)
   */
  @Deprecated
  public void insertFinished( PreparedStatement ps, boolean batch ) throws HopDatabaseException {
<span class="fc" id="L1388">    boolean isBatchUpdate = false;</span>
    try {
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">      if ( ps != null ) {</span>
<span class="fc bfc" id="L1391" title="All 2 branches covered.">        if ( !isAutoCommit() ) {</span>
          // Execute the batch or just perform a commit.
<span class="pc bpc" id="L1393" title="2 of 4 branches missed.">          if ( batch &amp;&amp; getDatabaseMetaData().supportsBatchUpdates() ) {</span>
            // The problem with the batch counters is that you can't just
            // execute the current batch.
            // Certain databases have a problem if you execute the batch and if
            // there are no statements in it.
            // You can't just catch the exception either because you would have
            // to roll back on certain databases before you can then continue to
            // do anything.
            // That leaves the task of keeping track of the number of rows up to
            // our responsibility.
<span class="fc" id="L1403">            isBatchUpdate = true;</span>
<span class="nc" id="L1404">            ps.executeBatch();</span>
<span class="nc" id="L1405">            commit();</span>
          } else {
<span class="nc" id="L1407">            commit();</span>
          }
        }

        // Let's not forget to close the prepared statement.
        //
<span class="nc" id="L1413">        ps.close();</span>
      }
<span class="nc" id="L1415">    } catch ( BatchUpdateException ex ) {</span>
<span class="nc" id="L1416">      throw createHopDatabaseBatchException( &quot;Error updating batch&quot;, ex );</span>
<span class="fc" id="L1417">    } catch ( SQLException ex ) {</span>
<span class="fc bfc" id="L1418" title="All 2 branches covered.">      if ( isBatchUpdate ) {</span>
<span class="fc" id="L1419">        throw createHopDatabaseBatchException( &quot;Error updating batch&quot;, ex );</span>
      } else {
<span class="fc" id="L1421">        throw new HopDatabaseException( &quot;Unable to commit connection after having inserted rows.&quot;, ex );</span>
      }
<span class="nc" id="L1423">    }</span>
<span class="nc" id="L1424">  }</span>

  /**
   * Execute an SQL statement on the database connection (has to be open)
   *
   * @param sql The SQL to execute
   * @return a Result object indicating the number of lines read, deleted, inserted, updated, ...
   * @throws HopDatabaseException in case anything goes wrong.
   */
  public Result execStatement( String sql ) throws HopDatabaseException {
<span class="nc" id="L1434">    return execStatement( sql, null, null );</span>
  }

  public Result execStatement( String rawsql, IRowMeta params, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L1438">    Result result = new Result();</span>

    // Replace existing code with a class that removes comments from the raw
    // SQL.
    // The SqlCommentScrubber respects single-quoted strings, so if a
    // double-dash or a multiline comment appears
    // in a single-quoted string, it will be treated as a string instead of
    // comments.
<span class="nc" id="L1446">    String sql = databaseMeta.getIDatabase().createSqlScriptParser().removeComments( rawsql ).trim();</span>
    try {
      boolean resultSet;
      int count;
<span class="nc bnc" id="L1450" title="All 2 branches missed.">      if ( params != null ) {</span>
<span class="nc" id="L1451">        PreparedStatement prep_stmt = connection.prepareStatement( databaseMeta.stripCR( sql ) );</span>
<span class="nc" id="L1452">        setValues( params, data, prep_stmt ); // set the parameters!</span>
<span class="nc" id="L1453">        resultSet = prep_stmt.execute();</span>
<span class="nc" id="L1454">        count = prep_stmt.getUpdateCount();</span>
<span class="nc" id="L1455">        prep_stmt.close();</span>
<span class="nc" id="L1456">      } else {</span>
<span class="nc" id="L1457">        String sqlStripped = databaseMeta.stripCR( sql );</span>
        // log.logDetailed(&quot;Executing SQL Statement: [&quot;+sqlStripped+&quot;]&quot;);
<span class="nc" id="L1459">        Statement stmt = connection.createStatement();</span>
<span class="nc" id="L1460">        resultSet = stmt.execute( sqlStripped );</span>
<span class="nc" id="L1461">        count = stmt.getUpdateCount();</span>
<span class="nc" id="L1462">        stmt.close();</span>
      }
<span class="nc" id="L1464">      String upperSql = sql.toUpperCase();</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">      if ( !resultSet ) {</span>
        // if the result is a resultset, we don't do anything with it!
        // You should have called something else!
        // log.logDetailed(&quot;What to do with ResultSet??? (count=&quot;+count+&quot;)&quot;);
<span class="nc bnc" id="L1469" title="All 2 branches missed.">        if ( count &gt; 0 ) {</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">          if ( upperSql.startsWith( &quot;INSERT&quot; ) ) {</span>
<span class="nc" id="L1471">            result.setNrLinesOutput( count );</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">          } else if ( upperSql.startsWith( &quot;UPDATE&quot; ) ) {</span>
<span class="nc" id="L1473">            result.setNrLinesUpdated( count );</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">          } else if ( upperSql.startsWith( &quot;DELETE&quot; ) ) {</span>
<span class="nc" id="L1475">            result.setNrLinesDeleted( count );</span>
          }
        }
      }

      // See if a cache needs to be cleared...
<span class="nc bnc" id="L1481" title="All 2 branches missed.">      if ( upperSql.startsWith( &quot;ALTER TABLE&quot; )</span>
<span class="nc bnc" id="L1482" title="All 4 branches missed.">        || upperSql.startsWith( &quot;DROP TABLE&quot; ) || upperSql.startsWith( &quot;CREATE TABLE&quot; ) ) {</span>
<span class="nc" id="L1483">        DbCache.getInstance().clear( databaseMeta.getName() );</span>
      }
<span class="nc" id="L1485">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L1486">      throw new HopDatabaseException( &quot;Couldn't execute SQL: &quot; + sql + Const.CR, ex );</span>
<span class="nc" id="L1487">    } catch ( Exception e ) {</span>
<span class="nc" id="L1488">      throw new HopDatabaseException( &quot;Unexpected error executing SQL: &quot; + Const.CR, e );</span>
<span class="nc" id="L1489">    }</span>

<span class="nc" id="L1491">    return result;</span>
  }

  /**
   * Execute a series of SQL statements, separated by ;
   * &lt;p/&gt;
   * We are already connected...
   * &lt;p/&gt;
   * Multiple statements have to be split into parts We use the &quot;;&quot; to separate statements...
   * &lt;p/&gt;
   * We keep the results in Result object from Workflows
   *
   * @param script The SQL script to be execute
   * @return A result with counts of the number or records updates, inserted, deleted or read.
   * @throws HopDatabaseException In case an error occurs
   */
  public Result execStatements( String script ) throws HopDatabaseException {
<span class="nc" id="L1508">    return execStatements( script, null, null );</span>
  }

  /**
   * Execute a series of SQL statements, separated by ;
   * &lt;p/&gt;
   * We are already connected...
   * &lt;p/&gt;
   * Multiple statements have to be split into parts We use the &quot;;&quot; to separate statements...
   * &lt;p/&gt;
   * We keep the results in Result object from Workflows
   *
   * @param script The SQL script to be execute
   * @param params Parameters Meta
   * @param data   Parameters value
   * @return A result with counts of the number or records updates, inserted, deleted or read.
   * @throws HopDatabaseException In case an error occurs
   */
  public Result execStatements( String script, IRowMeta params, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L1527">    Result result = new Result();</span>

<span class="nc" id="L1529">    SqlScriptParser sqlScriptParser = databaseMeta.getIDatabase().createSqlScriptParser();</span>
<span class="nc" id="L1530">    List&lt;String&gt; statements = sqlScriptParser.split( script );</span>
<span class="nc" id="L1531">    int nrstats = 0;</span>

<span class="nc bnc" id="L1533" title="All 2 branches missed.">    if ( statements != null ) {</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">      for ( String stat : statements ) {</span>
        // Deleting all the single-line and multi-line comments from the string
<span class="nc" id="L1536">        stat = sqlScriptParser.removeComments( stat );</span>

<span class="nc bnc" id="L1538" title="All 2 branches missed.">        if ( !Const.onlySpaces( stat ) ) {</span>
<span class="nc" id="L1539">          String sql = Const.trim( stat );</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">          if ( sql.toUpperCase().startsWith( &quot;SELECT&quot; ) ) {</span>
            // A Query
<span class="nc bnc" id="L1542" title="All 2 branches missed.">            if ( log.isDetailed() ) {</span>
<span class="nc" id="L1543">              log.logDetailed( &quot;launch SELECT statement: &quot; + Const.CR + sql );</span>
            }

<span class="nc" id="L1546">            nrstats++;</span>
<span class="nc" id="L1547">            ResultSet rs = null;</span>
            try {
<span class="nc" id="L1549">              rs = openQuery( sql, params, data );</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">              if ( rs != null ) {</span>
<span class="nc" id="L1551">                Object[] row = getRow( rs );</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">                while ( row != null ) {</span>
<span class="nc" id="L1553">                  result.setNrLinesRead( result.getNrLinesRead() + 1 );</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                  if ( log.isDetailed() ) {</span>
<span class="nc" id="L1555">                    log.logDetailed( rowMeta.getString( row ) );</span>
                  }
<span class="nc" id="L1557">                  row = getRow( rs );</span>
                }

<span class="nc" id="L1560">              } else {</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">                if ( log.isDebug() ) {</span>
<span class="nc" id="L1562">                  log.logDebug( &quot;Error executing query: &quot; + Const.CR + sql );</span>
                }
              }
<span class="nc" id="L1565">            } catch ( HopValueException e ) {</span>
<span class="nc" id="L1566">              throw new HopDatabaseException( e ); // just pass the error</span>
              // upwards.
            } finally {
              try {
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                if ( rs != null ) {</span>
<span class="nc" id="L1571">                  rs.close();</span>
                }
<span class="nc" id="L1573">              } catch ( SQLException ex ) {</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">                if ( log.isDebug() ) {</span>
<span class="nc" id="L1575">                  log.logDebug( &quot;Error closing query: &quot; + Const.CR + sql );</span>
                }
<span class="nc" id="L1577">              }</span>
            }
<span class="nc" id="L1579">          } else {</span>
            // any kind of statement
<span class="nc bnc" id="L1581" title="All 2 branches missed.">            if ( log.isDetailed() ) {</span>
<span class="nc" id="L1582">              log.logDetailed( &quot;launch DDL statement: &quot; + Const.CR + sql );</span>
            }

            // A DDL statement
<span class="nc" id="L1586">            nrstats++;</span>
<span class="nc" id="L1587">            Result res = execStatement( sql, params, data );</span>
<span class="nc" id="L1588">            result.add( res );</span>
          }
        }
<span class="nc" id="L1591">      }</span>
    }

<span class="nc bnc" id="L1594" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">      log.logDetailed( nrstats + &quot; statement&quot; + ( nrstats == 1 ? &quot;&quot; : &quot;s&quot; ) + &quot; executed&quot; );</span>
    }

<span class="nc" id="L1598">    return result;</span>
  }

  public ResultSet openQuery( String sql ) throws HopDatabaseException {
<span class="nc" id="L1602">    return openQuery( sql, null, null );</span>
  }

  /**
   * Open a query on the database with a set of parameters stored in a Hop Row
   *
   * @param sql    The SQL to launch with question marks (?) as placeholders for the parameters
   * @param params The parameters or null if no parameters are used.
   * @return A JDBC ResultSet
   * @throws HopDatabaseException when something goes wrong with the query.
   * @data the parameter data to open the query with
   */
  public ResultSet openQuery( String sql, IRowMeta params, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L1615">    return openQuery( sql, params, data, ResultSet.FETCH_FORWARD );</span>
  }

  public ResultSet openQuery( String sql, IRowMeta params, Object[] data, int fetch_mode )
    throws HopDatabaseException {
<span class="nc" id="L1620">    return openQuery( sql, params, data, fetch_mode, false );</span>
  }

  public ResultSet openQuery( String sql, IRowMeta params, Object[] data, int fetch_mode,
                              boolean lazyConversion ) throws HopDatabaseException {
    ResultSet res;

    // Create a Statement
    try {
<span class="fc" id="L1629">      log.snap( Metrics.METRIC_DATABASE_OPEN_QUERY_START, databaseMeta.getName() );</span>
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">      if ( params != null ) {</span>
<span class="nc" id="L1631">        log.snap( Metrics.METRIC_DATABASE_PREPARE_SQL_START, databaseMeta.getName() );</span>
<span class="nc" id="L1632">        pstmt =</span>
<span class="nc" id="L1633">          connection.prepareStatement(</span>
<span class="nc" id="L1634">            databaseMeta.stripCR( sql ), ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY );</span>
<span class="nc" id="L1635">        log.snap( Metrics.METRIC_DATABASE_PREPARE_SQL_STOP, databaseMeta.getName() );</span>

<span class="nc" id="L1637">        log.snap( Metrics.METRIC_DATABASE_SQL_VALUES_START, databaseMeta.getName() );</span>
<span class="nc" id="L1638">        setValues( params, data ); // set the dates etc!</span>
<span class="nc" id="L1639">        log.snap( Metrics.METRIC_DATABASE_SQL_VALUES_STOP, databaseMeta.getName() );</span>

<span class="nc bnc" id="L1641" title="All 2 branches missed.">        if ( canWeSetFetchSize( pstmt ) ) {</span>
<span class="nc" id="L1642">          int maxRows = pstmt.getMaxRows();</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">          int fs = Const.FETCH_SIZE &lt;= maxRows ? maxRows : Const.FETCH_SIZE;</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">          if ( databaseMeta.isMySqlVariant() ) {</span>
<span class="nc" id="L1645">            setMysqlFetchSize( pstmt, fs, maxRows );</span>
          } else {
<span class="nc" id="L1647">            pstmt.setFetchSize( fs );</span>
          }

<span class="nc" id="L1650">          pstmt.setFetchDirection( fetch_mode );</span>
        }

<span class="nc bnc" id="L1653" title="All 4 branches missed.">        if ( rowlimit &gt; 0 &amp;&amp; databaseMeta.supportsSetMaxRows() ) {</span>
<span class="nc" id="L1654">          pstmt.setMaxRows( rowlimit );</span>
        }

<span class="nc" id="L1657">        log.snap( Metrics.METRIC_DATABASE_EXECUTE_SQL_START, databaseMeta.getName() );</span>
<span class="nc" id="L1658">        res = pstmt.executeQuery();</span>
<span class="nc" id="L1659">        log.snap( Metrics.METRIC_DATABASE_EXECUTE_SQL_STOP, databaseMeta.getName() );</span>
      } else {
<span class="fc" id="L1661">        log.snap( Metrics.METRIC_DATABASE_CREATE_SQL_START, databaseMeta.getName() );</span>
<span class="nc" id="L1662">        sel_stmt = connection.createStatement();</span>
<span class="nc" id="L1663">        log.snap( Metrics.METRIC_DATABASE_CREATE_SQL_STOP, databaseMeta.getName() );</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">        if ( canWeSetFetchSize( sel_stmt ) ) {</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">          int fs = Const.FETCH_SIZE &lt;= sel_stmt.getMaxRows() ? sel_stmt.getMaxRows() : Const.FETCH_SIZE;</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">          if ( databaseMeta.getIDatabase().isMySqlVariant()</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">            &amp;&amp; databaseMeta.isStreamingResults() ) {</span>
<span class="nc" id="L1668">            sel_stmt.setFetchSize( Integer.MIN_VALUE );</span>
          } else {
<span class="nc" id="L1670">            sel_stmt.setFetchSize( fs );</span>
          }
<span class="nc" id="L1672">          sel_stmt.setFetchDirection( fetch_mode );</span>
        }
<span class="nc bnc" id="L1674" title="All 4 branches missed.">        if ( rowlimit &gt; 0 &amp;&amp; databaseMeta.supportsSetMaxRows() ) {</span>
<span class="nc" id="L1675">          sel_stmt.setMaxRows( rowlimit );</span>
        }

<span class="nc" id="L1678">        log.snap( Metrics.METRIC_DATABASE_EXECUTE_SQL_START, databaseMeta.getName() );</span>
<span class="nc" id="L1679">        res = sel_stmt.executeQuery( databaseMeta.stripCR( sql ) );</span>
<span class="nc" id="L1680">        log.snap( Metrics.METRIC_DATABASE_EXECUTE_SQL_STOP, databaseMeta.getName() );</span>
      }

      // MySQL Hack only. It seems too much for the cursor type of operation on
      // MySQL, to have another cursor opened
      // to get the length of a String field. So, on MySQL, we ingore the length
      // of Strings in result rows.
      //
<span class="nc" id="L1688">      rowMeta = getRowInfo( res.getMetaData(), databaseMeta.isMySqlVariant(), lazyConversion );</span>
<span class="nc" id="L1689">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L1690">      throw new HopDatabaseException( &quot;An error occurred executing SQL: &quot; + Const.CR + sql, ex );</span>
<span class="fc" id="L1691">    } catch ( Exception e ) {</span>
<span class="fc" id="L1692">      throw new HopDatabaseException( &quot;An error occurred executing SQL:&quot; + Const.CR + sql, e );</span>
    } finally {
<span class="fc" id="L1694">      log.snap( Metrics.METRIC_DATABASE_OPEN_QUERY_STOP, databaseMeta.getName() );</span>
    }

<span class="nc" id="L1697">    return res;</span>
  }

  private boolean canWeSetFetchSize( Statement statement ) throws SQLException {
<span class="nc bnc" id="L1701" title="All 2 branches missed.">    return databaseMeta.isFetchSizeSupported()</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">      &amp;&amp; ( statement.getMaxRows() &gt; 0</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">      || databaseMeta.getIDatabase().isPostgresVariant()</span>
<span class="nc bnc" id="L1704" title="All 4 branches missed.">      || ( databaseMeta.isMySqlVariant() &amp;&amp; databaseMeta.isStreamingResults() ) );</span>
  }

  public ResultSet openQuery( PreparedStatement ps, IRowMeta params, Object[] data )
    throws HopDatabaseException {
    ResultSet res;

    // Create a Statement
    try {
<span class="nc" id="L1713">      log.snap( Metrics.METRIC_DATABASE_OPEN_QUERY_START, databaseMeta.getName() );</span>

<span class="nc" id="L1715">      log.snap( Metrics.METRIC_DATABASE_SQL_VALUES_START, databaseMeta.getName() );</span>
<span class="nc" id="L1716">      setValues( params, data, ps ); // set the parameters!</span>
<span class="nc" id="L1717">      log.snap( Metrics.METRIC_DATABASE_SQL_VALUES_STOP, databaseMeta.getName() );</span>

<span class="nc bnc" id="L1719" title="All 2 branches missed.">      if ( canWeSetFetchSize( ps ) ) {</span>
<span class="nc" id="L1720">        int maxRows = ps.getMaxRows();</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">        int fs = Const.FETCH_SIZE &lt;= maxRows ? maxRows : Const.FETCH_SIZE;</span>
        // mysql have some restriction on fetch size assignment
<span class="nc bnc" id="L1723" title="All 2 branches missed.">        if ( databaseMeta.isMySqlVariant() ) {</span>
<span class="nc" id="L1724">          setMysqlFetchSize( ps, fs, maxRows );</span>
        } else {
          // other databases seems not.
<span class="nc" id="L1727">          ps.setFetchSize( fs );</span>
        }

<span class="nc" id="L1730">        ps.setFetchDirection( ResultSet.FETCH_FORWARD );</span>
      }

<span class="nc bnc" id="L1733" title="All 4 branches missed.">      if ( rowlimit &gt; 0 &amp;&amp; databaseMeta.supportsSetMaxRows() ) {</span>
<span class="nc" id="L1734">        ps.setMaxRows( rowlimit );</span>
      }

<span class="nc" id="L1737">      log.snap( Metrics.METRIC_DATABASE_EXECUTE_SQL_START, databaseMeta.getName() );</span>
<span class="nc" id="L1738">      res = ps.executeQuery();</span>
<span class="nc" id="L1739">      log.snap( Metrics.METRIC_DATABASE_EXECUTE_SQL_STOP, databaseMeta.getName() );</span>

      // MySQL Hack only. It seems too much for the cursor type of operation on
      // MySQL, to have another cursor opened
      // to get the length of a String field. So, on MySQL, we ignore the length
      // of Strings in result rows.
      //
<span class="nc" id="L1746">      log.snap( Metrics.METRIC_DATABASE_GET_ROW_META_START, databaseMeta.getName() );</span>
<span class="nc" id="L1747">      rowMeta = getRowInfo( res.getMetaData(), databaseMeta.isMySqlVariant(), false );</span>
<span class="nc" id="L1748">      log.snap( Metrics.METRIC_DATABASE_GET_ROW_META_STOP, databaseMeta.getName() );</span>
<span class="nc" id="L1749">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L1750">      throw new HopDatabaseException( &quot;ERROR executing query&quot;, ex );</span>
<span class="nc" id="L1751">    } catch ( Exception e ) {</span>
<span class="nc" id="L1752">      throw new HopDatabaseException( &quot;ERROR executing query&quot;, e );</span>
    } finally {
<span class="nc" id="L1754">      log.snap( Metrics.METRIC_DATABASE_OPEN_QUERY_STOP, databaseMeta.getName() );</span>
    }

<span class="nc" id="L1757">    return res;</span>
  }

  void setMysqlFetchSize( PreparedStatement ps, int fs, int getMaxRows ) throws SQLException, HopDatabaseException {
<span class="nc bnc" id="L1761" title="All 4 branches missed.">    if ( databaseMeta.isStreamingResults() &amp;&amp; getDatabaseMetaData().getDriverMajorVersion() == 3 ) {</span>
<span class="nc" id="L1762">      ps.setFetchSize( Integer.MIN_VALUE );</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">    } else if ( fs &lt;= getMaxRows ) {</span>
      // PDI-11373 do not set fetch size more than max rows can returns
<span class="nc" id="L1765">      ps.setFetchSize( fs );</span>
    }
<span class="nc" id="L1767">  }</span>

  /**
   * Returns a RowMeta describing the fields of a table expression.
   *
   * &lt;p&gt;Note that this implementation makes use of a SQL statement
   * in order to populate the ValueMeta object in the RowMeta it returns. This is sometimes necessary when the caller
   * needs the ValueMeta values to be properly casted.
   *
   * &lt;p&gt;In cases where a simple list of columns is required, it is preferable
   * to use {@link #getTableFieldsMeta(String, String)}. This other method will not use a SQL query and will populate
   * whatever information it can using @link {@link DatabaseMetaData#getColumns(String, String, String, String)}.
   *
   * @param tablename This is the properly quoted, and schema prefixed table name.
   */
  public IRowMeta getTableFields( String tablename ) throws HopDatabaseException {
<span class="nc" id="L1783">    return getQueryFields( databaseMeta.getSqlQueryFields( tablename ), false );</span>
  }

  public IRowMeta getQueryFields( String sql, boolean param ) throws HopDatabaseException {
<span class="fc" id="L1787">    return getQueryFields( sql, param, null, null );</span>
  }

  /**
   * See if the table specified exists by reading
   *
   * @param tablename The name of the table to check.&lt;br&gt; This is supposed to be the properly quoted name of the table
   *                  or the complete schema-table name combination.
   * @return true if the table exists, false if it doesn't.
   * @deprecated Deprecated in favor of {@link #checkTableExists(String, String)}
   */
  public boolean checkTableExists( String tablename ) throws HopDatabaseException {
    try {
<span class="pc bpc" id="L1800" title="1 of 2 branches missed.">      if ( log.isDebug() ) {</span>
<span class="nc" id="L1801">        log.logDebug( &quot;Checking if table [&quot; + tablename + &quot;] exists!&quot; );</span>
      }
      // Just try to read from the table.
<span class="fc" id="L1804">      String sql = databaseMeta.getSqlTableExists( tablename );</span>
      try {
<span class="nc" id="L1806">        getOneRow( sql );</span>
<span class="nc" id="L1807">        return true;</span>
<span class="fc" id="L1808">      } catch ( HopDatabaseException e ) {</span>
<span class="fc" id="L1809">        return false;</span>
      }
<span class="nc" id="L1811">    } catch ( Exception e ) {</span>
<span class="nc" id="L1812">      throw new HopDatabaseException(</span>
<span class="nc" id="L1813">        &quot;Unable to check if table [&quot; + tablename + &quot;] exists on connection [&quot; + databaseMeta.getName() + &quot;]&quot;, e );</span>
    }
  }

  /**
   * See if the table specified exists.
   *
   * &lt;p&gt;This is a smarter implementation of {@link #checkTableExists(String)} where
   * metadata is used first and we only use statements when absolutely necessary.
   *
   * &lt;p&gt;Contrary to previous versions of similar duplicated methods, this implementation
   * does not require quoted identifiers.
   *
   * @param tablename The unquoted name of the table to check.&lt;br&gt; This is NOT the properly quoted name of the table or
   *                  the complete schema-table name combination.
   * @param schema    The unquoted name of the schema.
   * @return true if the table exists, false if it doesn't.
   */
  public boolean checkTableExists( String schema, String tablename ) throws HopDatabaseException {

<span class="fc bfc" id="L1833" title="All 2 branches covered.">    if ( useJdbcMeta() ) {</span>
<span class="nc" id="L1834">      return checkTableExistsByDbMeta( schema, tablename );</span>
    } else {
<span class="fc" id="L1836">      return checkTableExists( databaseMeta.getQuotedSchemaTableCombination( schema, tablename ) );</span>
    }
  }

  /**
   * See if the table specified exists by getting db metadata.
   *
   * @param tablename The name of the table to check.&lt;br&gt; This is supposed to be the properly quoted name of the table
   *                  or the complete schema-table name combination.
   * @return true if the table exists, false if it doesn't.
   * @throws HopDatabaseException
   * @deprecated Deprecated in favor of {@link #checkTableExists(String, String)}
   */
  @Deprecated
  public boolean checkTableExistsByDbMeta( String schema, String tablename ) throws HopDatabaseException {
<span class="fc" id="L1851">    boolean isTableExist = false;</span>
<span class="pc bpc" id="L1852" title="1 of 2 branches missed.">    if ( log.isDebug() ) {</span>
<span class="nc" id="L1853">      log.logDebug( BaseMessages.getString( PKG, &quot;Database.Info.CheckingIfTableExistsInDbMetaData&quot;, tablename ) );</span>
    }
<span class="fc" id="L1855">    try ( ResultSet resTables = getTableMetaData( schema, tablename ) ) {</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">      while ( resTables.next() ) {</span>
<span class="fc" id="L1857">        String resTableName = resTables.getString( TABLES_META_DATA_TABLE_NAME );</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">        if ( tablename.equalsIgnoreCase( resTableName ) ) {</span>
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L1860">            log.logDebug( BaseMessages.getString( PKG, &quot;Database.Info.TableFound&quot;, tablename ) );</span>
          }
<span class="fc" id="L1862">          isTableExist = true;</span>
<span class="fc" id="L1863">          break;</span>
        }
<span class="fc" id="L1865">      }</span>
<span class="fc" id="L1866">    } catch ( SQLException e ) {</span>
<span class="fc" id="L1867">      throw new HopDatabaseException(</span>
<span class="fc" id="L1868">        BaseMessages.getString( PKG, &quot;Database.Error.UnableToCheckExistingTable&quot;, tablename, databaseMeta.getName() ),</span>
        e );
<span class="fc" id="L1870">    }</span>
<span class="fc" id="L1871">    return isTableExist;</span>
  }

  /**
   * Retrieves the table description matching the schema and table name.
   *
   * @param schema the schema name pattern
   * @param table  the table name pattern
   * @return table description row set
   * @throws HopDatabaseException if DatabaseMetaData is null or some database error occurs
   */
  private ResultSet getTableMetaData( String schema, String table ) throws HopDatabaseException {
<span class="fc" id="L1883">    ResultSet tables = null;</span>
<span class="fc bfc" id="L1884" title="All 2 branches covered.">    if ( getDatabaseMetaData() == null ) {</span>
<span class="fc" id="L1885">      throw new HopDatabaseException( BaseMessages.getString( PKG, &quot;Database.Error.UnableToGetDbMeta&quot; ) );</span>
    }
    try {
<span class="fc" id="L1888">      tables = getDatabaseMetaData().getTables( null, schema, table, TABLE_TYPES_TO_GET );</span>
<span class="fc" id="L1889">    } catch ( SQLException e ) {</span>
<span class="fc" id="L1890">      throw new HopDatabaseException( BaseMessages.getString( PKG, &quot;Database.Error.UnableToGetTableNames&quot; ), e );</span>
<span class="fc" id="L1891">    }</span>
<span class="fc bfc" id="L1892" title="All 2 branches covered.">    if ( tables == null ) {</span>
<span class="fc" id="L1893">      throw new HopDatabaseException( BaseMessages.getString( PKG, &quot;Database.Error.UnableToGetTableNames&quot; ) );</span>
    }
<span class="fc" id="L1895">    return tables;</span>
  }

  /**
   * Retrieves the columns metadata matching the schema and table name.
   *
   * @param schema the schema name pattern
   * @param table  the table name pattern
   * @throws HopDatabaseException if DatabaseMetaData is null or some database error occurs
   */
  private ResultSet getColumnsMetaData( String schema, String table ) throws HopDatabaseException {
<span class="fc" id="L1906">    ResultSet columns = null;</span>
<span class="pc bpc" id="L1907" title="1 of 2 branches missed.">    if ( getDatabaseMetaData() == null ) {</span>
<span class="nc" id="L1908">      throw new HopDatabaseException( BaseMessages.getString( PKG, &quot;Database.Error.UnableToGetDbMeta&quot; ) );</span>
    }
    try {
<span class="fc" id="L1911">      columns = getDatabaseMetaData().getColumns( null, schema, table, null );</span>
<span class="nc" id="L1912">    } catch ( SQLException e ) {</span>
<span class="nc" id="L1913">      throw new HopDatabaseException( BaseMessages.getString( PKG, &quot;Database.Error.UnableToGetTableNames&quot; ), e );</span>
<span class="fc" id="L1914">    }</span>
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">    if ( columns == null ) {</span>
<span class="fc" id="L1916">      throw new HopDatabaseException( BaseMessages.getString( PKG, &quot;Database.Error.UnableToGetTableNames&quot; ) );</span>
    }
<span class="nc" id="L1918">    return columns;</span>
  }

  /**
   * See if the column specified exists by reading the metadata first, execution last.
   *
   * &lt;p&gt;This is a smarter implementation of {@link #checkTableExists(String)} where
   * metadata is used first and we only use statements when absolutely necessary.
   *
   * &lt;p&gt;Contrary to previous versions of similar duplicated methods, this implementation
   * does not require quoted identifiers.
   *
   * @param schemaname The name of the schema to check.
   * @param tablename  The name of the table to check.
   * @param columnname The name of the column to check.
   * @return true if the table exists, false if it doesn't.
   */
  public boolean checkColumnExists( String schemaname, String tablename, String columnname )
    throws HopDatabaseException {
<span class="fc bfc" id="L1937" title="All 2 branches covered.">    if ( useJdbcMeta() ) {</span>
<span class="nc" id="L1938">      return checkColumnExistsByDbMeta( schemaname, tablename, columnname );</span>
    } else {
<span class="fc" id="L1940">      return checkColumnExists(</span>
<span class="fc" id="L1941">        databaseMeta.quoteField( columnname ),</span>
<span class="fc" id="L1942">        databaseMeta.getQuotedSchemaTableCombination( schemaname, tablename ) );</span>
    }
  }

  public boolean checkColumnExistsByDbMeta( String schemaname, String tablename, String columnname )
    throws HopDatabaseException {
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">    if ( log.isDebug() ) {</span>
<span class="nc" id="L1949">      log.logDebug( &quot;Checking if column [&quot; + columnname + &quot;] exists in table [&quot; + tablename + &quot;] !&quot; );</span>
    }

    // First try the metadata
    try {
<span class="nc" id="L1954">      ResultSet columns = getColumnsMetaData( schemaname, tablename );</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">      while ( columns.next() ) {</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">        if ( columnname.equals( columns.getString( &quot;COLUMN_NAME&quot; ) ) ) {</span>
<span class="nc" id="L1957">          return true;</span>
        }
      }
<span class="nc" id="L1960">      return false;</span>
<span class="fc" id="L1961">    } catch ( HopDatabaseException | SQLException e ) {</span>
      // That's ok. We will use a prepared statement.
<span class="fc" id="L1963">      throw new HopDatabaseException( &quot;Metadata check failed. Fallback to statement check.&quot; );</span>
    }

  }

  /**
   * See if the column specified exists by reading
   *
   * @param columnname The name of the column to check.
   * @param tablename  The name of the table to check.&lt;br&gt; This is supposed to be the properly quoted name of the table
   *                   or the complete schema-table name combination.
   * @return true if the table exists, false if it doesn't.
   * @deprecated Deprecated in favor of the smarter {@link #checkColumnExists(String, String, String)}
   */
  @Deprecated
  public boolean checkColumnExists( String columnname, String tablename ) throws HopDatabaseException {
    try {
<span class="pc bpc" id="L1980" title="1 of 2 branches missed.">      if ( log.isDebug() ) {</span>
<span class="nc" id="L1981">        log.logDebug( &quot;Checking if column [&quot; + columnname + &quot;] exists in table [&quot; + tablename + &quot;] !&quot; );</span>
      }

      // Just try to read from the table.
<span class="fc" id="L1985">      String sql = databaseMeta.getSqlColumnExists( columnname, tablename );</span>

      try {
<span class="nc" id="L1988">        getOneRow( sql );</span>
<span class="nc" id="L1989">        return true;</span>
<span class="fc" id="L1990">      } catch ( HopDatabaseException e ) {</span>
<span class="fc" id="L1991">        return false;</span>
      }
<span class="nc" id="L1993">    } catch ( Exception e ) {</span>
<span class="nc" id="L1994">      throw new HopDatabaseException( &quot;Unable to check if column [&quot;</span>
<span class="nc" id="L1995">        + columnname + &quot;] exists in table [&quot; + tablename + &quot;] on connection [&quot; + databaseMeta.getName() + &quot;]&quot;, e );</span>
    }
  }

  /**
   * Check whether the sequence exists, Oracle only!
   *
   * @param sequenceName The name of the sequence
   * @return true if the sequence exists.
   */
  public boolean checkSequenceExists( String sequenceName ) throws HopDatabaseException {
<span class="nc" id="L2006">    return checkSequenceExists( null, sequenceName );</span>
  }

  /**
   * Check whether the sequence exists, Oracle only!
   *
   * @param sequenceName The name of the sequence
   * @return true if the sequence exists.
   */
  public boolean checkSequenceExists( String schemaName, String sequenceName ) throws HopDatabaseException {
<span class="nc" id="L2016">    boolean retval = false;</span>

<span class="nc bnc" id="L2018" title="All 2 branches missed.">    if ( !databaseMeta.supportsSequences() ) {</span>
<span class="nc" id="L2019">      return retval;</span>
    }

<span class="nc" id="L2022">    String schemaSequence = databaseMeta.getQuotedSchemaTableCombination( schemaName, sequenceName );</span>
    try {
      //
      // Get the info from the data dictionary...
      //
<span class="nc" id="L2027">      String sql = databaseMeta.getSqlSequenceExists( schemaSequence );</span>
<span class="nc" id="L2028">      ResultSet res = openQuery( sql );</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">      if ( res != null ) {</span>
<span class="nc" id="L2030">        Object[] row = getRow( res );</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">        if ( row != null ) {</span>
<span class="nc" id="L2032">          retval = true;</span>
        }
<span class="nc" id="L2034">        closeQuery( res );</span>
      }
<span class="nc" id="L2036">    } catch ( Exception e ) {</span>
<span class="nc" id="L2037">      throw new HopDatabaseException( &quot;Unexpected error checking whether or not sequence [&quot;</span>
        + schemaSequence + &quot;] exists&quot;, e );
<span class="nc" id="L2039">    }</span>

<span class="nc" id="L2041">    return retval;</span>
  }

  /**
   * Check if an index on certain fields in a table exists.
   *
   * @param tableName  The table on which the index is checked
   * @param idx_fields The fields on which the indexe is checked
   * @return True if the index exists
   */
  public boolean checkIndexExists( String tableName, String[] idx_fields ) throws HopDatabaseException {
<span class="nc" id="L2052">    return checkIndexExists( null, tableName, idx_fields );</span>
  }

  /**
   * Check if an index on certain fields in a table exists.
   *
   * @param schemaName The schema on which the index is checked
   * @param tableName  The table on which the index is checked
   * @param idx_fields The fields on which the indexe is checked
   * @return True if the index exists
   */
  public boolean checkIndexExists( String schemaName, String tableName, String[] idx_fields )
    throws HopDatabaseException {
<span class="nc" id="L2065">    String tablename = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">    if ( !checkTableExists( tablename ) ) {</span>
<span class="nc" id="L2067">      return false;</span>
    }

<span class="nc bnc" id="L2070" title="All 2 branches missed.">    if ( log.isDebug() ) {</span>
<span class="nc" id="L2071">      log.logDebug( &quot;CheckIndexExists() tablename = &quot; + tablename + &quot; type = &quot; + databaseMeta.getPluginId() );</span>
    }

<span class="nc" id="L2074">    return databaseMeta.getIDatabase().checkIndexExists( this, schemaName, tableName, idx_fields );</span>
  }

  public String getCreateIndexStatement( String tablename, String indexname, String[] idx_fields, boolean tk,
                                         boolean unique, boolean bitmap, boolean semi_colon ) {
<span class="nc" id="L2079">    return getCreateIndexStatement( null, tablename, indexname, idx_fields, tk, unique, bitmap, semi_colon );</span>
  }

  public String getCreateIndexStatement( String schemaname, String tablename, String indexname,
                                         String[] idx_fields, boolean tk, boolean unique, boolean bitmap,
                                         boolean semi_colon ) {
<span class="nc" id="L2085">    String cr_index = &quot;&quot;;</span>
<span class="nc" id="L2086">    IDatabase iDatabase = databaseMeta.getIDatabase();</span>

    // Exasol does not support explicit handling of indexes
<span class="nc bnc" id="L2089" title="All 2 branches missed.">    if ( iDatabase.isExasolVariant() ) {</span>
<span class="nc" id="L2090">      return &quot;&quot;;</span>
    }

<span class="nc" id="L2093">    cr_index += &quot;CREATE &quot;;</span>

<span class="nc bnc" id="L2095" title="All 6 branches missed.">    if ( unique || ( tk &amp;&amp; iDatabase.isSybaseVariant() ) ) {</span>
<span class="nc" id="L2096">      cr_index += &quot;UNIQUE &quot;;</span>
    }

<span class="nc bnc" id="L2099" title="All 4 branches missed.">    if ( bitmap &amp;&amp; databaseMeta.supportsBitmapIndex() ) {</span>
<span class="nc" id="L2100">      cr_index += &quot;BITMAP &quot;;</span>
    }

<span class="nc" id="L2103">    cr_index += &quot;INDEX &quot; + databaseMeta.quoteField( indexname ) + &quot; &quot;;</span>
<span class="nc" id="L2104">    cr_index += &quot;ON &quot;;</span>
    // assume table has already been quoted (and possibly includes schema)
<span class="nc" id="L2106">    cr_index += tablename;</span>
<span class="nc" id="L2107">    cr_index += &quot;(&quot;;</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">    for ( int i = 0; i &lt; idx_fields.length; i++ ) {</span>
<span class="nc bnc" id="L2109" title="All 2 branches missed.">      if ( i &gt; 0 ) {</span>
<span class="nc" id="L2110">        cr_index += &quot;, &quot;;</span>
      }
<span class="nc" id="L2112">      cr_index += databaseMeta.quoteField( idx_fields[ i ] );</span>
    }
<span class="nc" id="L2114">    cr_index += &quot;)&quot; + Const.CR;</span>

<span class="nc" id="L2116">    cr_index += iDatabase.getIndexTablespaceDDL( variables, databaseMeta );</span>

<span class="nc bnc" id="L2118" title="All 2 branches missed.">    if ( semi_colon ) {</span>
<span class="nc" id="L2119">      cr_index += &quot;;&quot; + Const.CR;</span>
    }

<span class="nc" id="L2122">    return cr_index;</span>
  }

  public String getCreateSequenceStatement( String sequence, long start_at, long increment_by, long max_value,
                                            boolean semi_colon ) {
<span class="nc" id="L2127">    return getCreateSequenceStatement(</span>
<span class="nc" id="L2128">      null, sequence, Long.toString( start_at ), Long.toString( increment_by ), Long.toString( max_value ),</span>
      semi_colon );
  }

  public String getCreateSequenceStatement( String sequence, String start_at, String increment_by,
                                            String max_value, boolean semi_colon ) {
<span class="nc" id="L2134">    return getCreateSequenceStatement( null, sequence, start_at, increment_by, max_value, semi_colon );</span>
  }

  public String getCreateSequenceStatement( String schemaName, String sequence, long start_at, long increment_by,
                                            long max_value, boolean semi_colon ) {
<span class="nc" id="L2139">    return getCreateSequenceStatement( schemaName, sequence, Long.toString( start_at ), Long</span>
<span class="nc" id="L2140">      .toString( increment_by ), Long.toString( max_value ), semi_colon );</span>
  }

  public String getCreateSequenceStatement( String schemaName, String sequenceName, String start_at,
                                            String increment_by, String max_value, boolean semi_colon ) {
<span class="fc" id="L2145">    String cr_seq = &quot;&quot;;</span>

<span class="pc bpc" id="L2147" title="1 of 2 branches missed.">    if ( Utils.isEmpty( sequenceName ) ) {</span>
<span class="nc" id="L2148">      return cr_seq;</span>
    }

<span class="pc bpc" id="L2151" title="1 of 2 branches missed.">    if ( databaseMeta.supportsSequences() ) {</span>
<span class="fc" id="L2152">      String schemaSequence = databaseMeta.getQuotedSchemaTableCombination( schemaName, sequenceName );</span>
<span class="fc" id="L2153">      cr_seq += &quot;CREATE SEQUENCE &quot; + schemaSequence + &quot; &quot; + Const.CR; // Works</span>
      // for
      // both
      // Oracle
      // and
      // PostgreSQL
      // :-)
<span class="fc" id="L2160">      cr_seq += &quot;START WITH &quot; + start_at + &quot; &quot; + Const.CR;</span>
<span class="fc" id="L2161">      cr_seq += &quot;INCREMENT BY &quot; + increment_by + &quot; &quot; + Const.CR;</span>
<span class="pc bpc" id="L2162" title="1 of 2 branches missed.">      if ( max_value != null ) {</span>
        // &quot;-1&quot; means there is no maxvalue, must be handles different by DB2 /
        // AS400
        //
<span class="pc bpc" id="L2166" title="2 of 4 branches missed.">        if ( databaseMeta.supportsSequenceNoMaxValueOption() &amp;&amp; max_value.trim().equals( &quot;-1&quot; ) ) {</span>
<span class="fc" id="L2167">          IDatabase iDatabase = databaseMeta.getIDatabase();</span>
<span class="fc" id="L2168">          cr_seq += iDatabase.getSequenceNoMaxValueOption() + Const.CR;</span>
<span class="fc" id="L2169">        } else {</span>
          // set the max value
<span class="nc" id="L2171">          cr_seq += &quot;MAXVALUE &quot; + max_value + Const.CR;</span>
        }
      }

<span class="pc bpc" id="L2175" title="1 of 2 branches missed.">      if ( semi_colon ) {</span>
<span class="nc" id="L2176">        cr_seq += &quot;;&quot; + Const.CR;</span>
      }
    }

<span class="fc" id="L2180">    return cr_seq;</span>
  }

  /**
   * Returns a RowMeta describing the fields of a table.
   *
   * &lt;p&gt;This is a lighter implementation of {@link #getTableFields(String)} where
   * metadata is used first and we only use statements when absolutely necessary.
   *
   * &lt;p&gt;Note that the ValueMeta returned here will not contain any actual values
   * and as such, this method should be used whenever a simple list of columns is required, and we're not planning on
   * looking at the actual data.
   *
   * &lt;p&gt;Contrary to previous versions of similar duplicated methods, this implementation
   * does not require quoted identifiers.
   *
   * @param schemaName The unquoted schema name. Can be null.
   * @param tableName  The unquoted table name. Cannot be null.
   */
  public IRowMeta getTableFieldsMeta( String schemaName, String tableName )
    throws HopDatabaseException {
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">    if ( useJdbcMeta() ) {</span>
<span class="nc" id="L2202">      return getTableFieldsMetaByDbMeta( schemaName, tableName );</span>
    } else {
<span class="fc" id="L2204">      String tableSchema = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>
<span class="fc" id="L2205">      String sql = databaseMeta.getSqlQueryFields( tableSchema );</span>
<span class="fc" id="L2206">      return getQueryFields( sql, false );</span>
    }
  }

  public IRowMeta getTableFieldsMetaByDbMeta( String schemaName, String tableName )
    throws HopDatabaseException {
    try {
      // Cleanup a bit. In JDBC metadata, we want null names for
      // wildcards, not empty strings.
<span class="nc bnc" id="L2215" title="All 2 branches missed.">      if ( &quot;&quot;.equals( schemaName ) ) {</span>
<span class="nc" id="L2216">        schemaName = null;</span>
      }
<span class="nc bnc" id="L2218" title="All 2 branches missed.">      if ( &quot;&quot;.equals( tableName ) ) {</span>
<span class="nc" id="L2219">        tableName = null;</span>
      }

<span class="nc" id="L2222">      IRowMeta fields = null;</span>
<span class="nc" id="L2223">      DbCache dbcache = DbCache.getInstance();</span>
<span class="nc" id="L2224">      DbCacheEntry entry = null;</span>

<span class="nc bnc" id="L2226" title="All 2 branches missed.">      if ( dbcache != null ) {</span>
        // Cache key must not match the other implementation where
        // valuemeta is properly casted. We're not caching values here,
        // just metadata.
<span class="nc" id="L2230">        entry =</span>
          new DbCacheEntry(
<span class="nc bnc" id="L2232" title="All 2 branches missed.">            databaseMeta.getName(),</span>
            &quot;LIGHTWEIGHT_SALT&quot;
<span class="nc bnc" id="L2234" title="All 2 branches missed.">              .concat( schemaName == null ? &quot;nullSchema&quot; : schemaName )</span>
<span class="nc" id="L2235">              .concat( tableName == null ? &quot;nullTable&quot; : tableName ) );</span>

<span class="nc" id="L2237">        fields = dbcache.get( entry );</span>

<span class="nc bnc" id="L2239" title="All 2 branches missed.">        if ( fields != null ) {</span>
<span class="nc" id="L2240">          return fields;</span>
        }
      }
<span class="nc bnc" id="L2243" title="All 2 branches missed.">      if ( connection == null ) {</span>
<span class="nc" id="L2244">        return null; // Cache test without connect.</span>
      }

      // First get the fields through metadata
<span class="nc" id="L2248">      ResultSet rm =</span>
<span class="nc" id="L2249">        connection.getMetaData().getColumns( null, schemaName, tableName, null );</span>

<span class="nc bnc" id="L2251" title="All 2 branches missed.">      if ( fields == null ) {</span>
<span class="nc" id="L2252">        fields = new RowMeta();</span>
      }

<span class="nc bnc" id="L2255" title="All 2 branches missed.">      while ( rm.next() ) {</span>
<span class="nc" id="L2256">        IValueMeta valueMeta = null;</span>
<span class="nc bnc" id="L2257" title="All 2 branches missed.">        for ( IValueMeta valueMetaClass : valueMetaPluginClasses ) {</span>
          try {
<span class="nc" id="L2259">            IValueMeta v =</span>
<span class="nc" id="L2260">              valueMetaClass.getMetadataPreview( databaseMeta, rm );</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">            if ( v != null ) {</span>
<span class="nc" id="L2262">              valueMeta = v;</span>
<span class="nc" id="L2263">              break;</span>
            }
<span class="nc" id="L2265">          } catch ( HopDatabaseException e ) {</span>
            // That's ok. The VMI impl doesn't like this data type.
<span class="nc bnc" id="L2267" title="All 2 branches missed.">            if ( log.isDebug() ) {</span>
<span class="nc" id="L2268">              log.logDebug( &quot;Skipping IValueMeta:&quot; + valueMetaClass.getClass().getName(), e );</span>
            }
<span class="nc" id="L2270">          }</span>
<span class="nc" id="L2271">        }</span>
<span class="nc" id="L2272">        fields.addValueMeta( valueMeta );</span>
<span class="nc" id="L2273">      }</span>

      // Store in cache!!
<span class="nc bnc" id="L2276" title="All 4 branches missed.">      if ( dbcache != null &amp;&amp; entry != null ) {</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">        if ( fields != null ) {</span>
<span class="nc" id="L2278">          dbcache.put( entry, fields );</span>
        }
      }

<span class="nc" id="L2282">      return fields;</span>
<span class="nc" id="L2283">    } catch ( Exception e ) {</span>
<span class="nc" id="L2284">      throw new HopDatabaseException( &quot;Failed to fetch fields from jdbc meta &quot;, e );</span>
    }

  }

  public IRowMeta getQueryFields( String sql, boolean param, IRowMeta inform, Object[] data )
    throws HopDatabaseException {
    IRowMeta fields;
<span class="fc" id="L2292">    DbCache dbcache = DbCache.getInstance();</span>

<span class="fc" id="L2294">    DbCacheEntry entry = null;</span>

    // Check the cache first!
    //
<span class="pc bpc" id="L2298" title="1 of 2 branches missed.">    if ( dbcache != null ) {</span>
<span class="fc" id="L2299">      entry = new DbCacheEntry( databaseMeta.getName(), sql );</span>
<span class="fc" id="L2300">      fields = dbcache.get( entry );</span>
<span class="pc bpc" id="L2301" title="1 of 2 branches missed.">      if ( fields != null ) {</span>
<span class="nc" id="L2302">        return fields;</span>
      }
    }
<span class="pc bpc" id="L2305" title="1 of 2 branches missed.">    if ( connection == null ) {</span>
<span class="fc" id="L2306">      return null; // Cache test without connect.</span>
    }

    // No cache entry found

    // The new method of retrieving the query fields fails on Oracle because
    // they failed to implement the getMetaData method on a prepared statement.
    // (!!!)
    // Even recent drivers like 10.2 fail because of it.
    //
    // There might be other databases that don't support it (we have no
    // knowledge of this at the time of writing).
    // If we discover other RDBMSs, we will create an interface for it.
    // For now, we just try to get the field layout on the re-bound in the
    // exception block below.
    //
    try {
<span class="nc bnc" id="L2323" title="All 2 branches missed.">      if ( databaseMeta.supportsPreparedStatementMetadataRetrieval() ) {</span>
        // On with the regular program.
        //
<span class="nc" id="L2326">        fields = getQueryFieldsFromPreparedStatement( sql );</span>
      } else {
<span class="nc bnc" id="L2328" title="All 2 branches missed.">        if ( isDataServiceConnection() ) {</span>
<span class="nc" id="L2329">          fields = getQueryFieldsFromDatabaseMetaData( sql );</span>
        } else {
<span class="nc" id="L2331">          fields = getQueryFieldsFromDatabaseMetaData();</span>
        }
      }
<span class="nc" id="L2334">    } catch ( Exception e ) {</span>
      /*
       * databaseMeta.getDatabaseType()==DatabaseMeta.TYPE_DATABASE_SYBASEIQ ) {
       */
<span class="nc" id="L2338">      fields = getQueryFieldsFallback( sql, param, inform, data );</span>
<span class="nc" id="L2339">    }</span>

    // Store in cache!!
<span class="nc bnc" id="L2342" title="All 4 branches missed.">    if ( dbcache != null &amp;&amp; entry != null ) {</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">      if ( fields != null ) {</span>
<span class="nc" id="L2344">        dbcache.put( entry, fields );</span>
      }
    }

<span class="nc" id="L2348">    return fields;</span>
  }

  private boolean isDataServiceConnection() {
<span class="nc" id="L2352">    return DATA_SERVICES_PLUGIN_ID.equals( databaseMeta.getPluginId() );</span>
  }

  public IRowMeta getQueryFieldsFromPreparedStatement( String sql ) throws Exception {
<span class="fc" id="L2356">    PreparedStatement preparedStatement = null;</span>
    try {
<span class="fc" id="L2358">      preparedStatement =</span>
<span class="fc" id="L2359">        connection.prepareStatement( databaseMeta.stripCR( sql ), ResultSet.TYPE_FORWARD_ONLY,</span>
          ResultSet.CONCUR_READ_ONLY );
<span class="fc" id="L2361">      preparedStatement.setMaxRows( 1 );</span>
<span class="fc" id="L2362">      ResultSetMetaData rsmd = preparedStatement.getMetaData();</span>
<span class="fc" id="L2363">      return getRowInfo( rsmd, false, false );</span>
<span class="nc" id="L2364">    } catch ( Exception e ) {</span>
<span class="nc" id="L2365">      throw new Exception( e );</span>
    } finally {
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">      if ( preparedStatement != null ) {</span>
        try {
<span class="fc" id="L2369">          preparedStatement.close();</span>
<span class="nc" id="L2370">        } catch ( SQLException e ) {</span>
<span class="nc" id="L2371">          throw new HopDatabaseException( &quot;Unable to close prepared statement after determining SQL layout&quot;, e );</span>
<span class="fc" id="L2372">        }</span>
      }
    }
  }

  public IRowMeta getQueryFieldsFromDatabaseMetaData() throws Exception {
<span class="fc" id="L2378">    return this.getQueryFieldsFromDatabaseMetaData( null );</span>
  }

  private IRowMeta getQueryFieldsFromDatabaseMetaData( String sql ) throws Exception {

<span class="fc" id="L2383">    ResultSet columns = connection.getMetaData().getColumns( &quot;&quot;, &quot;&quot;,</span>
<span class="pc bpc" id="L2384" title="1 of 2 branches missed.">      StringUtils.isNotBlank( sql ) ? sql : databaseMeta.getName(), &quot;&quot; );</span>
<span class="fc" id="L2385">    IRowMeta rowMeta = new RowMeta();</span>
<span class="fc bfc" id="L2386" title="All 2 branches covered.">    while ( columns.next() ) {</span>
<span class="fc" id="L2387">      IValueMeta valueMeta = null;</span>
<span class="fc" id="L2388">      String name = columns.getString( &quot;COLUMN_NAME&quot; );</span>
<span class="fc" id="L2389">      String type = columns.getString( &quot;SOURCE_DATA_TYPE&quot; );</span>
<span class="fc" id="L2390">      int size = columns.getInt( &quot;COLUMN_SIZE&quot; );</span>
<span class="pc bpc" id="L2391" title="3 of 4 branches missed.">      if ( type.equals( &quot;Integer&quot; ) || type.equals( &quot;Long&quot; ) ) {</span>
<span class="fc" id="L2392">        valueMeta = new ValueMetaInteger();</span>
<span class="nc bnc" id="L2393" title="All 4 branches missed.">      } else if ( type.equals( &quot;BigDecimal&quot; ) || type.equals( &quot;BigNumber&quot; ) ) {</span>
<span class="nc" id="L2394">        valueMeta = new ValueMetaBigNumber();</span>
<span class="nc bnc" id="L2395" title="All 4 branches missed.">      } else if ( type.equals( &quot;Double&quot; ) || type.equals( &quot;Number&quot; ) ) {</span>
<span class="nc" id="L2396">        valueMeta = new ValueMetaNumber();</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">      } else if ( type.equals( &quot;String&quot; ) ) {</span>
<span class="nc" id="L2398">        valueMeta = new ValueMetaString();</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">      } else if ( type.equals( &quot;Date&quot; ) ) {</span>
<span class="nc" id="L2400">        valueMeta = new ValueMetaDate();</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">      } else if ( type.equals( &quot;Boolean&quot; ) ) {</span>
<span class="nc" id="L2402">        valueMeta = new ValueMetaBoolean();</span>
<span class="nc bnc" id="L2403" title="All 2 branches missed.">      } else if ( type.equals( &quot;Binary&quot; ) ) {</span>
<span class="nc" id="L2404">        valueMeta = new ValueMetaBinary();</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">      } else if ( type.equals( &quot;Timestamp&quot; ) ) {</span>
<span class="nc" id="L2406">        valueMeta = new ValueMetaTimestamp();</span>
<span class="nc bnc" id="L2407" title="All 2 branches missed.">      } else if ( type.equals( &quot;Internet Address&quot; ) ) {</span>
<span class="nc" id="L2408">        valueMeta = new ValueMetaInternetAddress();</span>
      }
<span class="pc bpc" id="L2410" title="1 of 2 branches missed.">      if ( valueMeta != null ) {</span>
<span class="fc" id="L2411">        valueMeta.setName( name );</span>
<span class="fc" id="L2412">        valueMeta.setComments( name );</span>
<span class="fc" id="L2413">        valueMeta.setLength( size );</span>
<span class="fc" id="L2414">        valueMeta.setOriginalColumnTypeName( type );</span>

<span class="fc" id="L2416">        valueMeta.setConversionMask( columns.getString( &quot;SOURCE_MASK&quot; ) );</span>
<span class="fc" id="L2417">        valueMeta.setDecimalSymbol( columns.getString( &quot;SOURCE_DECIMAL_SYMBOL&quot; ) );</span>
<span class="fc" id="L2418">        valueMeta.setGroupingSymbol( columns.getString( &quot;SOURCE_GROUPING_SYMBOL&quot; ) );</span>
<span class="fc" id="L2419">        valueMeta.setCurrencySymbol( columns.getString( &quot;SOURCE_CURRENCY_SYMBOL&quot; ) );</span>

<span class="fc" id="L2421">        rowMeta.addValueMeta( valueMeta );</span>
      } else {
<span class="nc" id="L2423">        log.logBasic( &quot;Database.getQueryFields() IValueMeta mapping not resolved for the column &quot; + name );</span>
<span class="nc" id="L2424">        rowMeta = null;</span>
<span class="nc" id="L2425">        break;</span>
      }
<span class="fc" id="L2427">    }</span>
<span class="pc bpc" id="L2428" title="2 of 4 branches missed.">    if ( rowMeta != null &amp;&amp; !rowMeta.isEmpty() ) {</span>
<span class="fc" id="L2429">      return rowMeta;</span>
    } else {
<span class="nc" id="L2431">      throw new Exception( &quot;Error in Database.getQueryFields()&quot; );</span>
    }
  }

  public IRowMeta getQueryFieldsFallback( String sql, boolean param, IRowMeta inform,
                                          Object[] data ) throws HopDatabaseException {
    IRowMeta fields;

    try {
<span class="pc bpc" id="L2440" title="1 of 2 branches missed.">      if ( ( inform == null</span>
        // Hack for MSSQL jtds 1.2 when using xxx NOT IN yyy we have to use a
        // prepared statement (see BugID 3214)
<span class="pc bpc" id="L2443" title="1 of 2 branches missed.">        &amp;&amp; databaseMeta.getIDatabase().isMsSqlServerVariant() )</span>
<span class="pc bpc" id="L2444" title="1 of 2 branches missed.">        || databaseMeta.getIDatabase().supportsResultSetMetadataRetrievalOnly() ) {</span>
<span class="nc" id="L2445">        sel_stmt = connection.createStatement( ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY );</span>
        try {
<span class="nc bnc" id="L2447" title="All 4 branches missed.">          if ( databaseMeta.isFetchSizeSupported() &amp;&amp; sel_stmt.getMaxRows() &gt;= 1 ) {</span>
<span class="nc bnc" id="L2448" title="All 2 branches missed.">            if ( databaseMeta.getIDatabase().isMySqlVariant() ) {</span>
<span class="nc" id="L2449">              sel_stmt.setFetchSize( Integer.MIN_VALUE );</span>
            } else {
<span class="nc" id="L2451">              sel_stmt.setFetchSize( 1 );</span>
            }
          }
<span class="nc bnc" id="L2454" title="All 2 branches missed.">          if ( databaseMeta.supportsSetMaxRows() ) {</span>
<span class="nc" id="L2455">            sel_stmt.setMaxRows( 1 );</span>
          }

<span class="nc" id="L2458">          ResultSet r = sel_stmt.executeQuery( databaseMeta.stripCR( sql ) );</span>
          try {
<span class="nc" id="L2460">            fields = getRowInfo( r.getMetaData(), false, false );</span>
          } finally { // avoid leaking resources
<span class="nc" id="L2462">            r.close();</span>
          }
        } finally { // avoid leaking resources
<span class="nc" id="L2465">          sel_stmt.close();</span>
<span class="nc" id="L2466">          sel_stmt = null;</span>
<span class="nc" id="L2467">        }</span>
      } else {
<span class="fc" id="L2469">        PreparedStatement ps = connection.prepareStatement( databaseMeta.stripCR( sql ) );</span>
        try {
<span class="pc bpc" id="L2471" title="1 of 2 branches missed.">          if ( param ) {</span>
<span class="nc" id="L2472">            IRowMeta par = inform;</span>

<span class="nc bnc" id="L2474" title="All 4 branches missed.">            if ( par == null || par.isEmpty() ) {</span>
<span class="nc" id="L2475">              par = getParameterMetaData( ps );</span>
            }

<span class="nc bnc" id="L2478" title="All 4 branches missed.">            if ( par == null || par.isEmpty() ) {</span>
<span class="nc" id="L2479">              par = getParameterMetaData( sql, inform, data );</span>
            }

<span class="nc" id="L2482">            setValues( par, data, ps );</span>
          }
<span class="fc" id="L2484">          ResultSet r = ps.executeQuery();</span>
          try {
            //
            // See PDI-14893
            // If we're in this private fallback method, it's because the databasemeta returns false for
            // supportsPreparedStatementMetadataRetrieval() or because we got an exception trying to do
            // it the other way. In either case, there is no reason for us to ever try getting the prepared
            // statement's metadata. The right answer is to directly get the resultset metadata.
            //
            // ResultSetMetaData metadata = ps.getMetaData();
            // If the PreparedStatement can't get us the metadata, try using the ResultSet's metadata
            // if ( metadata == null ) {
            //  metadata = r.getMetaData();
            // }
<span class="fc" id="L2498">            ResultSetMetaData metadata = r.getMetaData();</span>
<span class="fc" id="L2499">            fields = getRowInfo( metadata, false, false );</span>
          } finally { // should always use a try/finally to avoid leaks
<span class="fc" id="L2501">            r.close();</span>
          }
        } finally { // should always use a try/finally to avoid leaks
<span class="fc" id="L2504">          ps.close();</span>
        }
      }
<span class="nc" id="L2507">    } catch ( Exception ex ) {</span>
<span class="nc" id="L2508">      throw new HopDatabaseException( &quot;Couldn't get field info from [&quot; + sql + &quot;]&quot; + Const.CR, ex );</span>
<span class="fc" id="L2509">    }</span>

<span class="fc" id="L2511">    return fields;</span>
  }

  public void closeQuery( ResultSet res ) throws HopDatabaseException {
    // close everything involved in the query!
    try {
<span class="nc bnc" id="L2517" title="All 2 branches missed.">      if ( res != null ) {</span>
<span class="nc" id="L2518">        res.close();</span>
      }
<span class="nc bnc" id="L2520" title="All 2 branches missed.">      if ( sel_stmt != null ) {</span>
<span class="nc" id="L2521">        sel_stmt.close();</span>
<span class="nc" id="L2522">        sel_stmt = null;</span>
      }
<span class="nc bnc" id="L2524" title="All 2 branches missed.">      if ( pstmt != null ) {</span>
<span class="nc" id="L2525">        pstmt.close();</span>
<span class="nc" id="L2526">        pstmt = null;</span>
      }
<span class="nc" id="L2528">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L2529">      throw new HopDatabaseException( &quot;Couldn't close query: resultset or prepared statements&quot;, ex );</span>
<span class="nc" id="L2530">    }</span>
<span class="nc" id="L2531">  }</span>

  /**
   * Build the row using ResultSetMetaData rsmd
   *
   * @param rm             The resultset metadata to inquire
   * @param ignoreLength   true if you want to ignore the length (workaround for MySQL bug/problem)
   * @param lazyConversion true if lazy conversion needs to be enabled where possible
   */
  private IRowMeta getRowInfo( ResultSetMetaData rm, boolean ignoreLength, boolean lazyConversion )
    throws HopDatabaseException {
    try {
<span class="fc" id="L2543">      log.snap( Metrics.METRIC_DATABASE_GET_ROW_META_START, databaseMeta.getName() );</span>

<span class="pc bpc" id="L2545" title="1 of 2 branches missed.">      if ( rm == null ) {</span>
<span class="nc" id="L2546">        throw new HopDatabaseException( &quot;No result set metadata available to retrieve row metadata!&quot; );</span>
      }

<span class="fc" id="L2549">      IRowMeta rowMeta = new RowMeta();</span>

      try {
<span class="fc" id="L2552">        int nrcols = rm.getColumnCount();</span>
<span class="fc bfc" id="L2553" title="All 2 branches covered.">        for ( int i = 1; i &lt;= nrcols; i++ ) {</span>
<span class="fc" id="L2554">          IValueMeta valueMeta = getValueFromSqlType( rm, i, ignoreLength, lazyConversion );</span>
<span class="fc" id="L2555">          rowMeta.addValueMeta( valueMeta );</span>
        }
<span class="fc" id="L2557">        return rowMeta;</span>
<span class="nc" id="L2558">      } catch ( SQLException ex ) {</span>
<span class="nc" id="L2559">        throw new HopDatabaseException( &quot;Error getting row information from database: &quot;, ex );</span>
      }
    } finally {
<span class="fc" id="L2562">      log.snap( Metrics.METRIC_DATABASE_GET_ROW_META_STOP, databaseMeta.getName() );</span>
    }
  }

  private IValueMeta getValueFromSqlType(ResultSetMetaData rm, int i, boolean ignoreLength,
                                         boolean lazyConversion )
    throws HopDatabaseException, SQLException {
    // TODO If we do lazy conversion, we need to find out about the encoding
    //

    // Extract the name from the result set meta data...
    //
    String name;
<span class="pc bpc" id="L2575" title="1 of 2 branches missed.">    if ( databaseMeta.isMySqlVariant() ) {</span>
<span class="nc" id="L2576">      name = databaseMeta.getIDatabase().getLegacyColumnName( getDatabaseMetaData(), rm, i );</span>
    } else {
<span class="fc" id="L2578">      name = new String( rm.getColumnName( i ) );</span>
    }

    // Check the name, sometimes it's empty.
    //
<span class="pc bpc" id="L2583" title="2 of 4 branches missed.">    if ( Utils.isEmpty( name ) || Const.onlySpaces( name ) ) {</span>
<span class="nc" id="L2584">      name = &quot;Field&quot; + ( i + 1 );</span>
    }

    // Ask all the value meta types if they want to handle the SQL type.
    // The first to reply something gets the workflow...
    //
<span class="fc" id="L2590">    IValueMeta valueMeta = null;</span>
<span class="pc bpc" id="L2591" title="1 of 2 branches missed.">    for ( IValueMeta valueMetaClass : valueMetaPluginClasses ) {</span>
<span class="fc" id="L2592">      IValueMeta v =</span>
<span class="fc" id="L2593">        valueMetaClass.getValueFromSqlType( databaseMeta, name, rm, i, ignoreLength, lazyConversion );</span>
<span class="fc bfc" id="L2594" title="All 2 branches covered.">      if ( v != null ) {</span>
<span class="fc" id="L2595">        valueMeta = v;</span>
<span class="fc" id="L2596">        break;</span>
      }
<span class="fc" id="L2598">    }</span>

<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">    if ( valueMeta != null ) {</span>
<span class="fc" id="L2601">      return valueMeta;</span>
    }

<span class="nc" id="L2604">    throw new HopDatabaseException( &quot;Unable to handle database column '&quot;</span>
      + name + &quot;', on column index &quot; + i + &quot; : not a handled data type&quot; );
  }

  public boolean absolute( ResultSet rs, int position ) throws HopDatabaseException {
    try {
<span class="nc" id="L2610">      return rs.absolute( position );</span>
<span class="nc" id="L2611">    } catch ( SQLException e ) {</span>
<span class="nc" id="L2612">      throw new HopDatabaseException( &quot;Unable to move resultset to position &quot; + position, e );</span>
    }
  }

  public boolean relative( ResultSet rs, int rows ) throws HopDatabaseException {
    try {
<span class="nc" id="L2618">      return rs.relative( rows );</span>
<span class="nc" id="L2619">    } catch ( SQLException e ) {</span>
<span class="nc" id="L2620">      throw new HopDatabaseException( &quot;Unable to move the resultset forward &quot; + rows + &quot; rows&quot;, e );</span>
    }
  }

  public void afterLast( ResultSet rs ) throws HopDatabaseException {
    try {
<span class="nc" id="L2626">      rs.afterLast();</span>
<span class="nc" id="L2627">    } catch ( SQLException e ) {</span>
<span class="nc" id="L2628">      throw new HopDatabaseException( &quot;Unable to move resultset to after the last position&quot;, e );</span>
<span class="nc" id="L2629">    }</span>
<span class="nc" id="L2630">  }</span>

  public void first( ResultSet rs ) throws HopDatabaseException {
    try {
<span class="nc" id="L2634">      rs.first();</span>
<span class="nc" id="L2635">    } catch ( SQLException e ) {</span>
<span class="nc" id="L2636">      throw new HopDatabaseException( &quot;Unable to move resultset to the first position&quot;, e );</span>
<span class="nc" id="L2637">    }</span>
<span class="nc" id="L2638">  }</span>

  /**
   * Get a row from the resultset. Do not use lazy conversion
   *
   * @param rs The resultset to get the row from
   * @return one row or null if no row was found on the resultset or if an error occurred.
   */
  public Object[] getRow( ResultSet rs ) throws HopDatabaseException {
<span class="nc" id="L2647">    return getRow( rs, false );</span>
  }

  /**
   * Get a row from the resultset.
   *
   * @param rs             The resultset to get the row from
   * @param lazyConversion set to true if strings need to have lazy conversion enabled
   * @return one row or null if no row was found on the resultset or if an error occurred.
   */
  public Object[] getRow( ResultSet rs, boolean lazyConversion ) throws HopDatabaseException {
<span class="fc bfc" id="L2658" title="All 2 branches covered.">    if ( rowMeta == null ) {</span>
<span class="fc" id="L2659">      ResultSetMetaData rsmd = null;</span>
      try {
<span class="fc" id="L2661">        rsmd = rs.getMetaData();</span>
<span class="nc" id="L2662">      } catch ( SQLException e ) {</span>
<span class="nc" id="L2663">        throw new HopDatabaseException( &quot;Unable to retrieve metadata from resultset&quot;, e );</span>
<span class="fc" id="L2664">      }</span>

<span class="fc" id="L2666">      rowMeta = getRowInfo( rsmd, false, lazyConversion );</span>
    }

<span class="fc" id="L2669">    return getRow( rs, null, rowMeta );</span>
  }

  /**
   * Get a row from the resultset.
   *
   * @param rs The resultset to get the row from
   * @return one row or null if no row was found on the resultset or if an error occurred.
   */
  public Object[] getRow( ResultSet rs, ResultSetMetaData dummy, IRowMeta rowInfo )
    throws HopDatabaseException {
<span class="fc" id="L2680">    long startTime = System.currentTimeMillis();</span>

    try {

<span class="fc" id="L2684">      int nrcols = rowInfo.size();</span>
<span class="fc" id="L2685">      Object[] data = RowDataUtil.allocateRowData( nrcols );</span>

<span class="pc bpc" id="L2687" title="1 of 2 branches missed.">      if ( rs.next() ) {</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">        for ( int i = 0; i &lt; nrcols; i++ ) {</span>
<span class="nc" id="L2689">          IValueMeta val = rowInfo.getValueMeta( i );</span>

<span class="nc" id="L2691">          data[ i ] = databaseMeta.getValueFromResultSet( rs, val, i );</span>
        }
      } else {
<span class="fc" id="L2694">        data = null;</span>
      }

<span class="fc" id="L2697">      return data;</span>
<span class="nc" id="L2698">    } catch ( Exception ex ) {</span>
<span class="nc" id="L2699">      throw new HopDatabaseException( &quot;Couldn't get row from result set&quot;, ex );</span>
    } finally {
<span class="pc bpc" id="L2701" title="1 of 2 branches missed.">      if ( log.isGatheringMetrics() ) {</span>
<span class="nc" id="L2702">        long time = System.currentTimeMillis() - startTime;</span>
<span class="nc" id="L2703">        log.snap( Metrics.METRIC_DATABASE_GET_ROW_SUM_TIME, databaseMeta.getName(), time );</span>
<span class="nc" id="L2704">        log.snap( Metrics.METRIC_DATABASE_GET_ROW_MIN_TIME, databaseMeta.getName(), time );</span>
<span class="nc" id="L2705">        log.snap( Metrics.METRIC_DATABASE_GET_ROW_MAX_TIME, databaseMeta.getName(), time );</span>
<span class="nc" id="L2706">        log.snap( Metrics.METRIC_DATABASE_GET_ROW_COUNT, databaseMeta.getName() );</span>
      }
    }
  }

  public void printSqlException(SQLException ex ) {
<span class="nc" id="L2712">    log.logError( &quot;==&gt; SQLException: &quot; );</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">    while ( ex != null ) {</span>
<span class="nc" id="L2714">      log.logError( &quot;Message:   &quot; + ex.getMessage() );</span>
<span class="nc" id="L2715">      log.logError( &quot;SQLState:  &quot; + ex.getSQLState() );</span>
<span class="nc" id="L2716">      log.logError( &quot;ErrorCode: &quot; + ex.getErrorCode() );</span>
<span class="nc" id="L2717">      ex = ex.getNextException();</span>
<span class="nc" id="L2718">      log.logError( &quot;&quot; );</span>
    }
<span class="nc" id="L2720">  }</span>

  public void setLookup( String table, String[] codes, String[] condition, String[] gets, String[] rename,
                         String orderby ) throws HopDatabaseException {
<span class="fc" id="L2724">    setLookup( table, codes, condition, gets, rename, orderby, false );</span>
<span class="fc" id="L2725">  }</span>

  public void setLookup( String schema, String table, String[] codes, String[] condition, String[] gets,
                         String[] rename, String orderby ) throws HopDatabaseException {
<span class="nc" id="L2729">    setLookup( schema, table, codes, condition, gets, rename, orderby, false );</span>
<span class="nc" id="L2730">  }</span>

  public void setLookup( String tableName, String[] codes, String[] condition, String[] gets, String[] rename,
                         String orderby, boolean checkForMultipleResults ) throws HopDatabaseException {
<span class="fc" id="L2734">    setLookup( null, tableName, codes, condition, gets, rename, orderby, checkForMultipleResults );</span>
<span class="fc" id="L2735">  }</span>

  // Lookup certain fields in a table
  public void setLookup( String schemaName, String tableName, String[] codes, String[] condition, String[] gets,
                         String[] rename, String orderby, boolean checkForMultipleResults )
    throws HopDatabaseException {
    try {
<span class="fc" id="L2742">      log.snap( Metrics.METRIC_DATABASE_SET_LOOKUP_START, databaseMeta.getName() );</span>

<span class="fc" id="L2744">      String table = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>

<span class="fc" id="L2746">      String sql = &quot;SELECT &quot;;</span>

<span class="fc bfc" id="L2748" title="All 2 branches covered.">      for ( int i = 0; i &lt; gets.length; i++ ) {</span>
<span class="pc bpc" id="L2749" title="1 of 2 branches missed.">        if ( i != 0 ) {</span>
<span class="nc" id="L2750">          sql += &quot;, &quot;;</span>
        }
<span class="fc" id="L2752">        sql += databaseMeta.quoteField( gets[ i ] );</span>
<span class="pc bpc" id="L2753" title="3 of 6 branches missed.">        if ( rename != null &amp;&amp; rename[ i ] != null &amp;&amp; !gets[ i ].equalsIgnoreCase( rename[ i ] ) ) {</span>
<span class="nc" id="L2754">          sql += &quot; AS &quot; + databaseMeta.quoteField( rename[ i ] );</span>
        }
      }

<span class="fc" id="L2758">      sql += &quot; FROM &quot; + table + &quot; WHERE &quot;;</span>

<span class="fc bfc" id="L2760" title="All 2 branches covered.">      for ( int i = 0; i &lt; codes.length; i++ ) {</span>
<span class="pc bpc" id="L2761" title="1 of 2 branches missed.">        if ( i != 0 ) {</span>
<span class="nc" id="L2762">          sql += &quot; AND &quot;;</span>
        }
<span class="fc" id="L2764">        sql += databaseMeta.quoteField( codes[ i ] );</span>
<span class="pc bpc" id="L2765" title="1 of 2 branches missed.">        if ( &quot;BETWEEN&quot;.equalsIgnoreCase( condition[ i ] ) ) {</span>
<span class="nc" id="L2766">          sql += &quot; BETWEEN ? AND ? &quot;;</span>
<span class="pc bpc" id="L2767" title="2 of 4 branches missed.">        } else if ( &quot;IS NULL&quot;.equalsIgnoreCase( condition[ i ] ) || &quot;IS NOT NULL&quot;.equalsIgnoreCase( condition[ i ] ) ) {</span>
<span class="nc" id="L2768">          sql += &quot; &quot; + condition[ i ] + &quot; &quot;;</span>
        } else {
<span class="fc" id="L2770">          sql += &quot; &quot; + condition[ i ] + &quot; ? &quot;;</span>
        }
      }

<span class="pc bpc" id="L2774" title="2 of 4 branches missed.">      if ( orderby != null &amp;&amp; orderby.length() != 0 ) {</span>
<span class="fc" id="L2775">        sql += &quot; ORDER BY &quot; + orderby;</span>
      }

      try {
<span class="pc bpc" id="L2779" title="1 of 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L2780">          log.logDetailed( &quot;Setting preparedStatement to [&quot; + sql + &quot;]&quot; );</span>
        }
<span class="fc" id="L2782">        prepStatementLookup = connection.prepareStatement( databaseMeta.stripCR( sql ) );</span>
<span class="pc bpc" id="L2783" title="2 of 4 branches missed.">        if ( !checkForMultipleResults &amp;&amp; databaseMeta.supportsSetMaxRows() ) {</span>
<span class="nc" id="L2784">          prepStatementLookup.setMaxRows( 1 ); // alywas get only 1 line back!</span>
        }
<span class="nc" id="L2786">      } catch ( SQLException ex ) {</span>
<span class="nc" id="L2787">        throw new HopDatabaseException( &quot;Unable to prepare statement for update [&quot; + sql + &quot;]&quot;, ex );</span>
<span class="fc" id="L2788">      }</span>
    } finally {
<span class="fc" id="L2790">      log.snap( Metrics.METRIC_DATABASE_SET_LOOKUP_STOP, databaseMeta.getName() );</span>
    }
<span class="fc" id="L2792">  }</span>

  public boolean prepareUpdate( String table, String[] codes, String[] condition, String[] sets ) {
<span class="nc" id="L2795">    return prepareUpdate( null, table, codes, condition, sets );</span>
  }

  // Lookup certain fields in a table
  public boolean prepareUpdate( String schemaName, String tableName, String[] codes, String[] condition,
                                String[] sets ) {
    try {
<span class="nc" id="L2802">      log.snap( Metrics.METRIC_DATABASE_PREPARE_UPDATE_START, databaseMeta.getName() );</span>

<span class="nc" id="L2804">      StringBuilder sql = new StringBuilder( 128 );</span>

<span class="nc" id="L2806">      String schemaTable = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>

<span class="nc" id="L2808">      sql.append( &quot;UPDATE &quot; ).append( schemaTable ).append( Const.CR ).append( &quot;SET &quot; );</span>

<span class="nc bnc" id="L2810" title="All 2 branches missed.">      for ( int i = 0; i &lt; sets.length; i++ ) {</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">        if ( i != 0 ) {</span>
<span class="nc" id="L2812">          sql.append( &quot;,   &quot; );</span>
        }
<span class="nc" id="L2814">        sql.append( databaseMeta.quoteField( sets[ i ] ) );</span>
<span class="nc" id="L2815">        sql.append( &quot; = ?&quot; ).append( Const.CR );</span>
      }

<span class="nc" id="L2818">      sql.append( &quot;WHERE &quot; );</span>

<span class="nc bnc" id="L2820" title="All 2 branches missed.">      for ( int i = 0; i &lt; codes.length; i++ ) {</span>
<span class="nc bnc" id="L2821" title="All 2 branches missed.">        if ( i != 0 ) {</span>
<span class="nc" id="L2822">          sql.append( &quot;AND   &quot; );</span>
        }
<span class="nc" id="L2824">        sql.append( databaseMeta.quoteField( codes[ i ] ) );</span>
<span class="nc bnc" id="L2825" title="All 2 branches missed.">        if ( &quot;BETWEEN&quot;.equalsIgnoreCase( condition[ i ] ) ) {</span>
<span class="nc" id="L2826">          sql.append( &quot; BETWEEN ? AND ? &quot; );</span>
<span class="nc bnc" id="L2827" title="All 4 branches missed.">        } else if ( &quot;IS NULL&quot;.equalsIgnoreCase( condition[ i ] ) || &quot;IS NOT NULL&quot;.equalsIgnoreCase( condition[ i ] ) ) {</span>
<span class="nc" id="L2828">          sql.append( ' ' ).append( condition[ i ] ).append( ' ' );</span>
        } else {
<span class="nc" id="L2830">          sql.append( ' ' ).append( condition[ i ] ).append( &quot; ? &quot; );</span>
        }
      }

      try {
<span class="nc" id="L2835">        String s = sql.toString();</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L2837">          log.logDetailed( &quot;Setting update preparedStatement to [&quot; + s + &quot;]&quot; );</span>
        }
<span class="nc" id="L2839">        prepStatementUpdate = connection.prepareStatement( databaseMeta.stripCR( s ) );</span>
<span class="nc" id="L2840">      } catch ( SQLException ex ) {</span>
<span class="nc" id="L2841">        printSqlException( ex );</span>
<span class="nc" id="L2842">        return false;</span>
<span class="nc" id="L2843">      }</span>

<span class="nc" id="L2845">      return true;</span>
    } finally {
<span class="nc" id="L2847">      log.snap( Metrics.METRIC_DATABASE_PREPARE_UPDATE_STOP, databaseMeta.getName() );</span>
    }
  }

  /**
   * Prepare a delete statement by giving it the tablename, fields and conditions to work with.
   *
   * @param table     The table-name to delete in
   * @param codes
   * @param condition
   * @return true when everything went OK, false when something went wrong.
   */
  public boolean prepareDelete( String table, String[] codes, String[] condition ) {
<span class="nc" id="L2860">    return prepareDelete( null, table, codes, condition );</span>
  }

  /**
   * Prepare a delete statement by giving it the tablename, fields and conditions to work with.
   *
   * @param schemaName the schema-name to delete in
   * @param tableName  The table-name to delete in
   * @param codes
   * @param condition
   * @return true when everything went OK, false when something went wrong.
   */
  public boolean prepareDelete( String schemaName, String tableName, String[] codes, String[] condition ) {
    try {
<span class="nc" id="L2874">      log.snap( Metrics.METRIC_DATABASE_PREPARE_DELETE_START, databaseMeta.getName() );</span>

      String sql;

<span class="nc" id="L2878">      String table = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>
<span class="nc" id="L2879">      sql = &quot;DELETE FROM &quot; + table + Const.CR;</span>
<span class="nc" id="L2880">      sql += &quot;WHERE &quot;;</span>

<span class="nc bnc" id="L2882" title="All 2 branches missed.">      for ( int i = 0; i &lt; codes.length; i++ ) {</span>
<span class="nc bnc" id="L2883" title="All 2 branches missed.">        if ( i != 0 ) {</span>
<span class="nc" id="L2884">          sql += &quot;AND   &quot;;</span>
        }
<span class="nc" id="L2886">        sql += codes[ i ];</span>
<span class="nc bnc" id="L2887" title="All 2 branches missed.">        if ( &quot;BETWEEN&quot;.equalsIgnoreCase( condition[ i ] ) ) {</span>
<span class="nc" id="L2888">          sql += &quot; BETWEEN ? AND ? &quot;;</span>
<span class="nc bnc" id="L2889" title="All 4 branches missed.">        } else if ( &quot;IS NULL&quot;.equalsIgnoreCase( condition[ i ] ) || &quot;IS NOT NULL&quot;.equalsIgnoreCase( condition[ i ] ) ) {</span>
<span class="nc" id="L2890">          sql += &quot; &quot; + condition[ i ] + &quot; &quot;;</span>
        } else {
<span class="nc" id="L2892">          sql += &quot; &quot; + condition[ i ] + &quot; ? &quot;;</span>
        }
      }

      try {
<span class="nc bnc" id="L2897" title="All 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L2898">          log.logDetailed( &quot;Setting update preparedStatement to [&quot; + sql + &quot;]&quot; );</span>
        }
<span class="nc" id="L2900">        prepStatementUpdate = connection.prepareStatement( databaseMeta.stripCR( sql ) );</span>
<span class="nc" id="L2901">      } catch ( SQLException ex ) {</span>
<span class="nc" id="L2902">        printSqlException( ex );</span>
<span class="nc" id="L2903">        return false;</span>
<span class="nc" id="L2904">      }</span>

<span class="nc" id="L2906">      return true;</span>
    } finally {
<span class="nc" id="L2908">      log.snap( Metrics.METRIC_DATABASE_PREPARE_DELETE_STOP, databaseMeta.getName() );</span>
    }
  }

  public void setProcLookup( String proc, String[] arg, String[] argdir, int[] argtype, String returnvalue,
                             int returntype ) throws HopDatabaseException {
    try {
<span class="nc" id="L2915">      log.snap( Metrics.METRIC_DATABASE_PREPARE_DBPROC_START, databaseMeta.getName() );</span>
      String sql;
<span class="nc" id="L2917">      int pos = 0;</span>

<span class="nc" id="L2919">      sql = &quot;{ &quot;;</span>
<span class="nc bnc" id="L2920" title="All 4 branches missed.">      if ( returnvalue != null &amp;&amp; returnvalue.length() != 0 ) {</span>
<span class="nc" id="L2921">        sql += &quot;? = &quot;;</span>
      }
<span class="nc" id="L2923">      sql += &quot;call &quot; + proc + &quot; &quot;;</span>

<span class="nc bnc" id="L2925" title="All 2 branches missed.">      if ( arg.length &gt; 0 ) {</span>
<span class="nc" id="L2926">        sql += &quot;(&quot;;</span>
      }

<span class="nc bnc" id="L2929" title="All 2 branches missed.">      for ( int i = 0; i &lt; arg.length; i++ ) {</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">        if ( i != 0 ) {</span>
<span class="nc" id="L2931">          sql += &quot;, &quot;;</span>
        }
<span class="nc" id="L2933">        sql += &quot; ?&quot;;</span>
      }

<span class="nc bnc" id="L2936" title="All 2 branches missed.">      if ( arg.length &gt; 0 ) {</span>
<span class="nc" id="L2937">        sql += &quot;)&quot;;</span>
      }

<span class="nc" id="L2940">      sql += &quot;}&quot;;</span>

      try {
<span class="nc bnc" id="L2943" title="All 2 branches missed.">        if ( log.isDetailed() ) {</span>
<span class="nc" id="L2944">          log.logDetailed( &quot;DBA setting callableStatement to [&quot; + sql + &quot;]&quot; );</span>
        }
<span class="nc" id="L2946">        cstmt = connection.prepareCall( sql );</span>
<span class="nc" id="L2947">        pos = 1;</span>
<span class="nc bnc" id="L2948" title="All 2 branches missed.">        if ( !Utils.isEmpty( returnvalue ) ) {</span>
<span class="nc bnc" id="L2949" title="All 7 branches missed.">          switch ( returntype ) {</span>
            case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L2951">              cstmt.registerOutParameter( pos, java.sql.Types.DOUBLE );</span>
<span class="nc" id="L2952">              break;</span>
            case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L2954">              cstmt.registerOutParameter( pos, java.sql.Types.DECIMAL );</span>
<span class="nc" id="L2955">              break;</span>
            case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L2957">              cstmt.registerOutParameter( pos, java.sql.Types.BIGINT );</span>
<span class="nc" id="L2958">              break;</span>
            case IValueMeta.TYPE_STRING:
<span class="nc" id="L2960">              cstmt.registerOutParameter( pos, java.sql.Types.VARCHAR );</span>
<span class="nc" id="L2961">              break;</span>
            case IValueMeta.TYPE_DATE:
<span class="nc" id="L2963">              cstmt.registerOutParameter( pos, java.sql.Types.TIMESTAMP );</span>
<span class="nc" id="L2964">              break;</span>
            case IValueMeta.TYPE_BOOLEAN:
<span class="nc" id="L2966">              cstmt.registerOutParameter( pos, java.sql.Types.BOOLEAN );</span>
<span class="nc" id="L2967">              break;</span>
            default:
              break;
          }
<span class="nc" id="L2971">          pos++;</span>
        }
<span class="nc bnc" id="L2973" title="All 2 branches missed.">        for ( int i = 0; i &lt; arg.length; i++ ) {</span>
<span class="nc bnc" id="L2974" title="All 4 branches missed.">          if ( argdir[ i ].equalsIgnoreCase( &quot;OUT&quot; ) || argdir[ i ].equalsIgnoreCase( &quot;INOUT&quot; ) ) {</span>
<span class="nc bnc" id="L2975" title="All 7 branches missed.">            switch ( argtype[ i ] ) {</span>
              case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L2977">                cstmt.registerOutParameter( i + pos, java.sql.Types.DOUBLE );</span>
<span class="nc" id="L2978">                break;</span>
              case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L2980">                cstmt.registerOutParameter( i + pos, java.sql.Types.DECIMAL );</span>
<span class="nc" id="L2981">                break;</span>
              case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L2983">                cstmt.registerOutParameter( i + pos, java.sql.Types.BIGINT );</span>
<span class="nc" id="L2984">                break;</span>
              case IValueMeta.TYPE_STRING:
<span class="nc" id="L2986">                cstmt.registerOutParameter( i + pos, java.sql.Types.VARCHAR );</span>
<span class="nc" id="L2987">                break;</span>
              case IValueMeta.TYPE_DATE:
<span class="nc" id="L2989">                cstmt.registerOutParameter( i + pos, java.sql.Types.TIMESTAMP );</span>
<span class="nc" id="L2990">                break;</span>
              case IValueMeta.TYPE_BOOLEAN:
<span class="nc" id="L2992">                cstmt.registerOutParameter( i + pos, java.sql.Types.BOOLEAN );</span>
<span class="nc" id="L2993">                break;</span>
              default:
                break;
            }
          }
        }
<span class="nc" id="L2999">      } catch ( SQLException ex ) {</span>
<span class="nc" id="L3000">        throw new HopDatabaseException( &quot;Unable to prepare database procedure call&quot;, ex );</span>
<span class="nc" id="L3001">      }</span>
    } finally {
<span class="nc" id="L3003">      log.snap( Metrics.METRIC_DATABASE_PREPARE_DBPROC_STOP, databaseMeta.getName() );</span>
    }

<span class="nc" id="L3006">  }</span>

  public Object[] getLookup() throws HopDatabaseException {
<span class="fc" id="L3009">    return getLookup( prepStatementLookup, false );</span>
  }

  public Object[] getLookup( boolean failOnMultipleResults ) throws HopDatabaseException {
<span class="nc" id="L3013">    return getLookup( failOnMultipleResults, false );</span>
  }

  public Object[] getLookup( boolean failOnMultipleResults, boolean lazyConversion ) throws HopDatabaseException {
<span class="nc" id="L3017">    return getLookup( prepStatementLookup, failOnMultipleResults, lazyConversion );</span>
  }

  public Object[] getLookup( PreparedStatement ps ) throws HopDatabaseException {
    // we assume this is external PreparedStatement and we may need to re-create rowMeta
    // so we just reset it to null and it will be re-created on processRow call
<span class="fc" id="L3023">    rowMeta = null;</span>
<span class="fc" id="L3024">    return getLookup( ps, false );</span>
  }

  public Object[] getLookup( PreparedStatement ps, boolean failOnMultipleResults ) throws HopDatabaseException {
<span class="fc" id="L3028">    return getLookup( ps, failOnMultipleResults, false );</span>
  }

  public Object[] getLookup( PreparedStatement ps, boolean failOnMultipleResults, boolean lazyConversion )
    throws HopDatabaseException {
<span class="fc" id="L3033">    ResultSet res = null;</span>
    try {
<span class="fc" id="L3035">      log.snap( Metrics.METRIC_DATABASE_GET_LOOKUP_START, databaseMeta.getName() );</span>
<span class="fc" id="L3036">      res = ps.executeQuery();</span>

<span class="fc" id="L3038">      Object[] ret = getRow( res, lazyConversion );</span>

<span class="pc bpc" id="L3040" title="1 of 2 branches missed.">      if ( failOnMultipleResults ) {</span>
<span class="nc bnc" id="L3041" title="All 4 branches missed.">        if ( ret != null &amp;&amp; res.next() ) {</span>
          // if the previous row was null, there's no reason to try res.next()
          // again.
          // on DB2 this will even cause an exception (because of the buggy DB2
          // JDBC driver).
<span class="nc" id="L3046">          throw new HopDatabaseException(</span>
            &quot;Only 1 row was expected as a result of a lookup, and at least 2 were found!&quot; );
        }
      }
<span class="fc" id="L3050">      return ret;</span>
<span class="nc" id="L3051">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L3052">      throw new HopDatabaseException( &quot;Error looking up row in database&quot;, ex );</span>
    } finally {
      try {
<span class="pc bpc" id="L3055" title="1 of 2 branches missed.">        if ( res != null ) {</span>
<span class="fc" id="L3056">          res.close(); // close resultset!</span>
        }
<span class="nc" id="L3058">      } catch ( SQLException e ) {</span>
<span class="nc" id="L3059">        throw new HopDatabaseException( &quot;Unable to close resultset after looking up data&quot;, e );</span>
      } finally {
<span class="fc" id="L3061">        log.snap( Metrics.METRIC_DATABASE_GET_LOOKUP_STOP, databaseMeta.getName() );</span>
      }
    }
  }

  public DatabaseMetaData getDatabaseMetaData() throws HopDatabaseException {
<span class="fc bfc" id="L3067" title="All 2 branches covered.">    if ( dbmd == null ) {</span>
      try {
<span class="fc" id="L3069">        log.snap( Metrics.METRIC_DATABASE_GET_DBMETA_START, databaseMeta.getName() );</span>

<span class="pc bpc" id="L3071" title="1 of 2 branches missed.">        if ( connection == null ) {</span>
<span class="nc" id="L3072">          throw new HopDatabaseException( BaseMessages.getString( PKG,</span>
<span class="nc" id="L3073">            &quot;Database.Exception.EmptyConnectionError&quot;, databaseMeta.getDatabaseName() ) );</span>
        }

<span class="fc" id="L3076">        dbmd = connection.getMetaData(); // Only get the metadata once!</span>
<span class="nc" id="L3077">      } catch ( Exception e ) {</span>
<span class="nc" id="L3078">        throw new HopDatabaseException( BaseMessages.getString( PKG,</span>
          &quot;Database.Exception.UnableToGetMetadata&quot; ), e );
      } finally {
<span class="fc" id="L3081">        log.snap( Metrics.METRIC_DATABASE_GET_DBMETA_STOP, databaseMeta.getName() );</span>
      }
    }
<span class="fc" id="L3084">    return dbmd;</span>
  }

  public String getDDL( String tablename, IRowMeta fields ) throws HopDatabaseException {
<span class="nc" id="L3088">    return getDDL( tablename, fields, null, false, null, true );</span>
  }

  public String getDDL( String tablename, IRowMeta fields, String tk, boolean use_autoinc, String pk )
    throws HopDatabaseException {
<span class="nc" id="L3093">    return getDDL( tablename, fields, tk, use_autoinc, pk, true );</span>
  }

  public String getDDL( String tableName, IRowMeta fields, String tk, boolean use_autoinc, String pk,
                        boolean semicolon ) throws HopDatabaseException {
    String retval;

    // First, check for reserved SQL in the input row r...
<span class="nc" id="L3101">    databaseMeta.quoteReservedWords( fields );</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">    String quotedTk = tk != null ? databaseMeta.quoteField( tk ) : null;</span>

<span class="nc bnc" id="L3104" title="All 2 branches missed.">    if ( checkTableExists( tableName ) ) {</span>
<span class="nc" id="L3105">      retval = getAlterTableStatement( tableName, fields, quotedTk, use_autoinc, pk, semicolon );</span>
    } else {
<span class="nc" id="L3107">      retval = getCreateTableStatement( tableName, fields, quotedTk, use_autoinc, pk, semicolon );</span>
    }

<span class="nc" id="L3110">    return retval;</span>
  }

  /**
   * Generates SQL
   *
   * @param tableName   the table name or schema/table combination: this needs to be quoted properly in advance.
   * @param fields      the fields
   * @param tk          the name of the technical key field
   * @param use_autoinc true if we need to use auto-increment fields for a primary key
   * @param pk          the name of the primary/technical key field
   * @param semicolon   append semicolon to the statement
   * @return the SQL needed to create the specified table and fields.
   */
  public String getCreateTableStatement( String tableName, IRowMeta fields, String tk,
                                         boolean use_autoinc, String pk, boolean semicolon ) {
<span class="fc" id="L3126">    StringBuilder retval = new StringBuilder();</span>
<span class="fc" id="L3127">    IDatabase iDatabase = databaseMeta.getIDatabase();</span>
<span class="fc" id="L3128">    retval.append( iDatabase.getCreateTableStatement() );</span>

<span class="fc" id="L3130">    retval.append( tableName + Const.CR );</span>
<span class="fc" id="L3131">    retval.append( &quot;(&quot; ).append( Const.CR );</span>
<span class="fc bfc" id="L3132" title="All 2 branches covered.">    for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="pc bpc" id="L3133" title="1 of 2 branches missed.">      if ( i &gt; 0 ) {</span>
<span class="nc" id="L3134">        retval.append( &quot;, &quot; );</span>
      } else {
<span class="fc" id="L3136">        retval.append( &quot;  &quot; );</span>
      }

<span class="fc" id="L3139">      IValueMeta v = fields.getValueMeta( i );</span>
<span class="fc" id="L3140">      retval.append( databaseMeta.getFieldDefinition( v, tk, pk, use_autoinc ) );</span>
    }
    // At the end, before the closing of the statement, we might need to add
    // some constraints...
    // Technical keys
<span class="pc bpc" id="L3145" title="1 of 2 branches missed.">    if ( tk != null ) {</span>
<span class="pc bpc" id="L3146" title="1 of 2 branches missed.">      if ( databaseMeta.requiresCreateTablePrimaryKeyAppend() ) {</span>
<span class="fc" id="L3147">        retval.append( &quot;, PRIMARY KEY (&quot; ).append( tk ).append( &quot;)&quot; ).append( Const.CR );</span>
      }
    }

    // Primary keys
<span class="pc bpc" id="L3152" title="1 of 2 branches missed.">    if ( pk != null ) {</span>
<span class="pc bpc" id="L3153" title="1 of 2 branches missed.">      if ( databaseMeta.requiresCreateTablePrimaryKeyAppend() ) {</span>
<span class="fc" id="L3154">        retval.append( &quot;, PRIMARY KEY (&quot; ).append( pk ).append( &quot;)&quot; ).append( Const.CR );</span>
      }
    }
<span class="fc" id="L3157">    retval.append( &quot;)&quot; ).append( Const.CR );</span>

<span class="fc" id="L3159">    retval.append( databaseMeta.getIDatabase().getDataTablespaceDDL( variables, databaseMeta ) );</span>

<span class="pc bpc" id="L3161" title="5 of 6 branches missed.">    if ( pk == null &amp;&amp; tk == null &amp;&amp; databaseMeta.getIDatabase().isNeoviewVariant() ) {</span>
<span class="nc" id="L3162">      retval.append( &quot;NO PARTITION&quot; ); // use this as a default when no pk/tk is</span>
      // there, otherwise you get an error
    }

<span class="pc bpc" id="L3166" title="1 of 2 branches missed.">    if ( semicolon ) {</span>
<span class="fc" id="L3167">      retval.append( &quot;;&quot; );</span>
    }

<span class="fc" id="L3170">    return retval.toString();</span>
  }

  public String getAlterTableStatement( String tableName, IRowMeta fields, String tk, boolean use_autoinc,
                                        String pk, boolean semicolon ) throws HopDatabaseException {
<span class="nc" id="L3175">    String retval = &quot;&quot;;</span>

    // Get the fields that are in the table now:
<span class="nc" id="L3178">    IRowMeta tabFields = getTableFields( tableName );</span>

    // Don't forget to quote these as well...
<span class="nc" id="L3181">    databaseMeta.quoteReservedWords( tabFields );</span>

    // Find the missing fields
<span class="nc" id="L3184">    IRowMeta missing = new RowMeta();</span>
<span class="nc bnc" id="L3185" title="All 2 branches missed.">    for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="nc" id="L3186">      IValueMeta v = fields.getValueMeta( i );</span>
      // Not found?
<span class="nc bnc" id="L3188" title="All 2 branches missed.">      if ( tabFields.searchValueMeta( v.getName() ) == null ) {</span>
<span class="nc" id="L3189">        missing.addValueMeta( v ); // nope --&gt; Missing!</span>
      }
    }

<span class="nc bnc" id="L3193" title="All 2 branches missed.">    if ( missing.size() != 0 ) {</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">      for ( int i = 0; i &lt; missing.size(); i++ ) {</span>
<span class="nc" id="L3195">        IValueMeta v = missing.getValueMeta( i );</span>
<span class="nc" id="L3196">        retval += databaseMeta.getAddColumnStatement( tableName, v, tk, use_autoinc, pk, true );</span>
      }
    }

    // Find the surplus fields
<span class="nc" id="L3201">    IRowMeta surplus = new RowMeta();</span>
<span class="nc bnc" id="L3202" title="All 2 branches missed.">    for ( int i = 0; i &lt; tabFields.size(); i++ ) {</span>
<span class="nc" id="L3203">      IValueMeta v = tabFields.getValueMeta( i );</span>
      // Found in table, not in input ?
<span class="nc bnc" id="L3205" title="All 2 branches missed.">      if ( fields.searchValueMeta( v.getName() ) == null ) {</span>
<span class="nc" id="L3206">        surplus.addValueMeta( v ); // yes --&gt; surplus!</span>
      }
    }

<span class="nc bnc" id="L3210" title="All 2 branches missed.">    if ( surplus.size() != 0 ) {</span>
<span class="nc bnc" id="L3211" title="All 2 branches missed.">      for ( int i = 0; i &lt; surplus.size(); i++ ) {</span>
<span class="nc" id="L3212">        IValueMeta v = surplus.getValueMeta( i );</span>
<span class="nc" id="L3213">        retval += databaseMeta.getDropColumnStatement( tableName, v, tk, use_autoinc, pk, true );</span>
      }
    }

    //
    // OK, see if there are fields for which we need to modify the type...
    // (length, precision)
    //
<span class="nc" id="L3221">    IRowMeta modify = new RowMeta();</span>
<span class="nc bnc" id="L3222" title="All 2 branches missed.">    for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="nc" id="L3223">      IValueMeta desiredField = fields.getValueMeta( i );</span>
<span class="nc" id="L3224">      IValueMeta currentField = tabFields.searchValueMeta( desiredField.getName() );</span>
<span class="nc bnc" id="L3225" title="All 4 branches missed.">      if ( desiredField != null &amp;&amp; currentField != null ) {</span>
<span class="nc" id="L3226">        String desiredDDL = databaseMeta.getFieldDefinition( desiredField, tk, pk, use_autoinc );</span>
<span class="nc" id="L3227">        String currentDDL = databaseMeta.getFieldDefinition( currentField, tk, pk, use_autoinc );</span>

<span class="nc bnc" id="L3229" title="All 2 branches missed.">        boolean mod = !desiredDDL.equalsIgnoreCase( currentDDL );</span>
<span class="nc bnc" id="L3230" title="All 2 branches missed.">        if ( mod ) {</span>
<span class="nc" id="L3231">          modify.addValueMeta( desiredField );</span>
        }
      }
    }

<span class="nc bnc" id="L3236" title="All 2 branches missed.">    if ( modify.size() &gt; 0 ) {</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">      for ( int i = 0; i &lt; modify.size(); i++ ) {</span>
<span class="nc" id="L3238">        IValueMeta v = modify.getValueMeta( i );</span>
<span class="nc" id="L3239">        retval += databaseMeta.getModifyColumnStatement( tableName, v, tk, use_autoinc, pk, true );</span>
      }
    }

<span class="nc" id="L3243">    return retval;</span>
  }

  public void truncateTable( String tablename ) throws HopDatabaseException {
<span class="nc bnc" id="L3247" title="All 2 branches missed.">    if ( Utils.isEmpty( connectionGroup ) ) {</span>
<span class="nc" id="L3248">      String truncateStatement = databaseMeta.getTruncateTableStatement( null, tablename );</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">      if ( truncateStatement == null ) {</span>
<span class="nc" id="L3250">        throw new HopDatabaseException( &quot;Truncate table not supported by &quot;</span>
<span class="nc" id="L3251">          + databaseMeta.getIDatabase().getPluginName() );</span>
      }
<span class="nc" id="L3253">      execStatement( truncateStatement );</span>
<span class="nc" id="L3254">    } else {</span>
<span class="nc" id="L3255">      execStatement( &quot;DELETE FROM &quot; + databaseMeta.quoteField( tablename ) );</span>
    }
<span class="nc" id="L3257">  }</span>

  public void truncateTable( String schema, String tablename ) throws HopDatabaseException {
<span class="nc bnc" id="L3260" title="All 2 branches missed.">    if ( Utils.isEmpty( connectionGroup ) ) {</span>
<span class="nc" id="L3261">      String truncateStatement = databaseMeta.getTruncateTableStatement( schema, tablename );</span>
<span class="nc bnc" id="L3262" title="All 2 branches missed.">      if ( truncateStatement == null ) {</span>
<span class="nc" id="L3263">        throw new HopDatabaseException( &quot;Truncate table not supported by &quot;</span>
<span class="nc" id="L3264">          + databaseMeta.getIDatabase().getPluginName() );</span>
      }
<span class="nc" id="L3266">      execStatement( truncateStatement );</span>
<span class="nc" id="L3267">    } else {</span>
<span class="nc" id="L3268">      execStatement( &quot;DELETE FROM &quot; + databaseMeta.getQuotedSchemaTableCombination( schema, tablename ) );</span>
    }
<span class="nc" id="L3270">  }</span>

  /**
   * Execute a query and return at most one row from the resultset
   *
   * @param sql The SQL for the query
   * @return one Row with data or null if nothing was found.
   */
  public RowMetaAndData getOneRow( String sql ) throws HopDatabaseException {
<span class="nc" id="L3279">    ResultSet rs = openQuery( sql );</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">    if ( rs != null ) {</span>
<span class="nc" id="L3281">      Object[] row = getRow( rs ); // One row only;</span>

      try {
<span class="nc" id="L3284">        rs.close();</span>
<span class="nc" id="L3285">      } catch ( Exception e ) {</span>
<span class="nc" id="L3286">        throw new HopDatabaseException( &quot;Unable to close resultset&quot;, e );</span>
<span class="nc" id="L3287">      }</span>

<span class="nc bnc" id="L3289" title="All 2 branches missed.">      if ( pstmt != null ) {</span>
        try {
<span class="nc" id="L3291">          pstmt.close();</span>
<span class="nc" id="L3292">        } catch ( Exception e ) {</span>
<span class="nc" id="L3293">          throw new HopDatabaseException( &quot;Unable to close prepared statement pstmt&quot;, e );</span>
<span class="nc" id="L3294">        }</span>
<span class="nc" id="L3295">        pstmt = null;</span>
      }
<span class="nc bnc" id="L3297" title="All 2 branches missed.">      if ( sel_stmt != null ) {</span>
        try {
<span class="nc" id="L3299">          sel_stmt.close();</span>
<span class="nc" id="L3300">        } catch ( Exception e ) {</span>
<span class="nc" id="L3301">          throw new HopDatabaseException( &quot;Unable to close prepared statement sel_stmt&quot;, e );</span>
<span class="nc" id="L3302">        }</span>
<span class="nc" id="L3303">        sel_stmt = null;</span>
      }
<span class="nc" id="L3305">      return new RowMetaAndData( rowMeta, row );</span>
    } else {
<span class="nc" id="L3307">      throw new HopDatabaseException( &quot;error opening resultset for query: &quot; + sql );</span>
    }
  }

  public RowMeta getMetaFromRow( Object[] row, ResultSetMetaData md ) throws SQLException, HopDatabaseException {
<span class="nc" id="L3312">    RowMeta meta = new RowMeta();</span>

<span class="nc bnc" id="L3314" title="All 2 branches missed.">    for ( int i = 0; i &lt; md.getColumnCount(); i++ ) {</span>
<span class="nc" id="L3315">      IValueMeta valueMeta = getValueFromSqlType( md, i + 1, true, false );</span>
<span class="nc" id="L3316">      meta.addValueMeta( valueMeta );</span>
    }

<span class="nc" id="L3319">    return meta;</span>
  }

  public RowMetaAndData getOneRow( String sql, IRowMeta param, Object[] data ) throws HopDatabaseException {
<span class="nc" id="L3323">    ResultSet rs = openQuery( sql, param, data );</span>
<span class="nc bnc" id="L3324" title="All 2 branches missed.">    if ( rs != null ) {</span>
<span class="nc" id="L3325">      Object[] row = getRow( rs ); // One value: a number;</span>

<span class="nc" id="L3327">      rowMeta = null;</span>
<span class="nc" id="L3328">      RowMeta tmpMeta = null;</span>
      try {

<span class="nc" id="L3331">        ResultSetMetaData md = rs.getMetaData();</span>
<span class="nc" id="L3332">        tmpMeta = getMetaFromRow( row, md );</span>

<span class="nc" id="L3334">      } catch ( Exception e ) {</span>
<span class="nc" id="L3335">        e.printStackTrace();</span>
      } finally {
        try {
<span class="nc" id="L3338">          rs.close();</span>
<span class="nc" id="L3339">        } catch ( Exception e ) {</span>
<span class="nc" id="L3340">          throw new HopDatabaseException( &quot;Unable to close resultset&quot;, e );</span>
<span class="nc" id="L3341">        }</span>

<span class="nc bnc" id="L3343" title="All 2 branches missed.">        if ( pstmt != null ) {</span>
          try {
<span class="nc" id="L3345">            pstmt.close();</span>
<span class="nc" id="L3346">          } catch ( Exception e ) {</span>
<span class="nc" id="L3347">            throw new HopDatabaseException( &quot;Unable to close prepared statement pstmt&quot;, e );</span>
<span class="nc" id="L3348">          }</span>
<span class="nc" id="L3349">          pstmt = null;</span>
        }
<span class="nc bnc" id="L3351" title="All 2 branches missed.">        if ( sel_stmt != null ) {</span>
          try {
<span class="nc" id="L3353">            sel_stmt.close();</span>
<span class="nc" id="L3354">          } catch ( Exception e ) {</span>
<span class="nc" id="L3355">            throw new HopDatabaseException( &quot;Unable to close prepared statement sel_stmt&quot;, e );</span>
<span class="nc" id="L3356">          }</span>
<span class="nc" id="L3357">          sel_stmt = null;</span>
        }

      }

<span class="nc" id="L3362">      return new RowMetaAndData( tmpMeta, row );</span>
    } else {
<span class="nc" id="L3364">      return null;</span>
    }
  }

  public IRowMeta getParameterMetaData( PreparedStatement ps ) {
<span class="nc" id="L3369">    IRowMeta par = new RowMeta();</span>
    try {
<span class="nc" id="L3371">      ParameterMetaData pmd = ps.getParameterMetaData();</span>
<span class="nc bnc" id="L3372" title="All 2 branches missed.">      for ( int i = 1; i &lt;= pmd.getParameterCount(); i++ ) {</span>
<span class="nc" id="L3373">        String name = &quot;par&quot; + i;</span>
<span class="nc" id="L3374">        int sqltype = pmd.getParameterType( i );</span>
<span class="nc" id="L3375">        int length = pmd.getPrecision( i );</span>
<span class="nc" id="L3376">        int precision = pmd.getScale( i );</span>
        IValueMeta val;

<span class="nc bnc" id="L3379" title="All 6 branches missed.">        switch ( sqltype ) {</span>
          case java.sql.Types.CHAR:
          case java.sql.Types.VARCHAR:
<span class="nc" id="L3382">            val = new ValueMetaString( name );</span>
<span class="nc" id="L3383">            break;</span>
          case java.sql.Types.BIGINT:
          case java.sql.Types.INTEGER:
          case java.sql.Types.NUMERIC:
          case java.sql.Types.SMALLINT:
          case java.sql.Types.TINYINT:
<span class="nc" id="L3389">            val = new ValueMetaInteger( name );</span>
<span class="nc" id="L3390">            break;</span>
          case java.sql.Types.DECIMAL:
          case java.sql.Types.DOUBLE:
          case java.sql.Types.FLOAT:
          case java.sql.Types.REAL:
<span class="nc" id="L3395">            val = new ValueMetaNumber( name );</span>
<span class="nc" id="L3396">            break;</span>
          case java.sql.Types.DATE:
          case java.sql.Types.TIME:
          case java.sql.Types.TIMESTAMP:
<span class="nc" id="L3400">            val = new ValueMetaDate( name );</span>
<span class="nc" id="L3401">            break;</span>
          case java.sql.Types.BOOLEAN:
          case java.sql.Types.BIT:
<span class="nc" id="L3404">            val = new ValueMetaBoolean( name );</span>
<span class="nc" id="L3405">            break;</span>
          default:
<span class="nc" id="L3407">            val = new ValueMetaNone( name );</span>
            break;
        }

<span class="nc bnc" id="L3411" title="All 6 branches missed.">        if ( val.isNumeric() &amp;&amp; ( length &gt; 18 || precision &gt; 18 ) ) {</span>
<span class="nc" id="L3412">          val = new ValueMetaBigNumber( name );</span>
        }

<span class="nc" id="L3415">        par.addValueMeta( val );</span>
      }
<span class="nc" id="L3417">    } catch ( AbstractMethodError e ) {</span>
      // Oops: probably the database or JDBC doesn't support it.
<span class="nc" id="L3419">      return null;</span>
<span class="nc" id="L3420">    } catch ( SQLException e ) {</span>
<span class="nc" id="L3421">      return null;</span>
<span class="nc" id="L3422">    } catch ( Exception e ) {</span>
<span class="nc" id="L3423">      return null;</span>
<span class="nc" id="L3424">    }</span>

<span class="nc" id="L3426">    return par;</span>
  }

  public int countParameters( String sql ) {
<span class="nc" id="L3430">    int q = 0;</span>
<span class="nc" id="L3431">    boolean quote_opened = false;</span>
<span class="nc" id="L3432">    boolean dquote_opened = false;</span>

<span class="nc bnc" id="L3434" title="All 2 branches missed.">    for ( int x = 0; x &lt; sql.length(); x++ ) {</span>
<span class="nc" id="L3435">      char c = sql.charAt( x );</span>

<span class="nc bnc" id="L3437" title="All 4 branches missed.">      switch ( c ) {</span>
        case '\'':
<span class="nc bnc" id="L3439" title="All 2 branches missed.">          quote_opened = !quote_opened;</span>
<span class="nc" id="L3440">          break;</span>
        case '&quot;':
<span class="nc bnc" id="L3442" title="All 2 branches missed.">          dquote_opened = !dquote_opened;</span>
<span class="nc" id="L3443">          break;</span>
        case '?':
<span class="nc bnc" id="L3445" title="All 4 branches missed.">          if ( !quote_opened &amp;&amp; !dquote_opened ) {</span>
<span class="nc" id="L3446">            q++;</span>
          }
          break;
        default:
          break;
      }
    }

<span class="nc" id="L3454">    return q;</span>
  }

  // Get the fields back from an SQL query
  public IRowMeta getParameterMetaData( String sql, IRowMeta inform, Object[] data ) {
    // The database couldn't handle it: try manually!
<span class="nc" id="L3460">    int q = countParameters( sql );</span>

<span class="nc" id="L3462">    IRowMeta par = new RowMeta();</span>

<span class="nc bnc" id="L3464" title="All 4 branches missed.">    if ( inform != null &amp;&amp; q == inform.size() ) {</span>
<span class="nc bnc" id="L3465" title="All 2 branches missed.">      for ( int i = 0; i &lt; q; i++ ) {</span>
<span class="nc" id="L3466">        IValueMeta inf = inform.getValueMeta( i );</span>
<span class="nc" id="L3467">        IValueMeta v = inf.clone();</span>
<span class="nc" id="L3468">        par.addValueMeta( v );</span>
      }
    } else {
<span class="nc bnc" id="L3471" title="All 2 branches missed.">      for ( int i = 0; i &lt; q; i++ ) {</span>
<span class="nc" id="L3472">        IValueMeta v = new ValueMetaNumber( &quot;name&quot; + i );</span>
<span class="nc" id="L3473">        par.addValueMeta( v );</span>
      }
    }

<span class="nc" id="L3477">    return par;</span>
  }

  public void writeLogRecord( ILogTableCore logTable, LogStatus status, Object subject, Object parent )
    throws HopDatabaseException {
    try {
<span class="nc" id="L3483">      RowMetaAndData logRecord = logTable.getLogRecord( status, subject, parent );</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">      if ( logRecord == null ) {</span>
<span class="nc" id="L3485">        return;</span>
      }

<span class="nc bnc" id="L3488" title="All 4 branches missed.">      boolean update = ( logTable.getKeyField() != null ) &amp;&amp; !status.equals( LogStatus.START );</span>
<span class="nc" id="L3489">      String schemaTable =</span>
<span class="nc" id="L3490">        databaseMeta.getQuotedSchemaTableCombination(</span>
<span class="nc" id="L3491">          environmentSubstitute( logTable.getActualSchemaName() ), environmentSubstitute( logTable</span>
<span class="nc" id="L3492">            .getActualTableName() ) );</span>
<span class="nc" id="L3493">      IRowMeta rowMeta = logRecord.getRowMeta();</span>
<span class="nc" id="L3494">      Object[] rowData = logRecord.getData();</span>

<span class="nc bnc" id="L3496" title="All 2 branches missed.">      if ( update ) {</span>
<span class="nc" id="L3497">        IRowMeta updateRowMeta = new RowMeta();</span>
<span class="nc" id="L3498">        Object[] updateRowData = new Object[ rowMeta.size() ];</span>
<span class="nc" id="L3499">        IValueMeta keyValueMeta = rowMeta.getValueMeta( 0 );</span>
<span class="nc" id="L3500">        StringBuilder sqlBuff = new StringBuilder( 250 );</span>
<span class="nc" id="L3501">        sqlBuff.append( &quot;UPDATE &quot; ).append( schemaTable ).append( &quot; SET &quot; );</span>

<span class="nc bnc" id="L3503" title="All 2 branches missed.">        for ( int i = 1; i &lt; rowMeta.size(); i++ ) { // Without ID_JOB or ID_BATCH</span>
<span class="nc" id="L3504">          IValueMeta valueMeta = rowMeta.getValueMeta( i );</span>
<span class="nc bnc" id="L3505" title="All 2 branches missed.">          if ( i &gt; 1 ) {</span>
<span class="nc" id="L3506">            sqlBuff.append( &quot;, &quot; );</span>
          }
<span class="nc" id="L3508">          sqlBuff.append( databaseMeta.quoteField( valueMeta.getName() ) ).append( &quot;=? &quot; );</span>

<span class="nc" id="L3510">          updateRowMeta.addValueMeta( valueMeta );</span>
<span class="nc" id="L3511">          updateRowData[ i - 1 ] = rowData[ i ];</span>
        }
<span class="nc" id="L3513">        sqlBuff.append( &quot;WHERE &quot; ).append( databaseMeta.quoteField( keyValueMeta.getName() ) ).append( &quot;=? &quot; );</span>

<span class="nc" id="L3515">        updateRowMeta.addValueMeta( keyValueMeta );</span>
<span class="nc" id="L3516">        updateRowData[ rowMeta.size() - 1 ] = rowData[ 0 ];</span>

<span class="nc" id="L3518">        String sql = sqlBuff.toString();</span>
<span class="nc" id="L3519">        execStatement( sql, updateRowMeta, updateRowData );</span>

<span class="nc" id="L3521">      } else {</span>

<span class="nc" id="L3523">        insertRow( environmentSubstitute( logTable.getActualSchemaName() ), environmentSubstitute( logTable</span>
<span class="nc" id="L3524">          .getActualTableName() ), logRecord.getRowMeta(), logRecord.getData() );</span>

      }
<span class="nc" id="L3527">    } catch ( Exception e ) {</span>
<span class="nc" id="L3528">      DatabaseLogExceptionFactory.getExceptionStrategy( logTable, e )</span>
<span class="nc" id="L3529">        .registerException( log, e, PKG, &quot;Database.Error.WriteLogTable&quot;,</span>
<span class="nc" id="L3530">          environmentSubstitute( logTable.getActualTableName() ) );</span>
<span class="nc" id="L3531">    }</span>
<span class="nc" id="L3532">  }</span>

  public void cleanupLogRecords( ILogTableCore logTable ) throws HopDatabaseException {
<span class="nc" id="L3535">    double timeout = Const.toDouble( Const.trim( environmentSubstitute( logTable.getTimeoutInDays() ) ), 0.0 );</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">    if ( timeout &lt; 0.000001 ) {</span>
      // The timeout has to be at least a few seconds, otherwise we don't
      // bother
<span class="nc" id="L3539">      return;</span>
    }

<span class="nc" id="L3542">    String schemaTable =</span>
<span class="nc" id="L3543">      databaseMeta.getQuotedSchemaTableCombination( environmentSubstitute( logTable.getActualSchemaName() ),</span>
<span class="nc" id="L3544">        environmentSubstitute( logTable.getActualTableName() ) );</span>

<span class="nc bnc" id="L3546" title="All 2 branches missed.">    if ( schemaTable.isEmpty() ) {</span>
      //we can't process without table name
<span class="nc" id="L3548">      DatabaseLogExceptionFactory.getExceptionStrategy( logTable )</span>
<span class="nc" id="L3549">        .registerException( log, PKG, &quot;DatabaseMeta.Error.LogTableNameNotFound&quot; );</span>
    }

<span class="nc" id="L3552">    LogTableField logField = logTable.getLogDateField();</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">    if ( logField == null ) {</span>
      //can't stand without logField
<span class="nc" id="L3555">      DatabaseLogExceptionFactory.getExceptionStrategy( logTable )</span>
<span class="nc" id="L3556">        .registerException( log, PKG, &quot;Database.Exception.LogTimeoutDefinedOnTableWithoutLogField&quot; );</span>
    }

<span class="nc" id="L3559">    String sql =</span>
<span class="nc" id="L3560">      &quot;DELETE FROM &quot; + schemaTable + &quot; WHERE &quot; + databaseMeta.quoteField( logField.getFieldName() ) + &quot; &lt; ?&quot;;</span>
<span class="nc" id="L3561">    long now = System.currentTimeMillis();</span>
<span class="nc" id="L3562">    long limit = now - Math.round( timeout * 24 * 60 * 60 * 1000 );</span>
<span class="nc" id="L3563">    RowMetaAndData row = new RowMetaAndData();</span>
<span class="nc" id="L3564">    row.addValue( logField.getFieldName(), IValueMeta.TYPE_DATE, new Date( limit ) );</span>

    try {
      //fire database
<span class="nc" id="L3568">      execStatement( sql, row.getRowMeta(), row.getData() );</span>
<span class="nc" id="L3569">    } catch ( Exception e ) {</span>
<span class="nc" id="L3570">      DatabaseLogExceptionFactory.getExceptionStrategy( logTable )</span>
<span class="nc" id="L3571">        .registerException( log, PKG, &quot;Database.Exception.UnableToCleanUpOlderRecordsFromLogTable&quot;,</span>
<span class="nc" id="L3572">          environmentSubstitute( logTable.getActualTableName() ) );</span>
<span class="nc" id="L3573">    }</span>
<span class="nc" id="L3574">  }</span>

  public Object[] getLastLogDate( String logtable, String name, boolean workflow, LogStatus status )
    throws HopDatabaseException {
<span class="nc" id="L3578">    Object[] row = null;</span>

<span class="nc bnc" id="L3580" title="All 2 branches missed.">    String jobPipeline = workflow ? databaseMeta.quoteField( &quot;WORKFLOW_NAME&quot; ) : databaseMeta.quoteField( &quot;PIPELINE_NAME&quot; );</span>

<span class="nc" id="L3582">    String sql = &quot;&quot;;</span>
<span class="nc" id="L3583">    sql +=</span>
      &quot; SELECT &quot;
<span class="nc" id="L3585">        + databaseMeta.quoteField( &quot;ENDDATE&quot; ) + &quot;, &quot; + databaseMeta.quoteField( &quot;DEPDATE&quot; ) + &quot;, &quot;</span>
<span class="nc" id="L3586">        + databaseMeta.quoteField( &quot;STARTDATE&quot; );</span>
<span class="nc" id="L3587">    sql += &quot; FROM &quot; + logtable;</span>
<span class="nc" id="L3588">    sql += &quot; WHERE  &quot; + databaseMeta.quoteField( &quot;ERRORS&quot; ) + &quot;    = 0&quot;;</span>
<span class="nc" id="L3589">    sql += &quot; AND    &quot; + databaseMeta.quoteField( &quot;STATUS&quot; ) + &quot;    = 'end'&quot;;</span>
<span class="nc" id="L3590">    sql += &quot; AND    &quot; + jobPipeline + &quot; = ?&quot;;</span>
<span class="nc" id="L3591">    sql +=</span>
      &quot; ORDER BY &quot;
<span class="nc" id="L3593">        + databaseMeta.quoteField( &quot;LOGDATE&quot; ) + &quot; DESC, &quot; + databaseMeta.quoteField( &quot;ENDDATE&quot; ) + &quot; DESC&quot;;</span>

    try {
<span class="nc" id="L3596">      pstmt = connection.prepareStatement( databaseMeta.stripCR( sql ) );</span>

<span class="nc" id="L3598">      IRowMeta r = new RowMeta();</span>
<span class="nc" id="L3599">      r.addValueMeta( new ValueMetaString( &quot;PIPELINE_NAME&quot;, 255, -1 ) );</span>
<span class="nc" id="L3600">      setValues( r, new Object[] { name } );</span>

<span class="nc" id="L3602">      ResultSet res = pstmt.executeQuery();</span>
<span class="nc bnc" id="L3603" title="All 2 branches missed.">      if ( res != null ) {</span>
<span class="nc" id="L3604">        rowMeta = getRowInfo( res.getMetaData(), false, false );</span>
<span class="nc" id="L3605">        row = getRow( res );</span>
<span class="nc" id="L3606">        res.close();</span>
      }
<span class="nc" id="L3608">      pstmt.close();</span>
<span class="nc" id="L3609">      pstmt = null;</span>
<span class="nc" id="L3610">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L3611">      throw new HopDatabaseException( &quot;Unable to obtain last logdate from table &quot; + logtable, ex );</span>
<span class="nc" id="L3612">    }</span>

<span class="nc" id="L3614">    return row;</span>
  }

  public synchronized Long getNextValue( Map&lt;String, Counter&gt; counters, String tableName, String val_key )
    throws HopDatabaseException {
<span class="nc" id="L3619">    return getNextValue( counters, null, tableName, val_key );</span>
  }

  public synchronized Long getNextValue( Map&lt;String, Counter&gt; counters, String schemaName, String tableName,
                                         String val_key ) throws HopDatabaseException {
<span class="nc" id="L3624">    Long nextValue = null;</span>

<span class="nc" id="L3626">    String schemaTable = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>

<span class="nc" id="L3628">    String lookup = schemaTable + &quot;.&quot; + databaseMeta.quoteField( val_key );</span>

    // Try to find the previous sequence value...
<span class="nc" id="L3631">    Counter counter = null;</span>
<span class="nc bnc" id="L3632" title="All 2 branches missed.">    if ( counters != null ) {</span>
<span class="nc" id="L3633">      counter = counters.get( lookup );</span>
    }

<span class="nc bnc" id="L3636" title="All 2 branches missed.">    if ( counter == null ) {</span>
<span class="nc" id="L3637">      RowMetaAndData rmad =</span>
<span class="nc" id="L3638">        getOneRow( &quot;SELECT MAX(&quot; + databaseMeta.quoteField( val_key ) + &quot;) FROM &quot; + schemaTable );</span>
<span class="nc bnc" id="L3639" title="All 2 branches missed.">      if ( rmad != null ) {</span>
        long previous;
        try {
<span class="nc" id="L3642">          Long tmp = rmad.getRowMeta().getInteger( rmad.getData(), 0 );</span>

          // A &quot;select max(x)&quot; on a table with no matching rows will return
          // null.
<span class="nc bnc" id="L3646" title="All 2 branches missed.">          if ( tmp != null ) {</span>
<span class="nc" id="L3647">            previous = tmp.longValue();</span>
          } else {
<span class="nc" id="L3649">            previous = 0L;</span>
          }
<span class="nc" id="L3651">        } catch ( HopValueException e ) {</span>
<span class="nc" id="L3652">          throw new HopDatabaseException(</span>
            &quot;Error getting the first long value from the max value returned from table : &quot; + schemaTable );
<span class="nc" id="L3654">        }</span>
<span class="nc" id="L3655">        counter = new Counter( previous + 1, 1 );</span>
<span class="nc" id="L3656">        nextValue = Long.valueOf( counter.next() );</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">        if ( counters != null ) {</span>
<span class="nc" id="L3658">          counters.put( lookup, counter );</span>
        }
<span class="nc" id="L3660">      } else {</span>
<span class="nc" id="L3661">        throw new HopDatabaseException( &quot;Couldn't find maximum key value from table &quot; + schemaTable );</span>
      }
<span class="nc" id="L3663">    } else {</span>
<span class="nc" id="L3664">      nextValue = Long.valueOf( counter.next() );</span>
    }

<span class="nc" id="L3667">    return nextValue;</span>
  }

  @Override
  public String toString() {
<span class="nc bnc" id="L3672" title="All 2 branches missed.">    if ( databaseMeta != null ) {</span>
<span class="nc" id="L3673">      return databaseMeta.getName();</span>
    } else {
<span class="nc" id="L3675">      return &quot;-&quot;;</span>
    }
  }

  public boolean isSystemTable( String table_name ) {
<span class="nc" id="L3680">    return databaseMeta.isSystemTable( table_name );</span>
  }

  /**
   * Reads the result of an SQL query into an ArrayList
   *
   * @param sql   The SQL to launch
   * @param limit &lt;=0 means unlimited, otherwise this specifies the maximum number of rows read.
   * @return An ArrayList of rows.
   * @throws HopDatabaseException if something goes wrong.
   */
  public List&lt;Object[]&gt; getRows( String sql, int limit ) throws HopDatabaseException {
<span class="nc" id="L3692">    return getRows( sql, limit, null );</span>
  }

  /**
   * Reads the result of an SQL query into an ArrayList
   *
   * @param sql     The SQL to launch
   * @param limit   &lt;=0 means unlimited, otherwise this specifies the maximum number of rows read.
   * @param monitor The progress monitor to update while getting the rows.
   * @return An ArrayList of rows.
   * @throws HopDatabaseException if something goes wrong.
   */
  public List&lt;Object[]&gt; getRows( String sql, int limit, IProgressMonitor monitor )
    throws HopDatabaseException {

<span class="nc" id="L3707">    return getRows( sql, null, null, ResultSet.FETCH_FORWARD, false, limit, monitor );</span>
  }

  /**
   * Reads the result of an SQL query into an ArrayList.
   *
   * @param sql            The SQL to launch
   * @param params         The types of any parameters to be passed to the query
   * @param data           The values of any parameters to be passed to the query
   * @param fetch_mode     The fetch mode for the query (ResultSet.FETCH_FORWARD, e.g.)
   * @param lazyConversion Whether to perform lazy conversion of the values
   * @param limit          &lt;=0 means unlimited, otherwise this specifies the maximum number of rows read.
   * @param monitor        The progress monitor to update while getting the rows.
   * @return An ArrayList of rows.
   * @throws HopDatabaseException if something goes wrong.
   */
  public List&lt;Object[]&gt; getRows( String sql, IRowMeta params, Object[] data, int fetch_mode,
                                 boolean lazyConversion, int limit, IProgressMonitor monitor )
    throws HopDatabaseException {
<span class="nc bnc" id="L3726" title="All 2 branches missed.">    if ( monitor != null ) {</span>
<span class="nc" id="L3727">      monitor.setTaskName( &quot;Opening query...&quot; );</span>
    }
<span class="nc" id="L3729">    ResultSet rset = openQuery( sql, params, data, fetch_mode, lazyConversion );</span>

<span class="nc" id="L3731">    return getRows( rset, limit, monitor );</span>
  }

  /**
   * Reads the result of a ResultSet into an ArrayList
   *
   * @param rset    the ResultSet to read out
   * @param limit   &lt;=0 means unlimited, otherwise this specifies the maximum number of rows read.
   * @param monitor The progress monitor to update while getting the rows.
   * @return An ArrayList of rows.
   * @throws HopDatabaseException if something goes wrong.
   */
  public List&lt;Object[]&gt; getRows( ResultSet rset, int limit, IProgressMonitor monitor )
    throws HopDatabaseException {
    try {
<span class="nc" id="L3746">      List&lt;Object[]&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3747">      boolean stop = false;</span>
<span class="nc" id="L3748">      int i = 0;</span>

<span class="nc bnc" id="L3750" title="All 2 branches missed.">      if ( rset != null ) {</span>
<span class="nc bnc" id="L3751" title="All 4 branches missed.">        if ( monitor != null &amp;&amp; limit &gt; 0 ) {</span>
<span class="nc" id="L3752">          monitor.beginTask( &quot;Reading rows...&quot;, limit );</span>
        }
<span class="nc bnc" id="L3754" title="All 6 branches missed.">        while ( ( limit &lt;= 0 || i &lt; limit ) &amp;&amp; !stop ) {</span>
<span class="nc" id="L3755">          Object[] row = getRow( rset );</span>
<span class="nc bnc" id="L3756" title="All 2 branches missed.">          if ( row != null ) {</span>
<span class="nc" id="L3757">            result.add( row );</span>
<span class="nc" id="L3758">            i++;</span>
          } else {
<span class="nc" id="L3760">            stop = true;</span>
          }
<span class="nc bnc" id="L3762" title="All 4 branches missed.">          if ( monitor != null &amp;&amp; limit &gt; 0 ) {</span>
<span class="nc" id="L3763">            monitor.worked( 1 );</span>
          }
<span class="nc bnc" id="L3765" title="All 4 branches missed.">          if ( monitor != null &amp;&amp; monitor.isCanceled() ) {</span>
<span class="nc" id="L3766">            break;</span>
          }
<span class="nc" id="L3768">        }</span>
<span class="nc" id="L3769">        closeQuery( rset );</span>
<span class="nc bnc" id="L3770" title="All 2 branches missed.">        if ( monitor != null ) {</span>
<span class="nc" id="L3771">          monitor.done();</span>
        }
      }

<span class="nc" id="L3775">      return result;</span>
<span class="nc" id="L3776">    } catch ( Exception e ) {</span>
<span class="nc" id="L3777">      throw new HopDatabaseException( &quot;Unable to get list of rows from ResultSet : &quot;, e );</span>
    }
  }

  public List&lt;Object[]&gt; getFirstRows( String table_name, int limit ) throws HopDatabaseException {
<span class="nc" id="L3782">    return getFirstRows( table_name, limit, null );</span>
  }

  /**
   * Get the first rows from a table (for preview)
   *
   * @param table_name The table name (or schema/table combination): this needs to be quoted properly
   * @param limit      limit &lt;=0 means unlimited, otherwise this specifies the maximum number of rows read.
   * @param monitor    The progress monitor to update while getting the rows.
   * @return An ArrayList of rows.
   * @throws HopDatabaseException in case something goes wrong
   */
  public List&lt;Object[]&gt; getFirstRows( String table_name, int limit, IProgressMonitor monitor )
    throws HopDatabaseException {
<span class="nc" id="L3796">    String sql = &quot;SELECT&quot;;</span>
<span class="nc bnc" id="L3797" title="All 2 branches missed.">    if ( databaseMeta.getIDatabase().isNeoviewVariant() ) {</span>
<span class="nc" id="L3798">      sql += &quot; [FIRST &quot; + limit + &quot;]&quot;;</span>
<span class="nc bnc" id="L3799" title="All 2 branches missed.">    } else if ( databaseMeta.getIDatabase().isSybaseIQVariant() ) {</span>
      // improve support for Sybase IQ
<span class="nc" id="L3801">      sql += &quot; TOP &quot; + limit + &quot; &quot;;</span>
    }
<span class="nc" id="L3803">    sql += &quot; * FROM &quot; + table_name;</span>

<span class="nc bnc" id="L3805" title="All 2 branches missed.">    if ( limit &gt; 0 ) {</span>
<span class="nc" id="L3806">      sql += databaseMeta.getLimitClause( limit );</span>
    }

<span class="nc" id="L3809">    return getRows( sql, limit, monitor );</span>
  }

  public IRowMeta getReturnRowMeta() {
<span class="nc" id="L3813">    return rowMeta;</span>
  }

  public String[] getTableTypes() throws HopDatabaseException {
    try {
<span class="nc" id="L3818">      ArrayList&lt;String&gt; types = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L3820">      ResultSet rstt = getDatabaseMetaData().getTableTypes();</span>
<span class="nc bnc" id="L3821" title="All 2 branches missed.">      while ( rstt.next() ) {</span>
<span class="nc" id="L3822">        String ttype = rstt.getString( &quot;TABLE_TYPE&quot; );</span>
<span class="nc" id="L3823">        types.add( ttype );</span>
<span class="nc" id="L3824">      }</span>

<span class="nc" id="L3826">      return types.toArray( new String[ types.size() ] );</span>
<span class="nc" id="L3827">    } catch ( SQLException e ) {</span>
<span class="nc" id="L3828">      throw new HopDatabaseException( &quot;Unable to get table types from database!&quot;, e );</span>
    }
  }

  public String[] getTablenames() throws HopDatabaseException {
<span class="fc" id="L3833">    return getTablenames( false );</span>
  }

  public String[] getTablenames( boolean includeSchema ) throws HopDatabaseException {
<span class="fc" id="L3837">    return getTablenames( null, includeSchema );</span>
  }

  public String[] getTablenames( String schemanamein, boolean includeSchema ) throws HopDatabaseException {
<span class="fc" id="L3841">    return getTablenames( schemanamein, includeSchema, null );</span>
  }

  public String[] getTablenames( String schemanamein, boolean includeSchema, Map&lt;String, String&gt; props )
    throws HopDatabaseException {
<span class="fc" id="L3846">    Map&lt;String, Collection&lt;String&gt;&gt; tableMap = getTableMap( schemanamein, props );</span>
<span class="fc" id="L3847">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3848" title="All 2 branches covered.">    for ( String schema : tableMap.keySet() ) {</span>
<span class="fc" id="L3849">      Collection&lt;String&gt; tables = tableMap.get( schema );</span>
<span class="fc bfc" id="L3850" title="All 2 branches covered.">      for ( String table : tables ) {</span>
<span class="pc bpc" id="L3851" title="1 of 2 branches missed.">        if ( includeSchema ) {</span>
<span class="nc" id="L3852">          res.add( databaseMeta.getQuotedSchemaTableCombination( schema, table ) );</span>
        } else {
<span class="fc" id="L3854">          res.add( databaseMeta.getQuotedSchemaTableCombination( null, table ) );</span>
        }
<span class="fc" id="L3856">      }</span>
<span class="fc" id="L3857">    }</span>
<span class="fc" id="L3858">    return res.toArray( new String[ res.size() ] );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getTableMap() throws HopDatabaseException {
<span class="nc" id="L3862">    return getTableMap( null );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getTableMap( String schemanamein ) throws HopDatabaseException {
<span class="nc" id="L3866">    return getTableMap( schemanamein, null );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getTableMap( String schemanamein, Map&lt;String, String&gt; props )
    throws HopDatabaseException {
<span class="fc" id="L3871">    String schemaname = schemanamein;</span>
<span class="pc bpc" id="L3872" title="1 of 2 branches missed.">    if ( schemaname == null ) {</span>
<span class="pc bpc" id="L3873" title="1 of 2 branches missed.">      if ( databaseMeta.useSchemaNameForTableList() ) {</span>
<span class="nc" id="L3874">        schemaname = environmentSubstitute( databaseMeta.getUsername() ).toUpperCase();</span>
      }
    }
<span class="fc" id="L3877">    Map&lt;String, Collection&lt;String&gt;&gt; tableMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L3878">    ResultSet alltables = null;</span>
    try {
<span class="fc" id="L3880">      alltables = getDatabaseMetaData().getTables( null, schemaname, null, databaseMeta.getTableTypes() );</span>
<span class="fc bfc" id="L3881" title="All 2 branches covered.">      while ( alltables.next() ) {</span>
<span class="fc" id="L3882">        String cat = &quot;&quot;;</span>
        try {
<span class="fc" id="L3884">          cat = alltables.getString( &quot;TABLE_CAT&quot; );</span>
<span class="nc" id="L3885">        } catch ( Exception e ) {</span>
          // ignore
<span class="nc bnc" id="L3887" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L3888">            log.logDebug( &quot;Error getting tables for field TABLE_CAT (ignored): &quot; + e.toString() );</span>
          }
<span class="fc" id="L3890">        }</span>

<span class="fc" id="L3892">        String schema = &quot;&quot;;</span>
        try {
<span class="fc" id="L3894">          schema = alltables.getString( &quot;TABLE_SCHEM&quot; );</span>
<span class="nc" id="L3895">        } catch ( Exception e ) {</span>
          // ignore
<span class="nc bnc" id="L3897" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L3898">            log.logDebug( &quot;Error getting tables for field TABLE_SCHEM (ignored): &quot; + e.toString() );</span>
          }
<span class="fc" id="L3900">        }</span>

<span class="pc bpc" id="L3902" title="1 of 2 branches missed.">        if ( Utils.isEmpty( schema ) ) {</span>
<span class="fc" id="L3903">          schema = cat;</span>
        }

<span class="fc" id="L3906">        String table = alltables.getString( TABLES_META_DATA_TABLE_NAME );</span>

<span class="pc bpc" id="L3908" title="1 of 2 branches missed.">        if ( log.isRowLevel() ) {</span>
<span class="nc" id="L3909">          log.logRowlevel( toString(), &quot;got table from meta-data: &quot;</span>
<span class="nc" id="L3910">            + databaseMeta.getQuotedSchemaTableCombination( schema, table ) );</span>
        }

        // Check for any extra properties that might require validation
<span class="pc bpc" id="L3914" title="3 of 4 branches missed.">        if ( props != null &amp;&amp; !props.isEmpty() ) {</span>
<span class="nc bnc" id="L3915" title="All 2 branches missed.">          for ( Map.Entry&lt;String, String&gt; prop : props.entrySet() ) {</span>
<span class="nc" id="L3916">            String propName = prop.getKey();</span>

<span class="nc" id="L3918">            String tableProperty = alltables.getString( propName );</span>
<span class="nc bnc" id="L3919" title="All 2 branches missed.">            if ( tableProperty != null ) {</span>
<span class="nc" id="L3920">              String propValue = prop.getValue();</span>

<span class="nc bnc" id="L3922" title="All 2 branches missed.">              if ( tableProperty.equals( propValue ) ) {</span>
<span class="nc" id="L3923">                multimapPut( schema, table, tableMap );</span>
              }
            }
<span class="nc" id="L3926">          }</span>
        } else {
<span class="fc" id="L3928">          multimapPut( schema, table, tableMap );</span>
        }
<span class="fc" id="L3930">      }</span>
<span class="nc" id="L3931">    } catch ( SQLException e ) {</span>
<span class="nc" id="L3932">      log.logError( &quot;Error getting tablenames from schema [&quot; + schemaname + &quot;]&quot; );</span>
    } finally {
      try {
<span class="pc bpc" id="L3935" title="1 of 2 branches missed.">        if ( alltables != null ) {</span>
<span class="fc" id="L3936">          alltables.close();</span>
        }
<span class="nc" id="L3938">      } catch ( SQLException e ) {</span>
<span class="nc" id="L3939">        throw new HopDatabaseException( &quot;Error closing resultset after getting views from schema [&quot;</span>
          + schemaname + &quot;]&quot;, e );
<span class="fc" id="L3941">      }</span>
    }

<span class="pc bpc" id="L3944" title="1 of 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L3945">      log.logDetailed( &quot;read :&quot; + multimapSize( tableMap ) + &quot; table names from db meta-data.&quot; );</span>
    }

<span class="fc" id="L3948">    return tableMap;</span>
  }

  public String[] getViews() throws HopDatabaseException {
<span class="nc" id="L3952">    return getViews( false );</span>
  }

  public String[] getViews( boolean includeSchema ) throws HopDatabaseException {
<span class="nc" id="L3956">    return getViews( null, includeSchema );</span>
  }

  public String[] getViews( String schemanamein, boolean includeSchema ) throws HopDatabaseException {
<span class="nc" id="L3960">    Map&lt;String, Collection&lt;String&gt;&gt; viewMap = getViewMap( schemanamein );</span>
<span class="nc" id="L3961">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3962" title="All 2 branches missed.">    for ( String schema : viewMap.keySet() ) {</span>
<span class="nc" id="L3963">      Collection&lt;String&gt; views = viewMap.get( schema );</span>
<span class="nc bnc" id="L3964" title="All 2 branches missed.">      for ( String view : views ) {</span>
<span class="nc bnc" id="L3965" title="All 2 branches missed.">        if ( includeSchema ) {</span>
<span class="nc" id="L3966">          res.add( databaseMeta.getQuotedSchemaTableCombination( schema, view ) );</span>
        } else {
<span class="nc" id="L3968">          res.add( view );</span>
        }
<span class="nc" id="L3970">      }</span>
<span class="nc" id="L3971">    }</span>
<span class="nc" id="L3972">    return res.toArray( new String[ res.size() ] );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getViewMap() throws HopDatabaseException {
<span class="nc" id="L3976">    return getViewMap( null );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getViewMap( String schemanamein ) throws HopDatabaseException {
<span class="nc bnc" id="L3980" title="All 2 branches missed.">    if ( !databaseMeta.supportsViews() ) {</span>
<span class="nc" id="L3981">      return Collections.emptyMap();</span>
    }

<span class="nc" id="L3984">    String schemaname = schemanamein;</span>
<span class="nc bnc" id="L3985" title="All 2 branches missed.">    if ( schemaname == null ) {</span>
<span class="nc bnc" id="L3986" title="All 2 branches missed.">      if ( databaseMeta.useSchemaNameForTableList() ) {</span>
<span class="nc" id="L3987">        schemaname = environmentSubstitute( databaseMeta.getUsername() ).toUpperCase();</span>
      }
    }

<span class="nc" id="L3991">    Map&lt;String, Collection&lt;String&gt;&gt; viewMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L3992">    ResultSet allviews = null;</span>
    try {
<span class="nc" id="L3994">      allviews = getDatabaseMetaData().getTables( null, schemaname, null, databaseMeta.getViewTypes() );</span>
<span class="nc bnc" id="L3995" title="All 2 branches missed.">      while ( allviews.next() ) {</span>
<span class="nc" id="L3996">        String cat = &quot;&quot;;</span>
        try {
<span class="nc" id="L3998">          cat = allviews.getString( &quot;TABLE_CAT&quot; );</span>
<span class="nc" id="L3999">        } catch ( Exception e ) {</span>
          // ignore
<span class="nc bnc" id="L4001" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L4002">            log.logDebug( &quot;Error getting views for field TABLE_CAT (ignored): &quot; + e.toString() );</span>
          }
<span class="nc" id="L4004">        }</span>

<span class="nc" id="L4006">        String schema = &quot;&quot;;</span>
        try {
<span class="nc" id="L4008">          schema = allviews.getString( &quot;TABLE_SCHEM&quot; );</span>
<span class="nc" id="L4009">        } catch ( Exception e ) {</span>
          // ignore
<span class="nc bnc" id="L4011" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L4012">            log.logDebug( &quot;Error getting views for field TABLE_SCHEM (ignored): &quot; + e.toString() );</span>
          }
<span class="nc" id="L4014">        }</span>

<span class="nc bnc" id="L4016" title="All 2 branches missed.">        if ( Utils.isEmpty( schema ) ) {</span>
<span class="nc" id="L4017">          schema = cat;</span>
        }

<span class="nc" id="L4020">        String table = allviews.getString( TABLES_META_DATA_TABLE_NAME );</span>

<span class="nc bnc" id="L4022" title="All 2 branches missed.">        if ( log.isRowLevel() ) {</span>
<span class="nc" id="L4023">          log.logRowlevel( toString(), &quot;got view from meta-data: &quot;</span>
<span class="nc" id="L4024">            + databaseMeta.getQuotedSchemaTableCombination( schema, table ) );</span>
        }
<span class="nc" id="L4026">        multimapPut( schema, table, viewMap );</span>
<span class="nc" id="L4027">      }</span>
<span class="nc" id="L4028">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4029">      throw new HopDatabaseException( &quot;Error getting views from schema [&quot; + schemaname + &quot;]&quot;, e );</span>
    } finally {
      try {
<span class="nc bnc" id="L4032" title="All 2 branches missed.">        if ( allviews != null ) {</span>
<span class="nc" id="L4033">          allviews.close();</span>
        }
<span class="nc" id="L4035">      } catch ( SQLException e ) {</span>
<span class="nc" id="L4036">        throw new HopDatabaseException( &quot;Error closing resultset after getting views from schema [&quot;</span>
          + schemaname + &quot;]&quot;, e );
<span class="nc" id="L4038">      }</span>
    }

<span class="nc bnc" id="L4041" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L4042">      log.logDetailed( &quot;read :&quot; + multimapSize( viewMap ) + &quot; views from db meta-data.&quot; );</span>
    }

<span class="nc" id="L4045">    return viewMap;</span>
  }

  public String[] getSynonyms() throws HopDatabaseException {
<span class="nc" id="L4049">    return getSynonyms( false );</span>
  }

  public String[] getSynonyms( boolean includeSchema ) throws HopDatabaseException {
<span class="nc" id="L4053">    return getSynonyms( null, includeSchema );</span>
  }

  public String[] getSynonyms( String schemanamein, boolean includeSchema ) throws HopDatabaseException {
<span class="nc" id="L4057">    Map&lt;String, Collection&lt;String&gt;&gt; synonymMap = getSynonymMap( schemanamein );</span>
<span class="nc" id="L4058">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L4059" title="All 2 branches missed.">    for ( String schema : synonymMap.keySet() ) {</span>
<span class="nc" id="L4060">      Collection&lt;String&gt; synonyms = synonymMap.get( schema );</span>
<span class="nc bnc" id="L4061" title="All 2 branches missed.">      for ( String synonym : synonyms ) {</span>
<span class="nc bnc" id="L4062" title="All 2 branches missed.">        if ( includeSchema ) {</span>
<span class="nc" id="L4063">          res.add( databaseMeta.getQuotedSchemaTableCombination( schema, synonym ) );</span>
        } else {
<span class="nc" id="L4065">          res.add( synonym );</span>
        }
<span class="nc" id="L4067">      }</span>
<span class="nc" id="L4068">    }</span>
<span class="nc" id="L4069">    return res.toArray( new String[ res.size() ] );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getSynonymMap() throws HopDatabaseException {
<span class="nc" id="L4073">    return getSynonymMap( null );</span>
  }

  public Map&lt;String, Collection&lt;String&gt;&gt; getSynonymMap( String schemanamein ) throws HopDatabaseException {
<span class="nc bnc" id="L4077" title="All 2 branches missed.">    if ( !databaseMeta.supportsSynonyms() ) {</span>
<span class="nc" id="L4078">      return Collections.emptyMap();</span>
    }

<span class="nc" id="L4081">    String schemaname = schemanamein;</span>
<span class="nc bnc" id="L4082" title="All 2 branches missed.">    if ( schemaname == null ) {</span>
<span class="nc bnc" id="L4083" title="All 2 branches missed.">      if ( databaseMeta.useSchemaNameForTableList() ) {</span>
<span class="nc" id="L4084">        schemaname = environmentSubstitute( databaseMeta.getUsername() ).toUpperCase();</span>
      }
    }
<span class="nc" id="L4087">    Map&lt;String, Collection&lt;String&gt;&gt; synonymMap = new HashMap&lt;&gt;();</span>
    // ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
<span class="nc" id="L4089">    ResultSet alltables = null;</span>
    try {
<span class="nc" id="L4091">      alltables = getDatabaseMetaData().getTables( null, schemaname, null, databaseMeta.getSynonymTypes() );</span>
<span class="nc bnc" id="L4092" title="All 2 branches missed.">      while ( alltables.next() ) {</span>
<span class="nc" id="L4093">        String cat = &quot;&quot;;</span>
        try {
<span class="nc" id="L4095">          cat = alltables.getString( &quot;TABLE_CAT&quot; );</span>
<span class="nc" id="L4096">        } catch ( Exception e ) {</span>
          // ignore
<span class="nc bnc" id="L4098" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L4099">            log.logDebug( &quot;Error getting synonyms for field TABLE_CAT (ignored): &quot; + e.toString() );</span>
          }
<span class="nc" id="L4101">        }</span>

<span class="nc" id="L4103">        String schema = &quot;&quot;;</span>
        try {
<span class="nc" id="L4105">          schema = alltables.getString( &quot;TABLE_SCHEM&quot; );</span>
<span class="nc" id="L4106">        } catch ( Exception e ) {</span>
          // ignore
<span class="nc bnc" id="L4108" title="All 2 branches missed.">          if ( log.isDebug() ) {</span>
<span class="nc" id="L4109">            log.logDebug( &quot;Error getting synonyms for field TABLE_SCHEM (ignored): &quot; + e.toString() );</span>
          }
<span class="nc" id="L4111">        }</span>

<span class="nc bnc" id="L4113" title="All 2 branches missed.">        if ( Utils.isEmpty( schema ) ) {</span>
<span class="nc" id="L4114">          schema = cat;</span>
        }

<span class="nc" id="L4117">        String table = alltables.getString( TABLES_META_DATA_TABLE_NAME );</span>

<span class="nc bnc" id="L4119" title="All 2 branches missed.">        if ( log.isRowLevel() ) {</span>
<span class="nc" id="L4120">          log.logRowlevel( toString(), &quot;got synonym from meta-data: &quot;</span>
<span class="nc" id="L4121">            + databaseMeta.getQuotedSchemaTableCombination( schema, table ) );</span>
        }
<span class="nc" id="L4123">        multimapPut( schema, table, synonymMap );</span>
<span class="nc" id="L4124">      }</span>
<span class="nc" id="L4125">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4126">      throw new HopDatabaseException( &quot;Error getting synonyms from schema [&quot; + schemaname + &quot;]&quot;, e );</span>
    } finally {
      try {
<span class="nc bnc" id="L4129" title="All 2 branches missed.">        if ( alltables != null ) {</span>
<span class="nc" id="L4130">          alltables.close();</span>
        }
<span class="nc" id="L4132">      } catch ( SQLException e ) {</span>
<span class="nc" id="L4133">        throw new HopDatabaseException( &quot;Error closing resultset after getting synonyms from schema [&quot;</span>
          + schemaname + &quot;]&quot;, e );
<span class="nc" id="L4135">      }</span>
    }

<span class="nc bnc" id="L4138" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L4139">      log.logDetailed( &quot;read :&quot; + multimapSize( synonymMap ) + &quot; synonyms from db meta-data.&quot; );</span>
    }

<span class="nc" id="L4142">    return synonymMap;</span>
  }

  private &lt;K, V&gt; void multimapPut( final K key, final V value, final Map&lt;K, Collection&lt;V&gt;&gt; map ) {
<span class="fc" id="L4146">    Collection&lt;V&gt; valueCollection = map.get( key );</span>
<span class="pc bpc" id="L4147" title="1 of 2 branches missed.">    if ( valueCollection == null ) {</span>
<span class="fc" id="L4148">      valueCollection = new HashSet&lt;&gt;();</span>
    }
<span class="fc" id="L4150">    valueCollection.add( value );</span>
<span class="fc" id="L4151">    map.put( key, valueCollection );</span>
<span class="fc" id="L4152">  }</span>

  private &lt;K, V&gt; int multimapSize( final Map&lt;K, Collection&lt;V&gt;&gt; map ) {
<span class="nc" id="L4155">    int count = 0;</span>
<span class="nc bnc" id="L4156" title="All 2 branches missed.">    for ( Collection&lt;V&gt; valueCollection : map.values() ) {</span>
<span class="nc" id="L4157">      count += valueCollection.size();</span>
<span class="nc" id="L4158">    }</span>
<span class="nc" id="L4159">    return count;</span>
  }

  public String[] getSchemas() throws HopDatabaseException {
<span class="nc" id="L4163">    ArrayList&lt;String&gt; catalogList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4164">    ResultSet catalogResultSet = null;</span>
    try {
<span class="nc" id="L4166">      catalogResultSet = getDatabaseMetaData().getSchemas();</span>
      // Grab all the catalog names and put them in an array list
<span class="nc bnc" id="L4168" title="All 4 branches missed.">      while ( catalogResultSet != null &amp;&amp; catalogResultSet.next() ) {</span>
<span class="nc" id="L4169">        catalogList.add( catalogResultSet.getString( 1 ) );</span>
      }
<span class="nc" id="L4171">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4172">      throw new HopDatabaseException( &quot;Error getting schemas!&quot;, e );</span>
    } finally {
      try {
<span class="nc bnc" id="L4175" title="All 2 branches missed.">        if ( catalogResultSet != null ) {</span>
<span class="nc" id="L4176">          catalogResultSet.close();</span>
        }
<span class="nc" id="L4178">      } catch ( SQLException e ) {</span>
<span class="nc" id="L4179">        throw new HopDatabaseException( &quot;Error closing resultset after getting schemas!&quot;, e );</span>
<span class="nc" id="L4180">      }</span>
    }

<span class="nc bnc" id="L4183" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L4184">      log.logDetailed( &quot;read :&quot; + catalogList.size() + &quot; schemas from db meta-data.&quot; );</span>
    }

<span class="nc" id="L4187">    return catalogList.toArray( new String[ catalogList.size() ] );</span>
  }

  public String[] getCatalogs() throws HopDatabaseException {
<span class="nc" id="L4191">    ArrayList&lt;String&gt; catalogList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4192">    ResultSet catalogResultSet = null;</span>
    try {
<span class="nc" id="L4194">      catalogResultSet = getDatabaseMetaData().getCatalogs();</span>
      // Grab all the catalog names and put them in an array list
<span class="nc bnc" id="L4196" title="All 4 branches missed.">      while ( catalogResultSet != null &amp;&amp; catalogResultSet.next() ) {</span>
<span class="nc" id="L4197">        catalogList.add( catalogResultSet.getString( 1 ) );</span>
      }
<span class="nc" id="L4199">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4200">      throw new HopDatabaseException( &quot;Error getting catalogs!&quot;, e );</span>
    } finally {
      try {
<span class="nc bnc" id="L4203" title="All 2 branches missed.">        if ( catalogResultSet != null ) {</span>
<span class="nc" id="L4204">          catalogResultSet.close();</span>
        }
<span class="nc" id="L4206">      } catch ( SQLException e ) {</span>
<span class="nc" id="L4207">        throw new HopDatabaseException( &quot;Error closing resultset after getting catalogs!&quot;, e );</span>
<span class="nc" id="L4208">      }</span>
    }

<span class="nc bnc" id="L4211" title="All 2 branches missed.">    if ( log.isDetailed() ) {</span>
<span class="nc" id="L4212">      log.logDetailed( &quot;read :&quot; + catalogList.size() + &quot; catalogs from db meta-data.&quot; );</span>
    }

<span class="nc" id="L4215">    return catalogList.toArray( new String[ catalogList.size() ] );</span>
  }

  public String[] getProcedures() throws HopDatabaseException {
<span class="nc" id="L4219">    String sql = databaseMeta.getSqlListOfProcedures();</span>
<span class="nc bnc" id="L4220" title="All 2 branches missed.">    if ( sql != null ) {</span>
<span class="nc" id="L4221">      List&lt;Object[]&gt; procs = getRows( sql, 1000 );</span>
<span class="nc" id="L4222">      String[] str = new String[ procs.size() ];</span>
<span class="nc bnc" id="L4223" title="All 2 branches missed.">      for ( int i = 0; i &lt; procs.size(); i++ ) {</span>
<span class="nc" id="L4224">        str[ i ] = procs.get( i )[ 0 ].toString();</span>
      }
<span class="nc" id="L4226">      return str;</span>
    } else {
<span class="nc" id="L4228">      ResultSet rs = null;</span>
      try {
<span class="nc" id="L4230">        DatabaseMetaData dbmd = getDatabaseMetaData();</span>
<span class="nc" id="L4231">        rs = dbmd.getProcedures( null, null, null );</span>
<span class="nc" id="L4232">        List&lt;Object[]&gt; rows = getRows( rs, 0, null );</span>
<span class="nc" id="L4233">        String[] result = new String[ rows.size() ];</span>
<span class="nc bnc" id="L4234" title="All 2 branches missed.">        for ( int i = 0; i &lt; rows.size(); i++ ) {</span>
<span class="nc" id="L4235">          Object[] row = rows.get( i );</span>
<span class="nc" id="L4236">          String procCatalog = rowMeta.getString( row, &quot;PROCEDURE_CAT&quot;, null );</span>
<span class="nc" id="L4237">          String procSchema = rowMeta.getString( row, &quot;PROCEDURE_SCHEM&quot;, null );</span>
<span class="nc" id="L4238">          String procName = rowMeta.getString( row, &quot;PROCEDURE_NAME&quot;, &quot;&quot; );</span>

<span class="nc" id="L4240">          StringBuilder name = new StringBuilder( &quot;&quot; );</span>
<span class="nc bnc" id="L4241" title="All 2 branches missed.">          if ( procCatalog != null ) {</span>
<span class="nc" id="L4242">            name.append( procCatalog ).append( &quot;.&quot; );</span>
          }
<span class="nc bnc" id="L4244" title="All 2 branches missed.">          if ( procSchema != null ) {</span>
<span class="nc" id="L4245">            name.append( procSchema ).append( &quot;.&quot; );</span>
          }

<span class="nc" id="L4248">          name.append( procName );</span>

<span class="nc" id="L4250">          result[ i ] = name.toString();</span>
        }
<span class="nc" id="L4252">        return result;</span>
<span class="nc" id="L4253">      } catch ( Exception e ) {</span>
<span class="nc" id="L4254">        throw new HopDatabaseException( &quot;Unable to get list of procedures from database meta-data: &quot;, e );</span>
      } finally {
<span class="nc bnc" id="L4256" title="All 2 branches missed.">        if ( rs != null ) {</span>
          try {
<span class="nc" id="L4258">            rs.close();</span>
<span class="nc" id="L4259">          } catch ( Exception e ) {</span>
            // ignore the error.
<span class="nc" id="L4261">          }</span>
        }
      }
    }
  }

  public boolean isAutoCommit() {
<span class="fc bfc" id="L4268" title="All 2 branches covered.">    return commitsize &lt;= 0;</span>
  }

  /**
   * @return Returns the databaseMeta.
   */
  public DatabaseMeta getDatabaseMeta() {
<span class="fc" id="L4275">    return databaseMeta;</span>
  }

  /**
   * Lock a tables in the database for write operations
   *
   * @param tableNames The tables to lock. These need to be the appropriately quoted fully qualified (schema+table)
   *                   names.
   * @throws HopDatabaseException
   */
  public void lockTables( String[] tableNames ) throws HopDatabaseException {
<span class="nc bnc" id="L4286" title="All 2 branches missed.">    if ( Utils.isEmpty( tableNames ) ) {</span>
<span class="nc" id="L4287">      return;</span>
    }

    // Get the SQL to lock the (quoted) tables
    //
<span class="nc" id="L4292">    String sql = databaseMeta.getSqlLockTables( tableNames );</span>
<span class="nc bnc" id="L4293" title="All 2 branches missed.">    if ( sql != null ) {</span>
<span class="nc" id="L4294">      execStatements( sql );</span>
    }
<span class="nc" id="L4296">  }</span>

  /**
   * Unlock certain tables in the database for write operations
   *
   * @param tableNames The tables to unlock
   * @throws HopDatabaseException
   */
  public void unlockTables( String[] tableNames ) throws HopDatabaseException {
<span class="nc bnc" id="L4305" title="All 2 branches missed.">    if ( Utils.isEmpty( tableNames ) ) {</span>
<span class="nc" id="L4306">      return;</span>
    }

    // Quote table names too...
    //
<span class="nc" id="L4311">    String[] quotedTableNames = new String[ tableNames.length ];</span>
<span class="nc bnc" id="L4312" title="All 2 branches missed.">    for ( int i = 0; i &lt; tableNames.length; i++ ) {</span>
<span class="nc" id="L4313">      quotedTableNames[ i ] = databaseMeta.getQuotedSchemaTableCombination( null, tableNames[ i ] );</span>
    }

    // Get the SQL to unlock the (quoted) tables
    //
<span class="nc" id="L4318">    String sql = databaseMeta.getSqlUnlockTables( quotedTableNames );</span>
<span class="nc bnc" id="L4319" title="All 2 branches missed.">    if ( sql != null ) {</span>
<span class="nc" id="L4320">      execStatement( sql );</span>
    }
<span class="nc" id="L4322">  }</span>

  /**
   * @return the opened
   */
  public int getOpened() {
<span class="fc" id="L4328">    return opened;</span>
  }

  /**
   * @param opened the opened to set
   */
  public synchronized void setOpened( int opened ) {
<span class="nc" id="L4335">    this.opened = opened;</span>
<span class="nc" id="L4336">  }</span>

  /**
   * @return the connectionGroup
   */
  public String getConnectionGroup() {
<span class="nc" id="L4342">    return connectionGroup;</span>
  }

  /**
   * @param connectionGroup the connectionGroup to set
   */
  public void setConnectionGroup( String connectionGroup ) {
<span class="fc" id="L4349">    this.connectionGroup = connectionGroup;</span>
<span class="fc" id="L4350">  }</span>

  /**
   * @return the partitionId
   */
  public String getPartitionId() {
<span class="nc" id="L4356">    return partitionId;</span>
  }

  /**
   * @param partitionId the partitionId to set
   */
  public void setPartitionId( String partitionId ) {
<span class="nc" id="L4363">    this.partitionId = partitionId;</span>
<span class="nc" id="L4364">  }</span>

  /**
   * @return the copy
   */
  public int getCopy() {
<span class="fc" id="L4370">    return copy;</span>
  }

  /**
   * @param copy the copy to set
   */
  public synchronized void setCopy( int copy ) {
<span class="nc" id="L4377">    this.copy = copy;</span>
<span class="nc" id="L4378">  }</span>

  @Override
  public void copyVariablesFrom( IVariables variables ) {
<span class="nc" id="L4382">    variables.copyVariablesFrom( variables );</span>
<span class="nc" id="L4383">  }</span>

  @Override
  public String environmentSubstitute( String aString ) {
<span class="nc" id="L4387">    return variables.environmentSubstitute( aString );</span>
  }

  @Override
  public String[] environmentSubstitute( String[] aString ) {
<span class="nc" id="L4392">    return variables.environmentSubstitute( aString );</span>
  }

  @Override
  public String fieldSubstitute( String aString, IRowMeta rowMeta, Object[] rowData )
    throws HopValueException {
<span class="nc" id="L4398">    return variables.fieldSubstitute( aString, rowMeta, rowData );</span>
  }

  @Override
  public IVariables getParentVariableSpace() {
<span class="nc" id="L4403">    return variables.getParentVariableSpace();</span>
  }

  @Override
  public void setParentVariableSpace( IVariables parent ) {
<span class="nc" id="L4408">    variables.setParentVariableSpace( parent );</span>
<span class="nc" id="L4409">  }</span>

  @Override
  public String getVariable( String variableName, String defaultValue ) {
<span class="nc" id="L4413">    return variables.getVariable( variableName, defaultValue );</span>
  }

  @Override
  public String getVariable( String variableName ) {
<span class="nc" id="L4418">    return variables.getVariable( variableName );</span>
  }

  @Override
  public boolean getBooleanValueOfVariable( String variableName, boolean defaultValue ) {
<span class="nc bnc" id="L4423" title="All 2 branches missed.">    if ( !Utils.isEmpty( variableName ) ) {</span>
<span class="nc" id="L4424">      String value = environmentSubstitute( variableName );</span>
<span class="nc bnc" id="L4425" title="All 2 branches missed.">      if ( !Utils.isEmpty( value ) ) {</span>
<span class="nc" id="L4426">        return ValueMetaBase.convertStringToBoolean( value );</span>
      }
    }
<span class="nc" id="L4429">    return defaultValue;</span>
  }

  @Override
  public void initializeVariablesFrom( IVariables parent ) {
<span class="nc" id="L4434">    variables.initializeVariablesFrom( parent );</span>
<span class="nc" id="L4435">  }</span>

  @Override
  public String[] listVariables() {
<span class="nc" id="L4439">    return variables.listVariables();</span>
  }

  @Override
  public void setVariable( String variableName, String variableValue ) {
<span class="nc" id="L4444">    variables.setVariable( variableName, variableValue );</span>
<span class="nc" id="L4445">  }</span>

  @Override
  public void shareVariablesWith( IVariables variables ) {
<span class="fc" id="L4449">    this.variables = variables;</span>

    // Also share the variables with the meta data object
    // Make sure it's not the databaseMeta object itself. We would get an
    // infinite loop in that case.
    //
<span class="pc bpc" id="L4455" title="1 of 2 branches missed.">    if ( variables != databaseMeta ) {</span>
<span class="nc" id="L4456">      databaseMeta.shareVariablesWith( variables );</span>
    }
<span class="fc" id="L4458">  }</span>

  @Override
  public void injectVariables( Map&lt;String, String&gt; prop ) {
<span class="nc" id="L4462">    variables.injectVariables( prop );</span>
<span class="nc" id="L4463">  }</span>

  public RowMetaAndData callProcedure( String[] arg, String[] argdir, int[] argtype, String resultname,
                                       int resulttype ) throws HopDatabaseException {
    RowMetaAndData ret;
    try {
<span class="nc" id="L4469">      boolean moreResults = cstmt.execute();</span>
<span class="nc" id="L4470">      ret = new RowMetaAndData();</span>
<span class="nc" id="L4471">      int pos = 1;</span>
<span class="nc bnc" id="L4472" title="All 4 branches missed.">      if ( resultname != null &amp;&amp; resultname.length() != 0 ) {</span>
<span class="nc" id="L4473">        IValueMeta vMeta = ValueMetaFactory.createValueMeta( resultname, resulttype );</span>
<span class="nc" id="L4474">        Object v = null;</span>
<span class="nc bnc" id="L4475" title="All 8 branches missed.">        switch ( resulttype ) {</span>
          case IValueMeta.TYPE_BOOLEAN:
<span class="nc" id="L4477">            v = Boolean.valueOf( cstmt.getBoolean( pos ) );</span>
<span class="nc" id="L4478">            break;</span>
          case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L4480">            v = Double.valueOf( cstmt.getDouble( pos ) );</span>
<span class="nc" id="L4481">            break;</span>
          case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L4483">            v = cstmt.getBigDecimal( pos );</span>
<span class="nc" id="L4484">            break;</span>
          case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L4486">            v = Long.valueOf( cstmt.getLong( pos ) );</span>
<span class="nc" id="L4487">            break;</span>
          case IValueMeta.TYPE_STRING:
<span class="nc" id="L4489">            v = cstmt.getString( pos );</span>
<span class="nc" id="L4490">            break;</span>
          case IValueMeta.TYPE_BINARY:
<span class="nc bnc" id="L4492" title="All 2 branches missed.">            if ( databaseMeta.supportsGetBlob() ) {</span>
<span class="nc" id="L4493">              Blob blob = cstmt.getBlob( pos );</span>
<span class="nc bnc" id="L4494" title="All 2 branches missed.">              if ( blob != null ) {</span>
<span class="nc" id="L4495">                v = blob.getBytes( 1L, (int) blob.length() );</span>
              } else {
<span class="nc" id="L4497">                v = null;</span>
              }
<span class="nc" id="L4499">            } else {</span>
<span class="nc" id="L4500">              v = cstmt.getBytes( pos );</span>
            }
<span class="nc" id="L4502">            break;</span>
          case IValueMeta.TYPE_DATE:
<span class="nc bnc" id="L4504" title="All 2 branches missed.">            if ( databaseMeta.supportsTimeStampToDateConversion() ) {</span>
<span class="nc" id="L4505">              v = cstmt.getTimestamp( pos );</span>
            } else {
<span class="nc" id="L4507">              v = cstmt.getDate( pos );</span>
            }
<span class="nc" id="L4509">            break;</span>
          default:
            break;
        }
<span class="nc" id="L4513">        ret.addValue( vMeta, v );</span>
<span class="nc" id="L4514">        pos++;</span>
      }
<span class="nc bnc" id="L4516" title="All 2 branches missed.">      for ( int i = 0; i &lt; arg.length; i++ ) {</span>
<span class="nc bnc" id="L4517" title="All 4 branches missed.">        if ( argdir[ i ].equalsIgnoreCase( &quot;OUT&quot; ) || argdir[ i ].equalsIgnoreCase( &quot;INOUT&quot; ) ) {</span>
<span class="nc" id="L4518">          IValueMeta vMeta = ValueMetaFactory.createValueMeta( arg[ i ], argtype[ i ] );</span>
<span class="nc" id="L4519">          Object v = null;</span>
<span class="nc bnc" id="L4520" title="All 8 branches missed.">          switch ( argtype[ i ] ) {</span>
            case IValueMeta.TYPE_BOOLEAN:
<span class="nc" id="L4522">              v = Boolean.valueOf( cstmt.getBoolean( pos + i ) );</span>
<span class="nc" id="L4523">              break;</span>
            case IValueMeta.TYPE_NUMBER:
<span class="nc" id="L4525">              v = Double.valueOf( cstmt.getDouble( pos + i ) );</span>
<span class="nc" id="L4526">              break;</span>
            case IValueMeta.TYPE_BIGNUMBER:
<span class="nc" id="L4528">              v = cstmt.getBigDecimal( pos + i );</span>
<span class="nc" id="L4529">              break;</span>
            case IValueMeta.TYPE_INTEGER:
<span class="nc" id="L4531">              v = Long.valueOf( cstmt.getLong( pos + i ) );</span>
<span class="nc" id="L4532">              break;</span>
            case IValueMeta.TYPE_STRING:
<span class="nc" id="L4534">              v = cstmt.getString( pos + i );</span>
<span class="nc" id="L4535">              break;</span>
            case IValueMeta.TYPE_BINARY:
<span class="nc bnc" id="L4537" title="All 2 branches missed.">              if ( databaseMeta.supportsGetBlob() ) {</span>
<span class="nc" id="L4538">                Blob blob = cstmt.getBlob( pos + i );</span>
<span class="nc bnc" id="L4539" title="All 2 branches missed.">                if ( blob != null ) {</span>
<span class="nc" id="L4540">                  v = blob.getBytes( 1L, (int) blob.length() );</span>
                } else {
<span class="nc" id="L4542">                  v = null;</span>
                }
<span class="nc" id="L4544">              } else {</span>
<span class="nc" id="L4545">                v = cstmt.getBytes( pos + i );</span>
              }
<span class="nc" id="L4547">              break;</span>
            case IValueMeta.TYPE_DATE:
<span class="nc bnc" id="L4549" title="All 2 branches missed.">              if ( databaseMeta.supportsTimeStampToDateConversion() ) {</span>
<span class="nc" id="L4550">                v = cstmt.getTimestamp( pos + i );</span>
              } else {
<span class="nc" id="L4552">                v = cstmt.getDate( pos + i );</span>
              }
<span class="nc" id="L4554">              break;</span>
            default:
              break;
          }
<span class="nc" id="L4558">          ret.addValue( vMeta, v );</span>
        }
      }
<span class="nc" id="L4561">      ResultSet rs = null;</span>
<span class="nc" id="L4562">      int updateCount = -1;</span>

      // CHE: Iterate through the result sets and update counts
      // to receive all error messages from within the stored procedure.
      // This is only the first transform to ensure that the stored procedure
      // is properly executed. A future extension would be to return all
      // result sets and update counts properly.

      do {
<span class="nc" id="L4571">        rs = null;</span>
        try {
          // Save the result set
<span class="nc bnc" id="L4574" title="All 2 branches missed.">          if ( moreResults ) {</span>
<span class="nc" id="L4575">            rs = cstmt.getResultSet();</span>

          } else {
            // Save the update count if it is available (&gt; -1)
<span class="nc" id="L4579">            updateCount = cstmt.getUpdateCount();</span>

          }

<span class="nc" id="L4583">          moreResults = cstmt.getMoreResults();</span>

        } finally {
<span class="nc bnc" id="L4586" title="All 2 branches missed.">          if ( rs != null ) {</span>
<span class="nc" id="L4587">            rs.close();</span>
<span class="nc" id="L4588">            rs = null;</span>
          }
        }

<span class="nc bnc" id="L4592" title="All 4 branches missed.">      } while ( moreResults || ( updateCount &gt; -1 ) );</span>

<span class="nc" id="L4594">      return ret;</span>
<span class="nc" id="L4595">    } catch ( Exception ex ) {</span>
<span class="nc" id="L4596">      throw new HopDatabaseException( &quot;Unable to call procedure&quot;, ex );</span>
    }

  }

  public void closeProcedureStatement() throws HopDatabaseException {
    // CHE: close the callable statement involved in the stored
    // procedure call!
    try {
<span class="nc bnc" id="L4605" title="All 2 branches missed.">      if ( cstmt != null ) {</span>
<span class="nc" id="L4606">        cstmt.close();</span>
<span class="nc" id="L4607">        cstmt = null;</span>
      }
<span class="nc" id="L4609">    } catch ( SQLException ex ) {</span>
<span class="nc" id="L4610">      throw new HopDatabaseException( BaseMessages.getString(</span>
        PKG, &quot;Database.Exception.ErrorClosingCallableStatement&quot; ), ex );
<span class="nc" id="L4612">    }</span>
<span class="nc" id="L4613">  }</span>

  /**
   * Return SQL CREATION statement for a Table
   *
   * @param tableName The table to create
   * @throws HopDatabaseException
   */

  public String getDDLCreationTable( String tableName, IRowMeta fields ) throws HopDatabaseException {
    String retval;

    // First, check for reserved SQL in the input row r...
<span class="nc" id="L4626">    databaseMeta.quoteReservedWords( fields );</span>
<span class="nc" id="L4627">    String quotedTk = databaseMeta.quoteField( null );</span>
<span class="nc" id="L4628">    retval = getCreateTableStatement( tableName, fields, quotedTk, false, null, true );</span>

<span class="nc" id="L4630">    return retval;</span>
  }

  /**
   * Return SQL TRUNCATE statement for a Table
   *
   * @param schema    The schema
   * @param tablename The table to create
   * @throws HopDatabaseException
   */
  public String getDDLTruncateTable( String schema, String tablename ) throws HopDatabaseException {
<span class="nc bnc" id="L4641" title="All 2 branches missed.">    if ( Utils.isEmpty( connectionGroup ) ) {</span>
<span class="nc" id="L4642">      String truncateStatement = databaseMeta.getTruncateTableStatement( schema, tablename );</span>
<span class="nc bnc" id="L4643" title="All 2 branches missed.">      if ( truncateStatement == null ) {</span>
<span class="nc" id="L4644">        throw new HopDatabaseException( &quot;Truncate table not supported by &quot;</span>
<span class="nc" id="L4645">          + databaseMeta.getIDatabase().getPluginName() );</span>
      }
<span class="nc" id="L4647">      return truncateStatement;</span>
    } else {
<span class="nc" id="L4649">      return ( &quot;DELETE FROM &quot; + databaseMeta.getQuotedSchemaTableCombination( schema, tablename ) );</span>
    }
  }

  /**
   * Return SQL statement (INSERT INTO TableName ...
   *
   * @param schemaName tableName The schema
   * @param tableName
   * @param fields
   * @param dateFormat date format of field
   * @throws HopDatabaseException
   */

  public String getSqlOutput( String schemaName, String tableName, IRowMeta fields, Object[] r,
                              String dateFormat ) throws HopDatabaseException {
<span class="nc" id="L4665">    StringBuilder ins = new StringBuilder( 128 );</span>

    try {
<span class="nc" id="L4668">      String schemaTable = databaseMeta.getQuotedSchemaTableCombination( schemaName, tableName );</span>
<span class="nc" id="L4669">      ins.append( &quot;INSERT INTO &quot; ).append( schemaTable ).append( '(' );</span>

      // now add the names in the row:
<span class="nc bnc" id="L4672" title="All 2 branches missed.">      for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="nc bnc" id="L4673" title="All 2 branches missed.">        if ( i &gt; 0 ) {</span>
<span class="nc" id="L4674">          ins.append( &quot;, &quot; );</span>
        }
<span class="nc" id="L4676">        String name = fields.getValueMeta( i ).getName();</span>
<span class="nc" id="L4677">        ins.append( databaseMeta.quoteField( name ) );</span>

      }
<span class="nc" id="L4680">      ins.append( &quot;) VALUES (&quot; );</span>

<span class="nc" id="L4682">      java.text.SimpleDateFormat[] fieldDateFormatters = new java.text.SimpleDateFormat[ fields.size() ];</span>

      // new add values ...
<span class="nc bnc" id="L4685" title="All 2 branches missed.">      for ( int i = 0; i &lt; fields.size(); i++ ) {</span>
<span class="nc" id="L4686">        IValueMeta valueMeta = fields.getValueMeta( i );</span>
<span class="nc" id="L4687">        Object valueData = r[ i ];</span>

<span class="nc bnc" id="L4689" title="All 2 branches missed.">        if ( i &gt; 0 ) {</span>
<span class="nc" id="L4690">          ins.append( &quot;,&quot; );</span>
        }

        // Check for null values...
        //
<span class="nc bnc" id="L4695" title="All 2 branches missed.">        if ( valueMeta.isNull( valueData ) ) {</span>
<span class="nc" id="L4696">          ins.append( &quot;null&quot; );</span>
        } else {
          // Normal cases...
          //
<span class="nc bnc" id="L4700" title="All 3 branches missed.">          switch ( valueMeta.getType() ) {</span>
            case IValueMeta.TYPE_BOOLEAN:
            case IValueMeta.TYPE_STRING:
<span class="nc" id="L4703">              String string = valueMeta.getString( valueData );</span>
              // Have the database dialect do the quoting.
              // This also adds the single quotes around the string (thanks to
              // PostgreSQL)
              //
<span class="nc" id="L4708">              string = databaseMeta.quoteSqlString( string );</span>
<span class="nc" id="L4709">              ins.append( string );</span>
<span class="nc" id="L4710">              break;</span>
            case IValueMeta.TYPE_DATE:
<span class="nc" id="L4712">              Date date = fields.getDate( r, i );</span>

<span class="nc bnc" id="L4714" title="All 2 branches missed.">              if ( Utils.isEmpty( dateFormat ) ) {</span>
<span class="nc bnc" id="L4715" title="All 2 branches missed.">                if ( databaseMeta.getIDatabase().isOracleVariant() ) {</span>
<span class="nc bnc" id="L4716" title="All 2 branches missed.">                  if ( fieldDateFormatters[ i ] == null ) {</span>
<span class="nc" id="L4717">                    fieldDateFormatters[ i ] = new java.text.SimpleDateFormat( &quot;yyyy/MM/dd HH:mm:ss&quot; );</span>
                  }
<span class="nc" id="L4719">                  ins.append( &quot;TO_DATE('&quot; ).append( fieldDateFormatters[ i ].format( date ) ).append(</span>
                    &quot;', 'YYYY/MM/DD HH24:MI:SS')&quot; );
                } else {
<span class="nc" id="L4722">                  ins.append( &quot;'&quot; + fields.getString( r, i ) + &quot;'&quot; );</span>
                }
              } else {
                try {
<span class="nc" id="L4726">                  java.text.SimpleDateFormat formatter = new java.text.SimpleDateFormat( dateFormat );</span>
<span class="nc" id="L4727">                  ins.append( &quot;'&quot; + formatter.format( fields.getDate( r, i ) ) + &quot;'&quot; );</span>
<span class="nc" id="L4728">                } catch ( Exception e ) {</span>
<span class="nc" id="L4729">                  throw new HopDatabaseException( &quot;Error : &quot;, e );</span>
<span class="nc" id="L4730">                }</span>
              }
              break;
            default:
<span class="nc" id="L4734">              ins.append( fields.getString( r, i ) );</span>
              break;
          }
        }

      }
<span class="nc" id="L4740">      ins.append( ')' );</span>
<span class="nc" id="L4741">    } catch ( Exception e ) {</span>
<span class="nc" id="L4742">      throw new HopDatabaseException( e );</span>
<span class="nc" id="L4743">    }</span>
<span class="nc" id="L4744">    return ins.toString();</span>
  }

  public Savepoint setSavepoint() throws HopDatabaseException {
    try {
<span class="nc" id="L4749">      return connection.setSavepoint();</span>
<span class="nc" id="L4750">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4751">      throw new HopDatabaseException(</span>
<span class="nc" id="L4752">        BaseMessages.getString( PKG, &quot;Database.Exception.UnableToSetSavepoint&quot; ), e );</span>
    }
  }

  public Savepoint setSavepoint( String savePointName ) throws HopDatabaseException {
    try {
<span class="nc" id="L4758">      return connection.setSavepoint( savePointName );</span>
<span class="nc" id="L4759">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4760">      throw new HopDatabaseException( BaseMessages.getString(</span>
        PKG, &quot;Database.Exception.UnableToSetSavepointName&quot;, savePointName ), e );
    }
  }

  public void releaseSavepoint( Savepoint savepoint ) throws HopDatabaseException {
    try {
<span class="nc" id="L4767">      connection.releaseSavepoint( savepoint );</span>
<span class="nc" id="L4768">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4769">      throw new HopDatabaseException( BaseMessages.getString(</span>
        PKG, &quot;Database.Exception.UnableToReleaseSavepoint&quot; ), e );
<span class="nc" id="L4771">    }</span>
<span class="nc" id="L4772">  }</span>

  public void rollback( Savepoint savepoint ) throws HopDatabaseException {
    try {
<span class="nc" id="L4776">      connection.rollback( savepoint );</span>
<span class="nc" id="L4777">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4778">      throw new HopDatabaseException( BaseMessages.getString(</span>
        PKG, &quot;Database.Exception.UnableToRollbackToSavepoint&quot; ), e );
<span class="nc" id="L4780">    }</span>
<span class="nc" id="L4781">  }</span>

  public Object getParentObject() {
<span class="nc" id="L4784">    return parentLoggingObject;</span>
  }

  /**
   * Return primary key column names ...
   *
   * @param tablename
   * @throws HopDatabaseException
   */
  public String[] getPrimaryKeyColumnNames( String tablename ) throws HopDatabaseException {
<span class="nc" id="L4794">    List&lt;String&gt; names = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L4795">    ResultSet allkeys = null;</span>
    try {
<span class="nc" id="L4797">      allkeys = getDatabaseMetaData().getPrimaryKeys( null, null, tablename );</span>
<span class="nc bnc" id="L4798" title="All 2 branches missed.">      while ( allkeys.next() ) {</span>
<span class="nc" id="L4799">        String keyname = allkeys.getString( &quot;PK_NAME&quot; );</span>
<span class="nc" id="L4800">        String col_name = allkeys.getString( &quot;COLUMN_NAME&quot; );</span>
<span class="nc bnc" id="L4801" title="All 2 branches missed.">        if ( !names.contains( col_name ) ) {</span>
<span class="nc" id="L4802">          names.add( col_name );</span>
        }
<span class="nc bnc" id="L4804" title="All 2 branches missed.">        if ( log.isRowLevel() ) {</span>
<span class="nc" id="L4805">          log.logRowlevel( toString(), &quot;getting key : &quot; + keyname + &quot; on column &quot; + col_name );</span>
        }
<span class="nc" id="L4807">      }</span>
<span class="nc" id="L4808">    } catch ( SQLException e ) {</span>
<span class="nc" id="L4809">      log.logError( toString(), &quot;Error getting primary keys columns from table [&quot; + tablename + &quot;]&quot; );</span>
    } finally {
      try {
<span class="nc bnc" id="L4812" title="All 2 branches missed.">        if ( allkeys != null ) {</span>
<span class="nc" id="L4813">          allkeys.close();</span>
        }
<span class="nc" id="L4815">      } catch ( SQLException e ) {</span>
<span class="nc" id="L4816">        throw new HopDatabaseException( &quot;Error closing connection while searching primary keys in table [&quot;</span>
          + tablename + &quot;]&quot;, e );
<span class="nc" id="L4818">      }</span>
    }
<span class="nc" id="L4820">    return names.toArray( new String[ names.size() ] );</span>
  }

  /**
   * Return all sequence names from connection
   *
   * @return The sequences name list.
   * @throws HopDatabaseException
   */
  public String[] getSequences() throws HopDatabaseException {
<span class="nc bnc" id="L4830" title="All 2 branches missed.">    if ( databaseMeta.supportsSequences() ) {</span>
<span class="nc" id="L4831">      String sql = databaseMeta.getSqlListOfSequences();</span>
<span class="nc bnc" id="L4832" title="All 2 branches missed.">      if ( sql != null ) {</span>
<span class="nc" id="L4833">        List&lt;Object[]&gt; seqs = getRows( sql, 0 );</span>
<span class="nc" id="L4834">        String[] str = new String[ seqs.size() ];</span>
<span class="nc bnc" id="L4835" title="All 2 branches missed.">        for ( int i = 0; i &lt; seqs.size(); i++ ) {</span>
<span class="nc" id="L4836">          str[ i ] = seqs.get( i )[ 0 ].toString();</span>
        }
<span class="nc" id="L4838">        return str;</span>
      }
<span class="nc" id="L4840">    } else {</span>
<span class="nc" id="L4841">      throw new HopDatabaseException( &quot;Sequences are only available for Oracle databases.&quot; );</span>
    }
<span class="nc" id="L4843">    return null;</span>
  }

  @Override
  public String getFilename() {
<span class="fc" id="L4848">    return null;</span>
  }

  @Override
  public String getLogChannelId() {
<span class="nc" id="L4853">    return log.getLogChannelId();</span>
  }

  @Override
  public String getObjectName() {
<span class="fc" id="L4858">    return databaseMeta.getName();</span>
  }

  @Override
  public String getObjectCopy() {
<span class="fc" id="L4863">    return null;</span>
  }

  @Override
  public LoggingObjectType getObjectType() {
<span class="fc" id="L4868">    return LoggingObjectType.DATABASE;</span>
  }

  @Override
  public ILoggingObject getParent() {
<span class="fc" id="L4873">    return parentLoggingObject;</span>
  }

  @Override
  public LogLevel getLogLevel() {
<span class="fc" id="L4878">    return logLevel;</span>
  }

  public void setLogLevel( LogLevel logLevel ) {
<span class="nc" id="L4882">    this.logLevel = logLevel;</span>
<span class="nc" id="L4883">    log.setLogLevel( logLevel );</span>
<span class="nc" id="L4884">  }</span>

  /**
   * @return the serverObjectId
   */
  @Override
  public String getContainerId() {
<span class="fc" id="L4891">    return containerObjectId;</span>
  }

  /**
   * @param containerObjectId the execution container Object id to set
   */
  public void setContainerObjectId( String containerObjectId ) {
<span class="nc" id="L4898">    this.containerObjectId = containerObjectId;</span>
<span class="nc" id="L4899">  }</span>

  /**
   * Stub
   */
  @Override
  public Date getRegistrationDate() {
<span class="nc" id="L4906">    return null;</span>
  }

  /**
   * @return the nrExecutedCommits
   */
  public int getNrExecutedCommits() {
<span class="nc" id="L4913">    return nrExecutedCommits;</span>
  }

  /**
   * @param nrExecutedCommits the nrExecutedCommits to set
   */
  public void setNrExecutedCommits( int nrExecutedCommits ) {
<span class="nc" id="L4920">    this.nrExecutedCommits = nrExecutedCommits;</span>
<span class="nc" id="L4921">  }</span>

  /**
   * Execute an SQL statement inside a file on the database connection (has to be open)
   *
   * @param filename            the file containing the SQL to execute
   * @param sendSinglestatement set to true if you want to send the whole file as a single statement. If false separate statements will be isolated and executed.
   * @return a Result object indicating the number of lines read, deleted, inserted, updated, ...
   * @throws HopDatabaseException in case anything goes wrong.
   * @sendSinglestatement send one statement
   */
  public Result execStatementsFromFile( String filename, boolean sendSinglestatement ) throws HopException {
<span class="nc" id="L4933">    FileObject sqlFile = null;</span>
<span class="nc" id="L4934">    InputStream is = null;</span>
<span class="nc" id="L4935">    InputStreamReader bis = null;</span>
    try {
<span class="nc bnc" id="L4937" title="All 2 branches missed.">      if ( Utils.isEmpty( filename ) ) {</span>
<span class="nc" id="L4938">        throw new HopException( &quot;Filename is missing!&quot; );</span>
      }
<span class="nc" id="L4940">      sqlFile = HopVfs.getFileObject( filename );</span>
<span class="nc bnc" id="L4941" title="All 2 branches missed.">      if ( !sqlFile.exists() ) {</span>
<span class="nc" id="L4942">        throw new HopException( &quot;We can not find file [&quot; + filename + &quot;]!&quot; );</span>
      }

<span class="nc" id="L4945">      is = HopVfs.getInputStream( sqlFile );</span>
<span class="nc" id="L4946">      bis = new InputStreamReader( new BufferedInputStream( is, 500 ) );</span>
<span class="nc" id="L4947">      StringBuilder lineStringBuilder = new StringBuilder( 256 );</span>
<span class="nc" id="L4948">      lineStringBuilder.setLength( 0 );</span>

<span class="nc" id="L4950">      BufferedReader buff = new BufferedReader( bis );</span>
<span class="nc" id="L4951">      String sLine = null;</span>
<span class="nc" id="L4952">      String sql = Const.CR;</span>

<span class="nc bnc" id="L4954" title="All 2 branches missed.">      while ( ( sLine = buff.readLine() ) != null ) {</span>
<span class="nc bnc" id="L4955" title="All 2 branches missed.">        if ( Utils.isEmpty( sLine ) ) {</span>
<span class="nc" id="L4956">          sql = sql + Const.CR;</span>
        } else {
<span class="nc" id="L4958">          sql = sql + Const.CR + sLine;</span>
        }
      }

<span class="nc bnc" id="L4962" title="All 2 branches missed.">      if ( sendSinglestatement ) {</span>
<span class="nc" id="L4963">        return execStatement( sql );</span>
      } else {
<span class="nc" id="L4965">        return execStatements( sql );</span>
      }

<span class="nc" id="L4968">    } catch ( Exception e ) {</span>
<span class="nc" id="L4969">      throw new HopException( e );</span>
    } finally {
      try {
<span class="nc bnc" id="L4972" title="All 2 branches missed.">        if ( sqlFile != null ) {</span>
<span class="nc" id="L4973">          sqlFile.close();</span>
        }
<span class="nc bnc" id="L4975" title="All 2 branches missed.">        if ( is != null ) {</span>
<span class="nc" id="L4976">          is.close();</span>
        }
<span class="nc bnc" id="L4978" title="All 2 branches missed.">        if ( bis != null ) {</span>
<span class="nc" id="L4979">          bis.close();</span>
        }
<span class="nc" id="L4981">      } catch ( Exception e ) {</span>
        // Ignore
<span class="nc" id="L4983">      }</span>
    }
  }

  @Override
  public boolean isGatheringMetrics() {
<span class="pc bpc" id="L4989" title="3 of 4 branches missed.">    return log != null &amp;&amp; log.isGatheringMetrics();</span>
  }

  @Override
  public void setGatheringMetrics( boolean gatheringMetrics ) {
<span class="nc bnc" id="L4994" title="All 2 branches missed.">    if ( log != null ) {</span>
<span class="nc" id="L4995">      log.setGatheringMetrics( gatheringMetrics );</span>
    }
<span class="nc" id="L4997">  }</span>

  @Override
  public boolean isForcingSeparateLogging() {
<span class="pc bpc" id="L5001" title="3 of 4 branches missed.">    return log != null &amp;&amp; log.isForcingSeparateLogging();</span>
  }

  @Override
  public void setForcingSeparateLogging( boolean forcingSeparateLogging ) {
<span class="nc bnc" id="L5006" title="All 2 branches missed.">    if ( log != null ) {</span>
<span class="nc" id="L5007">      log.setForcingSeparateLogging( forcingSeparateLogging );</span>
    }
<span class="nc" id="L5009">  }</span>

  // Checks to see if the HOP_COMPATIBILITY_USE_JDBC_METADATA is set.  See PDI-17980 for more details.
  private boolean useJdbcMeta() {
<span class="fc" id="L5013">    String useJdbcMeta = this.variables.getVariable( Const.HOP_COMPATIBILITY_USE_JDBC_METADATA, &quot;false&quot; );</span>
<span class="fc" id="L5014">    return Boolean.TRUE.toString().equals( useJdbcMeta );</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>