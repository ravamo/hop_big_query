<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HopJaroWinklerDistance.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Hop Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.hop.core.util</a> &gt; <span class="el_source">HopJaroWinklerDistance.java</span></div><h1>HopJaroWinklerDistance.java</h1><pre class="source lang-java linenums">/*! ******************************************************************************
 *
 * Hop : The Hop Orchestration Platform
 *
 * http://www.project-hop.org
 *
 *******************************************************************************
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/
package org.apache.hop.core.util;

import java.util.Arrays;

/**
 * A similarity algorithm indicating the percentage of matched characters between two character sequences.
 *
 * &lt;p&gt;
 * The Jaro measure is the weighted sum of percentage of matched characters
 * from each file and transposed characters. Winkler increased this measure
 * for matching initial characters.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This implementation is based on the Jaro Winkler similarity algorithm
 * from &lt;a href=&quot;http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance&quot;&gt;
 * http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This code has been adapted from Apache Commons Lang 3.3.
 * &lt;/p&gt;
 *
 * @since 1.0
 */
<span class="nc" id="L47">public class HopJaroWinklerDistance {</span>

  /**
   * Represents a failed index search.
   */
  public static final int INDEX_NOT_FOUND = -1;
<span class="nc" id="L53">  private double j = 0D;</span>
<span class="nc" id="L54">  private double jw = 0D;</span>

  public Double getJaroDistance() {
<span class="nc" id="L57">    return new Double( j );</span>
  }

  public Double getJaroWinklerDistance() {
<span class="nc" id="L61">    return new Double( jw );</span>
  }

  /**
   * Find the Jaro Winkler Distance which indicates the similarity score
   * between two CharSequences.
   *
   * &lt;pre&gt;
   * distance.apply(null, null)          = IllegalArgumentException
   * distance.apply(&quot;&quot;,&quot;&quot;)               = 0.0
   * distance.apply(&quot;&quot;,&quot;a&quot;)              = 0.0
   * distance.apply(&quot;aaapppp&quot;, &quot;&quot;)       = 0.0
   * distance.apply(&quot;frog&quot;, &quot;fog&quot;)       = 0.93
   * distance.apply(&quot;fly&quot;, &quot;ant&quot;)        = 0.0
   * distance.apply(&quot;elephant&quot;, &quot;hippo&quot;) = 0.44
   * distance.apply(&quot;hippo&quot;, &quot;elephant&quot;) = 0.44
   * distance.apply(&quot;hippo&quot;, &quot;zzzzzzzz&quot;) = 0.0
   * distance.apply(&quot;hello&quot;, &quot;hallo&quot;)    = 0.88
   * distance.apply(&quot;ABC Corporation&quot;, &quot;ABC Corp&quot;) = 0.93
   * distance.apply(&quot;D N H Enterprises Inc&quot;, &quot;D &amp;amp; H Enterprises, Inc.&quot;) = 0.95
   * distance.apply(&quot;My Gym Children's Fitness Center&quot;, &quot;My Gym. Childrens Fitness&quot;) = 0.92
   * distance.apply(&quot;PENNSYLVANIA&quot;, &quot;PENNCISYLVNIA&quot;)    = 0.88
   * &lt;/pre&gt;
   *
   * @param left  the first String, must not be null
   * @param right the second String, must not be null
   * @return result distance
   * @throws IllegalArgumentException if either String input {@code null}
   */
  public void apply( final CharSequence left, final CharSequence right ) {
<span class="nc" id="L91">    final double defaultScalingFactor = 0.1;</span>

<span class="nc bnc" id="L93" title="All 4 branches missed.">    if ( left == null || right == null ) {</span>
<span class="nc" id="L94">      throw new IllegalArgumentException( &quot;Strings must not be null&quot; );</span>
    }

<span class="nc" id="L97">    final int[] mtp = matches( left, right );</span>
<span class="nc" id="L98">    final double m = mtp[ 0 ];</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">    if ( m == 0 ) {</span>
<span class="nc" id="L100">      j = 0D;</span>
<span class="nc" id="L101">      jw = 0D;</span>
    } else {
<span class="nc" id="L103">      j = ( ( m / left.length() + m / right.length() + ( m - mtp[ 1 ] ) / m ) ) / 3;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      jw = j &lt; 0.7D ? j : j + Math.min( defaultScalingFactor, 1D / mtp[ 3 ] ) * mtp[ 2 ] * ( 1D - j );</span>
    }
<span class="nc" id="L106">  }</span>

  /**
   * This method returns the Jaro-Winkler string matches, transpositions, prefix, max array.
   *
   * @param first  the first string to be matched
   * @param second the second string to be matched
   * @return mtp array containing: matches, transpositions, prefix, and max length
   */
  protected static int[] matches( final CharSequence first, final CharSequence second ) {
    CharSequence max, min;
<span class="nc bnc" id="L117" title="All 2 branches missed.">    if ( first.length() &gt; second.length() ) {</span>
<span class="nc" id="L118">      max = first;</span>
<span class="nc" id="L119">      min = second;</span>
    } else {
<span class="nc" id="L121">      max = second;</span>
<span class="nc" id="L122">      min = first;</span>
    }
<span class="nc" id="L124">    final int range = Math.max( max.length() / 2 - 1, 0 );</span>
<span class="nc" id="L125">    final int[] matchIndexes = new int[ min.length() ];</span>
<span class="nc" id="L126">    Arrays.fill( matchIndexes, -1 );</span>
<span class="nc" id="L127">    final boolean[] matchFlags = new boolean[ max.length() ];</span>
<span class="nc" id="L128">    int matches = 0;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">    for ( int mi = 0; mi &lt; min.length(); mi++ ) {</span>
<span class="nc" id="L130">      final char c1 = min.charAt( mi );</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">      for ( int xi = Math.max( mi - range, 0 ), xn = Math.min( mi + range + 1, max.length() ); xi &lt; xn; xi++ ) {</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">        if ( !matchFlags[ xi ] &amp;&amp; c1 == max.charAt( xi ) ) {</span>
<span class="nc" id="L133">          matchIndexes[ mi ] = xi;</span>
<span class="nc" id="L134">          matchFlags[ xi ] = true;</span>
<span class="nc" id="L135">          matches++;</span>
<span class="nc" id="L136">          break;</span>
        }
      }
    }
<span class="nc" id="L140">    final char[] ms1 = new char[ matches ];</span>
<span class="nc" id="L141">    final char[] ms2 = new char[ matches ];</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    for ( int i = 0, si = 0; i &lt; min.length(); i++ ) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if ( matchIndexes[ i ] != -1 ) {</span>
<span class="nc" id="L144">        ms1[ si ] = min.charAt( i );</span>
<span class="nc" id="L145">        si++;</span>
      }
    }
<span class="nc bnc" id="L148" title="All 2 branches missed.">    for ( int i = 0, si = 0; i &lt; max.length(); i++ ) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">      if ( matchFlags[ i ] ) {</span>
<span class="nc" id="L150">        ms2[ si ] = max.charAt( i );</span>
<span class="nc" id="L151">        si++;</span>
      }
    }
<span class="nc" id="L154">    int transpositions = 0;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">    for ( int mi = 0; mi &lt; ms1.length; mi++ ) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">      if ( ms1[ mi ] != ms2[ mi ] ) {</span>
<span class="nc" id="L157">        transpositions++;</span>
      }
    }
<span class="nc" id="L160">    int prefix = 0;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">    for ( int mi = 0; mi &lt; min.length(); mi++ ) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      if ( first.charAt( mi ) == second.charAt( mi ) ) {</span>
<span class="nc" id="L163">        prefix++;</span>
      } else {
        break;
      }
    }
<span class="nc" id="L168">    return new int[] { matches, transpositions / 2, prefix, max.length() };</span>
  }

  public void reset() {
<span class="nc" id="L172">    j = 0D;</span>
<span class="nc" id="L173">    jw = 0D;</span>
<span class="nc" id="L174">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>